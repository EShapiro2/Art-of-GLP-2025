\documentclass[11pt,a4paper,openright]{memoir}

%% ============================================
%% PACKAGES
%% ============================================

\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{amsthm}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{mdframed}
\usepackage{multirow}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

%% ============================================
%% MEMOIR SETTINGS
%% ============================================

\chapterstyle{madsen}
\setlength{\beforechapskip}{50pt}
\setlength{\afterchapskip}{40pt}
\raggedbottom

%% ============================================
%% COMMANDS (from paper)
%% ============================================

\newcommand{\GLP}{\textsc{GLP}\xspace}
\newcommand{\mypara}[1]{\smallskip\noindent\textbf{#1.}}
\newcommand{\temph}[1]{\textbf{#1}}
\newcommand{\remove}[1]{}

% Math commands
\newcommand{\calV}{\mathcal{V}}
\newcommand{\calG}{\mathcal{G}}
\newcommand{\calT}{\mathcal{T}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calR}{\mathbb{R}}
\newcommand{\calN}{\mathbb{N}}
\newcommand{\calA}{\mathcal{A}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\calS}{\mathcal{S}}
\newcommand{\calL}{\mathcal{L}}
\newcommand{\calP}{\mathcal{P}}
\newcommand{\calM}{\mathcal{M}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\calB}{\mathcal{B}}
\newcommand{\calC}{\mathcal{C}}
\newcommand{\calX}{\mathcal{X}}
\newcommand{\calD}{\mathcal{D}}

% Program counter
\newcounter{programcounter}[chapter]
\renewcommand{\theprogramcounter}{\thechapter.\arabic{programcounter}}
\newcommand{\Program}[1]{%
  \refstepcounter{programcounter}%
  \medskip\noindent\textbf{Program \theprogramcounter: #1}\par\nopagebreak
}

% List settings
\setlist{nosep, leftmargin=*}

% Theorem environments
\newtheorem{observation}{Observation}[chapter]
\newtheorem{definition}{Definition}[chapter]
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{lemma}[definition]{Lemma}

%% ============================================
%% FORMAL TRACK ENVIRONMENT
%% ============================================

\newcounter{formalbox}[chapter]
\renewcommand{\theformalbox}{\thechapter.\arabic{formalbox}}

\newenvironment{formal}[1]{%
  \refstepcounter{formalbox}%
  \begin{mdframed}[
    backgroundcolor=gray!10,
    linewidth=1pt,
    linecolor=gray!50,
    innertopmargin=10pt,
    innerbottommargin=10pt,
    innerleftmargin=10pt,
    innerrightmargin=10pt,
    skipabove=\baselineskip,
    skipbelow=\baselineskip
  ]
  \noindent\textbf{Formal \theformalbox: #1}\par\smallskip
}{%
  \end{mdframed}
}

%% ============================================
%% DOCUMENT
%% ============================================

\begin{document}

%% ============================================
%% TITLE PAGE
%% ============================================

\thispagestyle{empty}
\begin{center}
\vspace*{3cm}

{\Huge\bfseries The Art of\\[0.5cm] Grassroots Logic Programming}

\vspace{3cm}

{\Large Ehud Shapiro}

\vspace{1cm}

{\large London School of Economics\\and\\Weizmann Institute of Science}

\vfill

{\large 2025}

\end{center}
\cleardoublepage

%% ============================================
%% FRONT MATTER
%% ============================================

\frontmatter

\chapter{Preface}

This book presents \GLP, a secure, multiagent, concurrent logic programming language designed for implementing grassroots platforms.

[Preface to be written]

\chapter{How to Read This Book}

This book has two parallel tracks: an \emph{informal track} and a \emph{formal track}.

\section*{The Informal Track}

The informal track provides intuitive explanations, examples, and programming techniques. It is comprehensive and self-contained. Most readers should follow this track.

\section*{The Formal Track}

The formal track provides precise mathematical definitions and proofs. It appears in shaded boxes labeled ``Formal X.Y'' throughout the text.

\begin{formal}{Example Formal Box}
This is what a formal box looks like. Readers who prefer intuition can skip these boxes entirely.
\end{formal}

\section*{Book Organization}

The book is organized in two parts:

\textbf{Part I: Concurrent GLP} covers single-agent concurrent logic programming, including the core language, programming techniques, and simulation of multiagent systems.

\textbf{Part II: Multiagent GLP} covers distributed multiagent systems, security, and grassroots protocols. [To be developed]

\tableofcontents

%% ============================================
%% MAIN MATTER
%% ============================================

\mainmatter

%% ============================================
%% PART I: CONCURRENT GLP
%% ============================================

\part{Concurrent GLP}

\chapter{Introduction}

[Introduction chapter to be developed]

\section{The Grassroots Vision}

Grassroots platforms are distributed applications run by cryptographically-identified people on their networked personal devices, where multiple disjoint platform instances emerge independently and coalesce when they interoperate.

\section{Why GLP?}

\GLP extends logic programs with paired single-reader/single-writer variables, providing secure communication channels among cryptographically-identified people.

\section{A First Example: Merge}

\Program{Fair Stream Merger}
\begin{verbatim}
merge([X|Xs],Ys,[X?|Zs?]) :- merge(Ys?,Xs?,Zs).
merge(Xs,[Y|Ys],[Y?|Zs?]) :- merge(Xs?,Ys?,Zs).
merge([],[],[]).
\end{verbatim}

\chapter{Logic Programs}

[Logic programs chapter to be developed]

\chapter{GLP Core}

[GLP core concepts chapter to be developed]

\chapter{GLP Computation}

[GLP computation chapter to be developed]

\chapter{Streams}

[Streams chapter to be developed]

\chapter{Programming Techniques}
\label{ch:techniques}

This chapter presents programming techniques that exploit \GLP's concurrent execution model.

\section{Programming with Constants}

The simplest \GLP programs transform constant values. These programs illustrate fundamental patterns of reader/writer variable usage and clause selection.

\subsection{Unary Predicates}

A unary predicate with one reader parameter defines a property:

\begin{verbatim}
zero(0).
one(1).
positive(1).
\end{verbatim}

These succeed when called with matching constants:

\begin{verbatim}
GLP> zero(0).
zero(0) :- true
-> succeeds

GLP> zero(1).
-> fails (no matching clause)

GLP> positive(1).
positive(1) :- true
-> succeeds
\end{verbatim}

A unary predicate with one writer parameter generates a value:

\begin{verbatim}
default_value(42?).
initial_state(ready?).
\end{verbatim}

\begin{verbatim}
GLP> default_value(X).
default_value(X) :- true
X = 42
-> succeeds
\end{verbatim}

\subsection{Parameter Passing Patterns}

Binary predicates combine input and output parameters. The most common pattern: reader for input, writer for output.

\begin{verbatim}
successor(0, 1?).
successor(1, 2?).
successor(2, 3?).
\end{verbatim}

\begin{verbatim}
GLP> successor(0, X).
successor(0, X) :- true
X = 1
-> succeeds

GLP> successor(2, X).
successor(2, X) :- true
X = 3
-> succeeds

GLP> successor(5, X).
-> fails (no matching clause)
\end{verbatim}

Multiple outputs use multiple writers:

\begin{verbatim}
decompose(10, 1?, 0?).
decompose(23, 2?, 3?).
\end{verbatim}

\begin{verbatim}
GLP> decompose(23, Tens, Units).
decompose(23, Tens, Units) :- true
Tens = 2
Units = 3
-> succeeds
\end{verbatim}

\subsection{Clause Selection by Mode}

Readers in clause heads enable pattern matching---clause selection based on input values.

\begin{verbatim}
color_code(red, 1?).
color_code(green, 2?).
color_code(blue, 3?).
\end{verbatim}

The first argument (reader) selects the clause; the second (writer) delivers the result:

\begin{verbatim}
GLP> color_code(red, X).
color_code(red, X) :- true
X = 1
-> succeeds

GLP> color_code(blue, X).
color_code(blue, X) :- true
X = 3
-> succeeds
\end{verbatim}

Multiple readers enable multi-way dispatch:

\begin{verbatim}
combine(red, blue, purple?).
combine(red, yellow, orange?).
combine(blue, yellow, green?).
\end{verbatim}

\begin{verbatim}
GLP> combine(red, blue, X).
combine(red, blue, X) :- true
X = purple
-> succeeds

GLP> combine(blue, yellow, X).
combine(blue, yellow, X) :- true
X = green
-> succeeds
\end{verbatim}

\subsection{Bidirectional Predicates}

Some predicates work in multiple modes. The \verb|not| gate from the next section is bidirectional:

\begin{verbatim}
not(1, 0).
not(0, 1).
\end{verbatim}

With both parameters as readers, either can drive clause selection:

\begin{verbatim}
GLP> not(1, X).
not(1, X) :- true
X = 0
-> succeeds

GLP> not(X, 1).
not(X, 1) :- true
X = 0
-> succeeds
\end{verbatim}

However, with both unbound:

\begin{verbatim}
GLP> not(X, Y).
-> suspended (waiting for binding)
\end{verbatim}

The goal suspends because no clause head uniquely matches. This demonstrates \GLP's data-driven execution: computation proceeds when sufficient input is available.

\section{Logic Gates}

Digital circuits provide a natural example of dataflow computation. We define basic gates as facts:

\begin{verbatim}
and(1,1,1).
and(1,0,0).
and(0,1,0).
and(0,0,0).

or(1,1,1).
or(1,0,1).
or(0,1,1).
or(0,0,0).

not(1,0).
not(0,1).

xor(1,1,0).
xor(1,0,1).
xor(0,1,1).
xor(0,0,0).
\end{verbatim}

Each gate suspends until its inputs are bound:

\begin{verbatim}
GLP> and(1,1,X).
and(1,1,X) :- true
X = 1
-> succeeds

GLP> and(1,0,X).
and(1,0,X) :- true
X = 0
-> succeeds
\end{verbatim}

Compound gates compose simpler ones. Note the output parameter pattern: the reader \verb|Z?| in the head receives the goal's variable, and the writer \verb|Z| in the body produces the value.

\begin{verbatim}
nand(A,B,Z?) :- and(A?,B?,W), not(W?,Z).
\end{verbatim}

\begin{verbatim}
GLP> nand(1,1,X).
nand(1,1,X) :- and(1,1,X1), not(X1?,X2)
and(1,1,X1) :- true
not(1,X2) :- true
X = 0
-> succeeds

GLP> nand(0,1,X).
nand(0,1,X) :- and(0,1,X1), not(X1?,X2)
and(0,1,X1) :- true
not(0,X2) :- true
X = 1
-> succeeds
\end{verbatim}

A half-adder takes two input bits and produces a sum and carry. Since \verb|A?| and \verb|B?| each appear twice in the body (in both \verb|xor| and \verb|and|), we need \verb|ground| guards:

\begin{verbatim}
half_adder(A,B,Sum?,Carry?) :-
    ground(A?), ground(B?) |
    xor(A?,B?,Sum), and(A?,B?,Carry).
\end{verbatim}

\begin{verbatim}
GLP> half_adder(1,1,S,C).
half_adder(1,1,S,C) :- xor(1,1,X1), and(1,1,X2)
xor(1,1,X1) :- true
and(1,1,X2) :- true
S = 0
C = 1
-> succeeds

GLP> half_adder(1,0,S,C).
half_adder(1,0,S,C) :- xor(1,0,X1), and(1,0,X2)
xor(1,0,X1) :- true
and(1,0,X2) :- true
S = 1
C = 0
-> succeeds
\end{verbatim}

A full-adder adds three bits: two inputs and a carry-in. Each reader appears only once in the body, so no guards are needed:

\begin{verbatim}
full_adder(A,B,Cin,Sum?,Cout?) :-
    half_adder(A?,B?,S1,C1),
    half_adder(S1?,Cin?,Sum,C2),
    or(C1?,C2?,Cout).
\end{verbatim}

The trace shows dataflow: the second half-adder and \verb|or| suspend until the first half-adder produces results:

\begin{verbatim}
GLP> full_adder(1,1,1,S,C).
full_adder(1,1,1,S,C) :- half_adder(1,1,X1,X2),
    half_adder(X1?,1,X3,X4), or(X2?,X4?,X5)
half_adder(1,1,X1,X2) :- xor(1,1,X6), and(1,1,X7)
half_adder(X1?,1,X3,X4) -> suspended
or(X2?,X4?,X5) -> suspended
xor(1,1,X6) :- true
and(1,1,X7) :- true
half_adder(0,1,X3,X4) :- xor(0,1,X8), and(0,1,X9)
or(1,X4?,X5) -> suspended
xor(0,1,X8) :- true
and(0,1,X9) :- true
or(1,0,X5) :- true
S = 1
C = 1
-> succeeds
\end{verbatim}

An n-bit ripple-carry adder chains full-adders, with each stage's carry-out feeding the next stage's carry-in:

\begin{verbatim}
adder([],[],Cin,[Cin?]).
adder([A|As],[B|Bs],Cin,[S?|Ss?]) :-
    full_adder(A?,B?,Cin?,S,Cout),
    adder(As?,Bs?,Cout?,Ss).
\end{verbatim}

Adding 101 + 110 (5 + 6, LSB first):

\begin{verbatim}
GLP> adder([1,0,1],[1,1,0],0,R).
adder([1,0,1],[1,1,0],0,R) :- full_adder(1,1,0,X1,X2),
    adder([0,1],[1,0],X2?,X3)
full_adder(1,1,0,X1,X2) :- half_adder(1,1,X4,X5),
    half_adder(X4?,0,X6,X7), or(X5?,X7?,X8)
adder([0,1],[1,0],X2?,X3) -> suspended
half_adder(1,1,X4,X5) :- xor(1,1,X9), and(1,1,X10)
half_adder(X4?,0,X6,X7) -> suspended
or(X5?,X7?,X8) -> suspended
xor(1,1,X9) :- true
and(1,1,X10) :- true
half_adder(0,0,X6,X7) :- xor(0,0,X11), and(0,0,X12)
or(1,X7?,X8) -> suspended
xor(0,0,X11) :- true
and(0,0,X12) :- true
or(1,0,X8) :- true
adder([0,1],[1,0],1,X3) :- full_adder(0,1,1,X13,X14),
    adder([1],[0],X14?,X15)
...
R = [0,0,0,1]
-> succeeds
\end{verbatim}

The result \verb|[0,0,0,1]| is 1011 in binary (LSB first), which is 11 in decimal: $5 + 6 = 11$.

The trace shows the ripple-carry behavior: each \verb|adder| stage suspends waiting for the carry from the previous stage, then reactivates when the carry arrives.

\chapter{Simulating Multiagent Systems}
\label{ch:plays}

Part II of this book covers true multiagent \GLP---distributed agents on separate devices communicating over networks. But we can \emph{simulate} multiagent systems within single-agent \GLP, enabling development and testing before deployment.

This chapter introduces \emph{plays}: a theater-inspired framework for simulating and testing multiagent protocols.

\section{The Testing Challenge}

Testing distributed multiagent systems presents unique challenges:
\begin{itemize}
\item Agents cannot directly observe each other's internal state
\item Actions are causally linked rather than sequentially ordered
\item Nondeterminism must be controlled for reproducible tests
\item Network delays and failures add complexity
\end{itemize}

We address these challenges by simulating the entire system---multiple agents, users, and network---within a single \GLP computation.

\section{Theater-Style Testing}

We adopt a testing methodology inspired by theater. Each test scenario is a \emph{play} with \emph{actors} following a \emph{script}.

\begin{center}
\begin{tabular}{lll}
\textbf{Term} & \textbf{Role} & \textbf{Implementation} \\
\hline
Agent & Personal agent (code under test) & GLP process \\
Actor & Simulated user following script & GLP process \\
Play & Complete test scenario & Directory with files \\
Script & Human-readable test description & Structured English \\
\end{tabular}
\end{center}

The architecture for each simulated person:
\begin{verbatim}
    Actor (simulated user)
        |
   user channel
        |
        v
    Agent (code under test) <-- network channel --> Network
\end{verbatim}

\section{Scripts}

Scripts describe causal sequences using phrases like ``after seeing X, do Y'':

\begin{verbatim}
Title: Alice and Bob become friends via cold call
Actors: Alice, Bob

---
Scene 1: Alice initiates

Alice says to her agent: connect(bob)

---
Scene 2: Bob receives offer

Bob's agent says to Bob: befriend(alice, Resp)
Bob says to his agent: decision(yes, alice, Resp)

---
Scene 3: Connection established

Alice's agent establishes friend channel to Bob
Alice says to her agent: send(bob, hello)

---
Scene 4: Message delivered

Bob's agent says to Bob: msg(alice, hello)
Bob: done
\end{verbatim}

\section{Actors}

Actors are strict, deterministic \GLP processes. Each script step becomes one clause. Unexpected messages cause failure---there are no \texttt{otherwise} guards.

\Program{Alice's Actor for Cold Call}
\begin{verbatim}
% Step 1: Initiate connection to bob
alice(ch(In, [connect(bob)|Out?])) :-
    alice_wait(In?, Out).

% Step 2: After response, send hello
alice_wait([response(_)|In], [send(bob, hello)|Out?]) :-
    alice_done(In?, Out).

% Step 3: Done - close output stream
alice_done(_, []).
\end{verbatim}

Key principles:
\begin{enumerate}
\item Each script step = one clause
\item Unexpected messages $\rightarrow$ no clause matches $\rightarrow$ goal suspends (test fails)
\item Clean termination: output streams closed with \texttt{[]}
\end{enumerate}

\section{Channels}

Communication uses bidirectional channels:

\Program{Channel Operations}
\begin{verbatim}
send(X, ch(In, [X?|Out?]), ch(In?, Out)).
receive(X?, ch([X|In], Out?), ch(In?, Out)).
new_channel(ch(Xs?, Ys), ch(Ys?, Xs)).
\end{verbatim}

A channel \texttt{ch(In, Out)} has an input stream \texttt{In} (messages received) and output stream \texttt{Out} (messages sent). The \texttt{new\_channel} predicate creates a paired channel where each end's output is the other's input.

\section{Network Simulation}

For two-agent tests, a simple network switch routes messages:

\Program{Two-Agent Network}
\begin{verbatim}
network((P, ChP), (Q, ChQ)) :-
    receive(msg(To, X)?, ChP?, ChP1),
    To = Q |
    send(X?, ChQ?, ChQ1),
    network((P?, ChP1?), (Q?, ChQ1?)).

network((P, ChP), (Q, ChQ)) :-
    receive(msg(To, X)?, ChQ?, ChQ1),
    To = P |
    send(X?, ChP?, ChP1),
    network((P?, ChP1?), (Q?, ChQ1?)).
\end{verbatim}

Messages are tagged with destination; the network routes accordingly.

\section{Stream Observation}

To verify test execution, we observe message streams without consuming them:

\Program{Stream Observer}
\begin{verbatim}
observe([], [], []).
observe([X|Xs], [X?|Ys?], [X?|Zs?]) :-
    observe(Xs?, Ys, Zs).
\end{verbatim}

This creates two copies of a stream for observation. One copy goes to the agent; the other becomes a trace for verification.

\begin{formal}{SRSW and Stream Observation}
The \texttt{observe} program appears to violate SRSW: the reader \texttt{X?} occurs twice in the second clause head. However, when \texttt{X} is bound to a ground term, the SRSW constraint on readers can be relaxed---a ground value can safely be copied.

The guard \texttt{ground(X)} explicitly enables this relaxation:
\begin{verbatim}
observe([X|Xs], [Y1?|Ys1?], [Y2?|Ys2?]) :-
    ground(X?) |
    Y1 = X?, Y2 = X?,
    observe(Xs?, Ys1, Ys2).
\end{verbatim}
\end{formal}

\section{Test Harness}

The test harness wires together channels, network, agents, and actors:

\Program{Cold Call Test Harness}
\begin{verbatim}
test(AliceTrace?, BobTrace?) :-
    % Create channels
    new_channel(NetA, ANet),
    new_channel(NetB, BNet),
    new_channel(UserA, AUser),
    new_channel(UserB, BUser),

    % Observe user channels for traces
    AUser = ch(AIn, AOut),
    observe(AIn?, AInCopy, AliceTrace),
    BUser = ch(BIn, BOut),
    observe(BIn?, BInCopy, BobTrace),

    % Start network
    network((alice, NetA?), (bob, NetB?)),

    % Start agents
    agent(alice, ch(AInCopy?, AOut?), ANet?),
    agent(bob, ch(BInCopy?, BOut?), BNet?),

    % Start actors
    alice_actor(UserA?),
    bob_actor(UserB?).
\end{verbatim}

Running \texttt{test(AliceTrace, BobTrace)} executes the entire simulation. The traces capture all messages for verification.

\section{Verification}

After a test completes:
\begin{enumerate}
\item Check that traces contain expected messages in order
\item Verify final channel bindings match expected state
\item Confirm clean termination (no suspended goals)
\end{enumerate}

A suspended goal indicates the script didn't match reality---either a bug in the agent code or an incorrect script.

\section{From Simulation to Reality}

The plays framework provides a development path:
\begin{enumerate}
\item \textbf{Design}: Write the script in structured English
\item \textbf{Implement}: Code actors and agents
\item \textbf{Test}: Run simulation, verify traces
\item \textbf{Deploy}: Replace simulated network with real network (Part II)
\end{enumerate}

The agent code remains unchanged between simulation and deployment---only the network layer changes.

\section{Exercises}

\begin{enumerate}
\item[$\star$] Write a script for a three-person introduction: Alice introduces Bob to Carol.

\item[$\star$] Implement the actors for a message rejection scenario: Bob refuses Alice's friend request.

\item[$\star\star$] Extend the network simulation to handle message delays (messages arrive after $n$ steps).

\item[$\star\star$] Design a test for group formation with four participants.

\item[$\star\star\star$] Implement an ``adversarial actor'' that tries to violate the protocol. Verify the agent correctly rejects invalid messages.
\end{enumerate}

%% ============================================
%% PART II: MULTIAGENT GLP (placeholder)
%% ============================================

\part{Multiagent GLP}

[Part II to be developed]

%% ============================================
%% BACK MATTER
%% ============================================

\backmatter

\bibliographystyle{plain}
\bibliography{bib}

\end{document}
