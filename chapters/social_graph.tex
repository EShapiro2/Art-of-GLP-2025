% chapters/social_graph.tex - The Grassroots Social Graph

\chapter{The Grassroots Social Graph}
\label{ch:social-graph}

This chapter presents the grassroots social graph---the foundation for all grassroots platforms. We show how agents establish authenticated friendships through cold-call and friend-mediated introduction protocols.

\section{Graph Structure}
\label{sec:graph-structure}

The grassroots social graph is a distributed graph where:
\begin{itemize}
\item Nodes represent cryptographically-identified agents
\item Edges represent authenticated bidirectional channels
\item Connected components arise spontaneously and merge through befriending
\end{itemize}

Each agent runs on a personal device and maintains its portion of the graph: its identity (keypair), its friend list (authenticated connections), and the \GLP runtime.

\section{Agent Initialization}
\label{sec:agent-init}

Each agent begins with the goal \verb|agent(Id, ChUser, ChNet)| where \verb|Id| is the agent's unique identifier, \verb|ChUser| provides bidirectional communication with the user interface, and \verb|ChNet| connects to the network:

\begin{verbatim}
agent(Id, ChUser, ChNet) :-
    ChUser = ch(UserIn, UserOut), ChNet = ch(NetIn, NetOut) |
    merge(UserIn?, NetIn?, In),
    social_graph(Id?, In?, [(user, UserOut), (net, NetOut)]).
\end{verbatim}

The initialization extracts input and output streams from user and network channels, merges inputs into a unified stream \verb|In|, and stores output streams in the initial friends list with special identifiers \verb|user| and \verb|net|.

The \verb|social_graph| predicate is the main event loop, processing messages from the merged input stream. Its arguments are: the agent's identity, the input message stream, and the friends list (an association list mapping names to output streams).

\section{Cold-Call Befriending Protocol}
\label{sec:cold-call}

The cold-call protocol enables agents to establish friendship without prior shared variables. It proceeds in four phases: user initiation, offer transmission, user consultation, and channel establishment.

\subsection{User Initiation}

When the user requests connection to a target agent:

\begin{verbatim}
social_graph(Id, [msg(user, Id?, connect(Target))|In], Fs) :-
    ground(Id?), ground(Target?) |
    send_and_setup_response(Id?, Target?, Fs?, Fs1, In?, In1),
    social_graph(Id?, In1?, Fs1?).

send_and_setup_response(Id, Target, Fs, Fs1?, In, In1?) :-
    atom(Id?), atom(Target?) |
    lookup_send(net, msg(Id?, Target?, intro(Id?, Id?, Resp)), Fs?, Fs1),
    setup_inject(Resp?, Target?, Id?, In?, In1).

setup_inject(Resp, Target, Id, In, In1?) :-
    atom(Target?), atom(Id?) |
    inject(Resp?, msg(Target?, Id?, response(Resp)), In?, In1).
\end{verbatim}

The agent sends an introduction message through the network channel containing its identity and a fresh response variable \verb|Resp|. The helper predicates \verb|send_and_setup_response| and \verb|setup_inject| ensure SRSW compliance by isolating each reader variable occurrence. The \verb|inject| predicate defers insertion of the response into the input stream until \verb|Resp| becomes bound.

\subsection{Processing Received Introductions}

When an agent receives a self-introduction:

\begin{verbatim}
social_graph(Id, [msg(From, Id?, intro(From?, From?, Resp))|In], Fs) :-
    ground(Id?), ground(From?) |
    lookup_send(user, msg(agent, user, befriend(From?, Resp)), Fs?, Fs1),
    social_graph(Id?, In?, Fs1?).
\end{verbatim}

In deployment, an \verb|attestation| guard would verify the introduction carries a valid signature from the claimed sender. In GLPSAM simulation, we assume all agents are correct, so attestation guards are omitted. Upon receiving the introduction, the agent consults the user about whether to accept.

\subsection{User Decision and Channel Establishment}

When the user decides:

\begin{verbatim}
social_graph(Id, [msg(user, Id?, decision(Dec, From, Resp?))|In], Fs) :-
    ground(Id?) |
    bind_response(Dec?, From?, Resp, Fs?, Fs1, In?, In1),
    social_graph(Id?, In1?, Fs1?).
\end{verbatim}

The \verb|bind_response| predicate handles both acceptance and rejection:

\begin{verbatim}
bind_response(yes, From, Out?, Fs, Fs1?, In, In1?) :-
    atom(From?),
    new_channel(ch(FIn, FOut), FCh) |
    wrap_accept(FCh?, Out),
    handle_accept(From?, ch(FIn?, FOut?), Fs?, Fs1, In?, In1).
bind_response(no, _, no, Fs, Fs?, In, In?).

wrap_accept(Ch, accept(Ch?)).
\end{verbatim}

On acceptance, \verb|new_channel| creates a pair of connected channels. The \verb|wrap_accept| helper binds the output to an \verb|accept| wrapper containing the channel, ensuring single-writer use. The acceptor keeps one half and sends the other to the initiator via the response variable.

\subsection{Establishing the Connection}

The \verb|handle_accept| predicate completes channel establishment for the accepting agent:

\begin{verbatim}
handle_accept(From, ch(FIn, FOut), Fs, Fs1?, In, In1?) :-
    atom(From?) |
    tag_stream(From?, FIn?, Tagged),
    merge(In?, Tagged?, In1),
    add_friend(From?, FOut?, Fs?, Fs1).
\end{verbatim}

The \verb|handle_response| predicate handles responses for the initiating agent:

\begin{verbatim}
handle_response(accept(ch(FIn, FOut)), From, Fs, Fs1?, In, In1?) :-
    atom(From?) |
    tag_stream(From?, FIn?, Tagged),
    merge(In?, Tagged?, In1),
    add_friend(From?, FOut?, Fs?, Fs1).
handle_response(no, _, Fs, Fs?, In, In?).

add_friend(Name, Out, Fs, [(Name?, Out?)|Fs?]).
\end{verbatim}

On acceptance, the friend's output stream is added to the friends list via \verb|add_friend|, and the friend's input stream (tagged with the friend's identity) is merged into the main input stream.

\subsection{The Inject Predicate}
\label{sec:inject-pattern}

The \verb|inject| predicate defers message insertion until a trigger variable becomes bound:

\begin{verbatim}
inject(X, Y, Ys, [Y?|Ys?]) :- ground(X?) | true.
inject(X, Y, [Y1|Ys], [Y1?|Ys1?]) :- writer(X) | inject(X?, Y?, Ys?, Ys1).
\end{verbatim}

The \verb|ground(X?)| guard succeeds when \verb|X| is bound to a ground term. The \verb|writer(X)| guard succeeds when \verb|X| is still an unbound writer variable. When \verb|X| is unbound, messages pass through unchanged. When \verb|X| becomes bound, the deferred message \verb|Y| is inserted. This enables non-blocking protocol operation where a response must be processed at a later time.

\section{Friend-Mediated Introduction}
\label{sec:friend-intro}

When agent $r$ is friends with both $p$ and $q$, $r$ can introduce them. This leverages existing trust relationships.

\subsection{Initiating an Introduction}

The introducer creates channel pairs and sends invitations:

\begin{verbatim}
social_graph(Id, [msg(user, Id?, introduce(P, Q))|In], Fs) :-
    ground(Id?), ground(P?), ground(Q?),
    new_channel(ch(PQIn, PQOut), ch(QPIn, QPOut)) |
    lookup_send(P?, msg(Id?, P?, intro(Q?, ch(QPIn?, PQOut?))), Fs?, Fs1),
    lookup_send(Q?, msg(Id?, Q?, intro(P?, ch(PQIn?, QPOut?))), Fs1?, Fs2),
    social_graph(Id?, In?, Fs2?).
\end{verbatim}

Each party receives one half of the channel pair, enabling direct communication once both accept.

\subsection{Processing the Introduction}

Recipients verify the introduction came from a trusted friend. In GLPSAM simulation, attestation guards are omitted:

\begin{verbatim}
social_graph(Id, [msg(From, Id?, intro(Other, Ch))|In], Fs) :-
    ground(Id?), ground(From?), ground(Other?) |
    lookup_send(user, msg(agent, user,
        befriend_intro(From?, Other?, Ch?)), Fs?, Fs1),
    social_graph(Id?, In?, Fs1?).
\end{verbatim}

The user is consulted about whether to accept the introduction.

\subsection{Accepting or Rejecting the Introduction}

When the user accepts:

\begin{verbatim}
social_graph(Id, [msg(user, Id?, accept_intro(Other, ch(FIn, FOut)))|In], Fs) :-
    ground(Id?), ground(Other?) |
    tag_stream(Other?, FIn?, Tagged),
    merge(In?, Tagged?, In1),
    add_friend(Other?, FOut?, Fs?, Fs1),
    social_graph(Id?, In1?, Fs1?).
\end{verbatim}

When the user rejects:

\begin{verbatim}
social_graph(Id, [msg(user, Id?, reject_intro(_, _))|In], Fs) :-
    ground(Id?) |
    social_graph(Id?, In?, Fs?).
\end{verbatim}

Upon acceptance, the provided channel is added to the friends list and its input merged into the main stream.

\section{Defined Guards for Channels}
\label{sec:channel-guards}

Channel operations are defined as unit clauses, serving as defined guards when used in guard position:

\begin{verbatim}
send(X, ch(In, [X?|Out?]), ch(In?, Out)).
receive(X?, ch([X|In], Out?), ch(In?, Out)).
new_channel(ch(Xs?, Ys), ch(Ys?, Xs)).
\end{verbatim}

The \verb|send| operation adds a message to the output stream. The \verb|receive| operation removes a message from the input stream. The \verb|new_channel| operation creates a pair of connected channels where each channel's input is the other's output.

These definitions follow the GLP mechanism for defined guards: when a unit clause appears in guard position, it unfolds to equality tests against its arguments.

\section{Utility Predicates}
\label{sec:social-graph-utilities}

The social graph protocol uses several utility predicates:

\begin{verbatim}
lookup(Key, [(Key?, Value?)|_], Value).
lookup(Key, [(K, _)|Rest], Value) :-
    Key? \= K? | lookup(Key?, Rest?, Value).

lookup_send(Key, Msg, Fs, Fs1) :-
    lookup(Key?, Fs?, (_, Out)),
    Out = [Msg?|Out1?],
    update(Key?, Out1, Fs?, Fs1).

tag_stream(Name, [M|In], [msg(Name?, M?)|Out?]) :-
    atom(Name?) | tag_stream(Name?, In?, Out).
tag_stream(_, [], []).
\end{verbatim}

The \verb|lookup| predicate finds a value in an association list. The \verb|lookup_send| predicate sends a message through the channel associated with a key and updates the friends list with the new stream tail. The \verb|tag_stream| predicate wraps each message with its source identifier, enabling merged streams to preserve source information.

\section{Exercises}
\label{sec:social-graph-exercises}

\begin{enumerate}
\item Trace the cold-call protocol when Alice initiates connection to Bob. Show the message flow and variable bindings at each step.

\item Extend the protocol to support connection rejection with a reason message.

\item Implement a \verb|friends_of_friends| predicate that discovers potential connections through existing friends.

\item The current protocol trusts the network to deliver messages. Design an extension using challenge-response to verify liveness.
\end{enumerate}
