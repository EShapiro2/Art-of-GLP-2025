% chapters/social_graph.tex - The Grassroots Social Graph

\chapter{The Grassroots Social Graph}
\label{ch:social-graph}

This chapter presents the grassroots social graph---the foundation for all grassroots platforms. We show how agents establish authenticated friendships through cold-call and friend-mediated introduction protocols.

\section{Graph Structure}
\label{sec:graph-structure}

The grassroots social graph is a distributed graph where:
\begin{itemize}
\item Nodes represent cryptographically-identified agents
\item Edges represent authenticated bidirectional channels
\item Connected components arise spontaneously and merge through befriending
\end{itemize}

Each agent runs on a personal device and maintains its portion of the graph: its identity (keypair), its friend list (authenticated connections), and the \GLP runtime.

\section{Agent Initialization}
\label{sec:agent-init}

Each agent begins with the goal \verb|agent(Id, ChUser, ChNet)| where \verb|Id| is the agent's unique identifier, \verb|ChUser| provides bidirectional communication with the user interface, and \verb|ChNet| connects to the network:

\begin{verbatim}
agent(Id, ChUser, ChNet) :-
    ChUser = ch(UserIn, UserOut), ChNet = ch(NetIn, NetOut) |
    merge(UserIn?, NetIn?, In),
    social_graph(Id?, In?, [(user, UserOut), (net, NetOut)]).
\end{verbatim}

The initialization extracts input and output streams from user and network channels, merges inputs into a unified stream \verb|In|, and stores output streams in the initial friends list with special identifiers \verb|user| and \verb|net|.

The \verb|social_graph| predicate is the main event loop, processing messages from the merged input stream. Its arguments are: the agent's identity, the input message stream, and the friends list (an association list mapping names to output streams).

\section{Cold-Call Befriending Protocol}
\label{sec:cold-call}

The cold-call protocol enables agents to establish friendship without prior shared variables. It proceeds in four phases: user initiation, offer transmission, user consultation, and channel establishment.

\subsection{User Initiation}

When the user requests connection to a target agent:

\begin{verbatim}
social_graph(Id, [msg(user, Id, connect(Target))|In], Fs) :-
    ground(Id), ground(Target) |
    lookup_send(net, msg(Id?, Target?, intro(Id?, Id?, Resp)), Fs?, Fs1),
    response_stream(Resp?, Target?, Id?, Rs),
    merge(In?, Rs?, In1),
    social_graph(Id?, In1?, Fs1?).
\end{verbatim}

The agent sends an introduction message through the network channel containing its identity and a fresh response variable \verb|Resp|. The \verb|response_stream| predicate produces a single-element stream when the response arrives; this stream is merged into the input stream so the response can be processed by the main event loop.

\subsection{Processing Received Introductions}

When an agent receives a self-introduction:

\begin{verbatim}
social_graph(Id, [msg(From, Id, intro(From, From, Resp))|In], Fs) :-
    ground(Id), ground(From) |
    lookup_send(user, msg(agent, user, befriend(From?, Resp?)), Fs?, Fs1),
    social_graph(Id?, In?, Fs1?).
\end{verbatim}

Upon receiving the introduction, the agent consults the user about whether to accept.

\subsection{User Decision and Channel Establishment}

When the user decides:

\begin{verbatim}
social_graph(Id, [msg(user, Id, decision(Dec, From, Resp))|In], Fs) :-
    ground(Id) |
    bind_response(Dec?, From?, Resp?, Fs?, Fs1, In?, In1),
    social_graph(Id?, In1?, Fs1?).
\end{verbatim}

The \verb|bind_response| predicate handles both acceptance and rejection:

\begin{verbatim}
bind_response(yes, From, Out?, Fs, Fs1?, In, In1?) :-
    atom(From?),
    new_channel(ch(FIn, FOut), FCh) |
    wrap_accept(FCh?, Out),
    handle_accept(From?, ch(FIn?, FOut?), Fs?, Fs1, In?, In1).
bind_response(no, _, no, Fs, Fs?, In, In?).

wrap_accept(Ch, accept(Ch?)).
\end{verbatim}

On acceptance, \verb|new_channel| creates a pair of connected channels. The \verb|wrap_accept| helper binds the output to \verb|accept(Ch?)| using a separate writer, ensuring SRSW compliance. The acceptor keeps one half of the channel pair and sends the other to the initiator via the response variable.

\subsection{Establishing the Connection}

The \verb|handle_accept| predicate completes channel establishment for the accepting agent:

\begin{verbatim}
handle_accept(From, ch(FIn, FOut), Fs, Fs1?, In, In1?) :-
    atom(From?) |
    tag_stream(From?, FIn?, Tagged),
    merge(In?, Tagged?, In1),
    add_friend(From?, FOut?, Fs?, Fs1).
\end{verbatim}

The \verb|handle_response| predicate handles responses for the initiating agent:

\begin{verbatim}
handle_response(accept(ch(FIn, FOut)), From, Fs, Fs1?, In, In1?) :-
    atom(From?) |
    tag_stream(From?, FIn?, Tagged),
    merge(In?, Tagged?, In1),
    add_friend(From?, FOut?, Fs?, Fs1).
handle_response(no, _, Fs, Fs?, In, In?).

add_friend(Name, Out, Fs, [(Name?, Out?)|Fs?]).
\end{verbatim}

On acceptance, the friend's output stream is added to the friends list via \verb|add_friend|, and the friend's input stream (tagged with the friend's identity) is merged into the main input stream.

\subsection{Processing Responses}

When the initiating agent receives a response to their introduction:

\begin{verbatim}
social_graph(Id, [msg(From, Id, response(Resp))|In], Fs) :-
    ground(Id) |
    handle_response(Resp?, From?, Fs?, Fs1, In?, In1),
    social_graph(Id?, In1?, Fs1?).
\end{verbatim}

The response message arrives via the merged input stream (from \verb|response_stream|). The \verb|handle_response| predicate establishes the connection on acceptance or does nothing on rejection.

\subsection{Response Stream}
\label{sec:response-stream}

The \verb|response_stream| predicate produces a single-element stream when a trigger variable becomes bound:

\begin{verbatim}
response_stream(Resp, Target, Id, [msg(Target?, Id?, response(Resp?))]) :-
    known(Resp?) | true.
\end{verbatim}

The \verb|known(X?)| guard succeeds when \verb|X| is bound to any value. Until the response arrives, the stream remains unbound. When the remote agent binds \verb|Resp| (via acceptance or rejection), the guard succeeds and the stream produces a single response message that gets merged into the main input stream.

\subsection{The Inject Predicate}
\label{sec:inject-pattern}

An alternative to \verb|response_stream| is the \verb|inject| predicate, which defers message insertion into an existing stream:

\begin{verbatim}
inject(X, Y, Ys, [Y?|Ys?]) :- known(X) | true.
inject(X, Y, [Y1|Ys], [Y1?|Ys1?]) :- unknown(X) | inject(X?, Y?, Ys?, Ys1).
\end{verbatim}

The \verb|known(X)| guard succeeds when \verb|X| is bound; \verb|unknown(X)| succeeds when \verb|X| is unbound. When \verb|X| is unbound, messages pass through unchanged. When \verb|X| becomes bound, the deferred message \verb|Y| is inserted. This enables non-blocking protocol operation where a response must be processed at a later time.

Note: \verb|inject| works when the message \verb|Y| is pre-constructed. For messages that must reference the trigger variable (like \verb|response(Resp?)|), use \verb|response_stream| with \verb|merge| instead.

\section{Friend-Mediated Introduction}
\label{sec:friend-intro}

When agent $r$ is friends with both $p$ and $q$, $r$ can introduce them. This leverages existing trust relationships.

\subsection{Initiating an Introduction}

The introducer creates channel pairs and sends invitations:

\begin{verbatim}
social_graph(Id, [msg(user, Id?, introduce(P, Q))|In], Fs) :-
    ground(Id?), ground(P?), ground(Q?),
    new_channel(ch(PQIn, PQOut), ch(QPIn, QPOut)) |
    lookup_send(P?, msg(Id?, P?, intro(Q?, ch(QPIn?, PQOut?))), Fs?, Fs1),
    lookup_send(Q?, msg(Id?, Q?, intro(P?, ch(PQIn?, QPOut?))), Fs1?, Fs2),
    social_graph(Id?, In?, Fs2?).
\end{verbatim}

Each party receives one half of the channel pair, enabling direct communication once both accept.

\subsection{Processing the Introduction}

Recipients verify the introduction came from a trusted friend. In GLPSAM simulation, attestation guards are omitted:

\begin{verbatim}
social_graph(Id, [msg(From, Id?, intro(Other, Ch))|In], Fs) :-
    ground(Id?), ground(From?), ground(Other?) |
    lookup_send(user, msg(agent, user,
        befriend_intro(From?, Other?, Ch?)), Fs?, Fs1),
    social_graph(Id?, In?, Fs1?).
\end{verbatim}

The user is consulted about whether to accept the introduction.

\subsection{Accepting or Rejecting the Introduction}

When the user accepts:

\begin{verbatim}
social_graph(Id, [msg(user, Id?, accept_intro(Other, ch(FIn, FOut)))|In], Fs) :-
    ground(Id?), ground(Other?) |
    tag_stream(Other?, FIn?, Tagged),
    merge(In?, Tagged?, In1),
    add_friend(Other?, FOut?, Fs?, Fs1),
    social_graph(Id?, In1?, Fs1?).
\end{verbatim}

When the user rejects:

\begin{verbatim}
social_graph(Id, [msg(user, Id?, reject_intro(_, _))|In], Fs) :-
    ground(Id?) |
    social_graph(Id?, In?, Fs?).
\end{verbatim}

Upon acceptance, the provided channel is added to the friends list and its input merged into the main stream.

\subsection{Catch-All Clause}

Messages that don't match any specific clause are handled by a catch-all:

\begin{verbatim}
social_graph(Id, [msg(_, _, _)|In], Fs) :-
    ground(Id), otherwise |
    social_graph(Id?, In?, Fs?).
\end{verbatim}

The \verb|otherwise| guard ensures this clause only matches when no other clause applies. Unrecognized messages are silently dropped, allowing the event loop to continue processing.

\section{Channel Operations}
\label{sec:channel-guards}

Channel operations encapsulate stream manipulation for bidirectional communication:

\begin{verbatim}
send(X, ch(In, [X?|Out?]), ch(In?, Out)).
receive(X?, ch([X|In], Out?), ch(In?, Out)).
new_channel(ch(Xs?, Ys), ch(Ys?, Xs)).
\end{verbatim}

The \verb|send| operation adds a message to the output stream. The \verb|receive| operation removes a message from the input stream. The \verb|new_channel| operation creates a pair of connected channels where each channel's input is the other's output.

\section{Utility Predicates}
\label{sec:social-graph-utilities}

The social graph protocol uses several utility predicates:

\begin{verbatim}
lookup(Key, [(K, Value)|_], Value?) :- Key? =?= K? | true.
lookup(Key, [_|Rest], Value?) :-
    otherwise | lookup(Key?, Rest?, Value).

lookup_send(Key, Msg, Fs, Fs1?) :-
    ground(Key?), ground(Fs?) |
    lookup(Key?, Fs?, [Msg?|Out1]),
    update(Key?, Out1?, Fs?, Fs1).

tag_stream(Name, [M|In], [msg(Name?, M?)|Out?]) :-
    atom(Name?) | tag_stream(Name?, In?, Out).
tag_stream(_, [], []).
\end{verbatim}

The \verb|lookup| predicate finds a value in an association list. The \verb|lookup_send| predicate sends a message through the channel associated with a key and updates the friends list with the new stream tail. The \verb|tag_stream| predicate wraps each message with its source identifier, enabling merged streams to preserve source information.

\section{Testing with Multiagent Plays}
\label{sec:plays}

The protocols presented above describe agent behavior in isolation. To verify that multiple agents interact correctly, we simulate multiagent systems. This section presents the \emph{play} methodology: self-contained programs that spawn multiple agents, connect them through a network switch, and drive their behavior through scripted actors.

\subsection{The Network Switch}

In deployment, agents communicate through a physical network. In simulation, a \verb|network| process routes messages between agents. Each agent maintains a single channel to the network; messages include a destination address, and the switch forwards them accordingly.

A channel \verb|ch(In?, Out)| pairs an input stream (which the holder reads) with an output stream (which the holder writes). The network holds the inverse of each agent's channel: where Alice has \verb|ch(NetIn?, NetOut)|, the network has \verb|ch(NetOut?, NetIn)|.

For a two-agent network:

\begin{verbatim}
%% Alice sends to Bob
network2((alice, ch([msg(alice, bob, X)|AliceIn], AliceOut?)),
         (bob, ch(BobIn, [msg(alice, bob, X?)|BobOut?]))) :-
    network2((alice, ch(AliceIn?, AliceOut)),
             (bob, ch(BobIn?, BobOut))).

%% Bob sends to Alice
network2((alice, ch(AliceIn, [msg(bob, alice, X?)|AliceOut?])),
         (bob, ch([msg(bob, alice, X)|BobIn], BobOut?))) :-
    network2((alice, ch(AliceIn?, AliceOut)),
             (bob, ch(BobIn?, BobOut))).
\end{verbatim}

The structure merits careful study. In the first clause:
\begin{itemize}
\item The head reads from Alice's output: \verb|[msg(alice, bob, X)|AliceIn]| extracts the message
\item The head writes to Bob's input: \verb|[msg(alice, bob, X?)|BobOut?]| delivers the message
\item The body preserves the stream tails as writers for subsequent messages
\end{itemize}

The reader/writer annotations ensure SRSW compliance: each stream variable appears exactly once as a writer in the body. This enables the switch to route multiple messages---after forwarding one message, the switch recurses with fresh stream tails ready for the next.

For $n$ agents, the switch requires $n(n-1)$ clauses---one for each ordered pair of distinct agents. A four-agent switch has twelve clauses.

\subsection{Actors and Scripts}

A \emph{play} simulates a scenario by spawning agents and driving them with \emph{actors}. An actor represents a user following a deterministic script---responding to agent prompts with predetermined choices.

The simplest actor initiates a single action:

\begin{verbatim}
alice_actor(Out?, [msg(user, alice, connect(bob))]).
\end{verbatim}

Alice's actor writes a \verb|connect(bob)| request to her agent's user input stream, then terminates.

A responding actor waits for a prompt before acting:

\begin{verbatim}
bob_actor([msg(agent, user, befriend(From, Resp))|_],
          [msg(user, bob, decision(yes, From?, Resp?))|_]).
\end{verbatim}

Bob's actor reads a \verb|befriend| request from his agent, then writes an acceptance decision.

\subsection{The Play Structure}

A complete play wires together the network, agents, and actors:

\begin{verbatim}
play_alice_bob :-
    %% Network switch
    network2((alice, ch(AliceNetOut?, AliceNetIn)),
             (bob, ch(BobNetOut?, BobNetIn))),

    %% Agents
    agent(alice, ch(AliceUserIn?, AliceUserOut),
                 ch(AliceNetIn?, AliceNetOut)),
    agent(bob, ch(BobUserIn?, BobUserOut),
               ch(BobNetIn?, BobNetOut)),

    %% Actors
    alice_actor(AliceUserOut?, AliceUserIn),
    bob_actor(BobUserOut?, BobUserIn).
\end{verbatim}

The channel wiring requires attention. Each agent has two channels:
\begin{itemize}
\item User channel: \verb|ch(UserIn?, UserOut)| connects to the actor
\item Network channel: \verb|ch(NetIn?, NetOut)| connects to the switch
\end{itemize}

The network holds inverse channels: \verb|ch(NetOut?, NetIn)|. This ensures that when Alice writes to her \verb|NetOut|, the network reads it; when the network writes to \verb|NetIn|, Alice reads it.

\subsection{Execution Trace}

Running \verb|play_alice_bob| produces a complete protocol execution:

\begin{enumerate}
\item Alice's actor sends \verb|connect(bob)| to her agent
\item Alice's agent sends \verb|intro(alice, alice, Resp)| through the network
\item The network routes the message to Bob
\item Bob's agent sends \verb|befriend(alice, Resp)| to his actor
\item Bob's actor sends \verb|decision(yes, alice, Resp)| to his agent
\item Bob's agent binds \verb|Resp| to \verb|accept(ch(FOut?, FIn))|
\item The \verb|inject_msg| predicate delivers the response to Alice
\item Both agents add each other to their friends lists
\end{enumerate}

The final state shows successful befriending: Alice's friends list contains Bob, and Bob's contains Alice. The protocol terminates with agents suspended on empty friend channels, ready for application-level messaging.

\subsection{Scaling to More Agents}

The methodology scales to larger plays. A four-agent scenario tests cross-network befriending:

\begin{verbatim}
play_4agents :-
    network4((alice, ch(AliceNetOut?, AliceNetIn)),
             (bob, ch(BobNetOut?, BobNetIn)),
             (carol, ch(CarolNetOut?, CarolNetIn)),
             (dave, ch(DaveNetOut?, DaveNetIn))),

    agent(alice, ch(AliceUserIn?, AliceUserOut),
                 ch(AliceNetIn?, AliceNetOut)),
    agent(bob, ch(BobUserIn?, BobUserOut),
               ch(BobNetIn?, BobNetOut)),
    agent(carol, ch(CarolUserIn?, CarolUserOut),
                 ch(CarolNetIn?, CarolNetOut)),
    agent(dave, ch(DaveUserIn?, DaveUserOut),
                ch(DaveNetIn?, DaveNetOut)),

    alice_actor(AliceUserOut?, AliceUserIn),
    bob_actor(BobUserOut?, BobUserIn),
    carol_actor(CarolUserOut?, CarolUserIn),
    dave_actor(DaveUserOut?, DaveUserIn).
\end{verbatim}

With appropriate actor scripts, this play can test scenarios such as: Alice befriends Bob, Carol befriends Dave, then Bob befriends Carol---demonstrating independent befriending operations and graph connectivity growth.

\subsection{Testing Friend-Mediated Introduction}

The cold-call plays test network-routed befriending. To test friend-mediated introduction, we need a scenario where an agent already has multiple friends.

The \verb|play_introduction| scenario proceeds in three phases:
\begin{enumerate}
\item Alice cold-calls Bob through the network; Bob accepts
\item Alice cold-calls Carol through the network; Carol accepts
\item Alice introduces Bob to Carol through her friend channels
\end{enumerate}

After phase 2, Alice has both Bob and Carol as friends. The introduction in phase 3 sends messages through Alice's friend channels---not the network---to Bob and Carol. Each receives an \verb|intro| message containing the other's identity and one half of a fresh channel pair.

The actors must handle two protocol phases:

\begin{verbatim}
bob_actor([msg(agent, user, befriend(alice, Resp1))|Out1],
          [msg(user, bob, decision(yes, alice, Resp1?))|In1?]) :-
    bob_wait_intro(Out1?, In1).

bob_wait_intro([msg(agent, user, befriend_intro(alice, carol, Ch))|_],
               [msg(user, bob, accept_intro(carol, Ch?))|_]).
\end{verbatim}

Bob's actor first accepts Alice's cold-call, then waits for the introduction. The \verb|befriend_intro| message indicates a friend-mediated introduction (from Alice, introducing Carol). Upon acceptance, Bob and Carol establish a direct channel without network involvement.

The final state shows all three agents as mutual friends: Alice connected to both Bob and Carol through cold-calls, and Bob connected to Carol through the introduction.

\section{Exercises}
\label{sec:social-graph-exercises}

\begin{enumerate}
\item Trace the cold-call protocol when Alice initiates connection to Bob. Show the message flow and variable bindings at each step.

\item Extend the protocol to support connection rejection with a reason message.

\item Implement a \verb|friends_of_friends| predicate that discovers potential connections through existing friends.

\item The current protocol trusts the network to deliver messages. Design an extension using challenge-response to verify liveness.
\end{enumerate}
