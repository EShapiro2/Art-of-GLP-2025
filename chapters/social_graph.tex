% chapters/social_graph.tex - The Grassroots Social Graph

\chapter{The Grassroots Social Graph}
\label{ch:social-graph}

This chapter presents the grassroots social graph---the foundation for all grassroots platforms. We show how agents establish authenticated friendships through cold-call and friend-mediated introduction protocols.

\section{Graph Structure}
\label{sec:graph-structure}

The grassroots social graph is a distributed graph where:
\begin{itemize}
\item Nodes represent cryptographically-identified agents
\item Edges represent authenticated bidirectional channels
\item Connected components arise spontaneously and merge through befriending
\end{itemize}

Each agent runs on a personal device and maintains its portion of the graph: its identity (keypair), its friend list (authenticated connections), and the \GLP runtime.

\section{Agent Initialization}
\label{sec:agent-init}

Each agent begins with the goal \verb|agent(Id, ChUser, ChNet)| where \verb|Id| is the agent's unique identifier, \verb|ChUser| provides bidirectional communication with the user interface, and \verb|ChNet| connects to the network:

\begin{verbatim}
agent(Id, ChUser, ChNet) :-
    ChUser = ch(UserIn, UserOut), ChNet = ch(NetIn, NetOut) |
    merge(UserIn?, NetIn?, In),
    social_graph(Id?, In?, [(user, UserOut), (net, NetOut)]).
\end{verbatim}

The initialization extracts input and output streams from user and network channels, merges inputs into a unified stream \verb|In|, and stores output streams in the initial friends list with special identifiers \verb|user| and \verb|net|.

The \verb|social_graph| predicate is the main event loop, processing messages from the merged input stream. Its arguments are: the agent's identity, the input message stream, and the friends list (an association list mapping names to output streams).

\section{Cold-Call Befriending Protocol}
\label{sec:cold-call}

The cold-call protocol enables agents to establish friendship without prior shared variables. It proceeds in four phases: user initiation, offer transmission, user consultation, and channel establishment.

\subsection{User Initiation}

When the user requests connection to a target agent:

\begin{verbatim}
social_graph(Id, [msg(user, Id, connect(Target))|In], Fs) :-
    ground(Id), ground(Target) |
    lookup_send(net, msg(Id, Target, intro(Id?, Id?, Resp)), Fs?, Fs1),
    inject(Resp?, msg(Target, Id, response(Resp)), In?, In1),
    social_graph(Id, In1?, Fs1?).
\end{verbatim}

The agent sends an introduction message through the network channel containing its identity and a fresh response variable \verb|Resp|. The \verb|inject| predicate defers insertion of the response into the input stream until \verb|Resp| becomes bound.

\subsection{Processing Received Introductions}

When an agent receives a self-introduction:

\begin{verbatim}
social_graph(Id, [msg(From, Id, intro(From, From, Resp))|In], Fs) :-
    ground(Id) |
    lookup_send(user, msg(agent, user, befriend(From?, Resp)), Fs?, Fs1),
    social_graph(Id, In?, Fs1?).
\end{verbatim}

In deployment, an \verb|attestation| guard would verify the introduction carries a valid signature from the claimed sender. In simulation, we assume all agents are correct. Upon receiving the introduction, the agent consults the user about whether to accept.

\subsection{User Decision and Channel Establishment}

When the user decides:

\begin{verbatim}
social_graph(Id, [msg(user, Id, decision(Dec, From, Resp?))|In], Fs) :-
    ground(Id) |
    bind_response(Dec?, From?, Resp, Fs?, Fs1, In?, In1),
    social_graph(Id, In1?, Fs1?).
\end{verbatim}

The \verb|bind_response| predicate handles both acceptance and rejection:

\begin{verbatim}
bind_response(yes, From, accept(FCh), Fs, Fs1, In, In1) :-
    new_channel(ch(FIn, FOut), FCh) |
    handle_response(accept(FCh?), From?, Fs?, Fs1, In?, In1).
bind_response(no, _, no, Fs, Fs?, In, In?).
\end{verbatim}

On acceptance, \verb|new_channel| creates a pair of connected channels. The acceptor keeps one half and sends the other to the initiator via the response variable.

\subsection{Establishing the Connection}

The \verb|handle_response| predicate completes channel establishment:

\begin{verbatim}
handle_response(accept(ch(FIn, FOut)), From, Fs, [(From?, FOut?)|Fs?], In, In1) :-
    tag_stream(From?, FIn?, Tagged),
    merge(In?, Tagged?, In1).
handle_response(no, _, Fs, Fs?, In, In?).
\end{verbatim}

On acceptance, the friend's output stream is added to the friends list, and the friend's input stream (tagged with the friend's identity) is merged into the main input stream.

\subsection{The Inject Predicate}
\label{sec:inject-pattern}

The \verb|inject| predicate defers message insertion until a trigger variable becomes bound:

\begin{verbatim}
inject(X, Y, Ys, [Y?|Ys?]) :- known(X?) | true.
inject(X, Y, [Y1|Ys], [Y1?|Ys1?]) :- unknown(X?) | inject(X?, Y?, Ys?, Ys1).
\end{verbatim}

When \verb|X| is unbound, messages pass through unchanged. When \verb|X| becomes bound, the deferred message \verb|Y| is inserted. This enables non-blocking protocol operation where a response must be processed at a later time.

\section{Friend-Mediated Introduction}
\label{sec:friend-intro}

When agent $r$ is friends with both $p$ and $q$, $r$ can introduce them. This leverages existing trust relationships.

\subsection{Initiating an Introduction}

The introducer creates channel pairs and sends invitations:

\begin{verbatim}
social_graph(Id, [msg(user, Id, introduce(P, Q))|In], Fs) :-
    ground(Id), ground(P), ground(Q),
    new_channel(ch(PQIn, PQOut), ch(QPIn, QPOut)) |
    lookup_send(P?, msg(Id?, P?, intro(Q?, ch(QPIn?, PQOut?))), Fs?, Fs1),
    lookup_send(Q?, msg(Id?, Q?, intro(P?, ch(PQIn?, QPOut?))), Fs1?, Fs2),
    social_graph(Id?, In?, Fs2?).
\end{verbatim}

Each party receives one half of the channel pair, enabling direct communication once both accept.

\subsection{Processing the Introduction}

Recipients verify the introduction came from a trusted friend. In simulation, we assume correct agents:

\begin{verbatim}
social_graph(Id, [msg(From, Id, intro(Other, Ch))|In], Fs) :-
    ground(Id) |
    lookup_send(user, msg(agent, user,
        befriend_intro(From?, Other?, Ch?)), Fs?, Fs1),
    social_graph(Id?, In?, Fs1?).
\end{verbatim}

The user is consulted about whether to accept the introduction. Upon acceptance, the provided channel is added to the friends list.

\section{Defined Guards for Channels}
\label{sec:channel-guards}

Channel operations are defined as unit clauses, serving as defined guards when used in guard position:

\begin{verbatim}
send(X, ch(In, [X?|Out?]), ch(In?, Out)).
receive(X?, ch([X|In], Out?), ch(In?, Out)).
new_channel(ch(Xs?, Ys), ch(Ys?, Xs)).
\end{verbatim}

The \verb|send| operation adds a message to the output stream. The \verb|receive| operation removes a message from the input stream. The \verb|new_channel| operation creates a pair of connected channels where each channel's input is the other's output.

These definitions follow the GLP mechanism for defined guards: when a unit clause appears in guard position, it unfolds to equality tests against its arguments.

\section{Utility Predicates}
\label{sec:social-graph-utilities}

The social graph protocol uses several utility predicates:

\begin{verbatim}
lookup(Key, [(Key?, Value?)|_], Value).
lookup(Key, [(K, _)|Rest], Value) :-
    Key? \= K? | lookup(Key?, Rest?, Value).

lookup_send(Key, Msg, Fs, Fs1) :-
    lookup(Key?, Fs?, (_, Out)),
    Out = [Msg?|Out1?],
    update(Key?, Out1, Fs?, Fs1).

tag_stream(Name, [M|In], [msg(Name?, M?)|Out?]) :-
    tag_stream(Name?, In?, Out).
tag_stream(_, [], []).
\end{verbatim}

The \verb|lookup| predicate finds a value in an association list. The \verb|lookup_send| predicate sends a message through the channel associated with a key and updates the friends list with the new stream tail. The \verb|tag_stream| predicate wraps each message with its source identifier, enabling merged streams to preserve source information.

\section{Exercises}
\label{sec:social-graph-exercises}

\begin{enumerate}
\item Trace the cold-call protocol when Alice initiates connection to Bob. Show the message flow and variable bindings at each step.

\item Extend the protocol to support connection rejection with a reason message.

\item Implement a \verb|friends_of_friends| predicate that discovers potential connections through existing friends.

\item The current protocol trusts the network to deliver messages. Design an extension using challenge-response to verify liveness.
\end{enumerate}
