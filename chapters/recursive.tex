% chapters/recursive.tex - Recursive Programming

\chapter{Recursive Programming}
\label{ch:recursive}

This chapter presents recursive programming in \GLP. We distinguish \emph{tail recursion}, which is iteration by a single process, from \emph{true recursion}, which spawns concurrent processes forming a tree of computation.

%% ============================================
%% Section 1: Arithmetic and Trees
%% ============================================

\section{Arithmetic and Trees}
\label{sec:arithmetic-trees}

\subsection{Peano Arithmetic}
\label{sec:peano}

Peano arithmetic represents natural numbers using zero and successor:
\begin{itemize}
\item \verb|0| represents zero
\item \verb|s(N)| represents the successor of \verb|N| (i.e., $N + 1$)
\end{itemize}

\paragraph{Addition.} Addition in Peano arithmetic:

\begin{verbatim}
plus(0, Y, Y?).
plus(s(X), Y, s(Z?)) :- plus(X?, Y?, Z).
\end{verbatim}

The first clause: $0 + Y = Y$. The second clause: $s(X) + Y = s(X + Y)$---adding a successor on the left produces a successor in the result.

Peano arithmetic is elegant but inefficient---representing $n$ requires $O(n)$ space. For practical computation, we use built-in arithmetic.

\subsection{Integer Arithmetic}
\label{sec:integer-arithmetic}

\GLP provides efficient built-in arithmetic through the assignment operator \verb|:=| and arithmetic guards.

\paragraph{Assignment.} The operator \verb|X := Expr| evaluates the arithmetic expression \verb|Expr| and assigns the result to the writer \verb|X|:

\begin{verbatim}
double(X, Y?) :- Y := X? * 2.
average(X, Y, Avg?) :- Avg := (X? + Y?) / 2.
\end{verbatim}

\paragraph{Arithmetic Guards.} Comparison guards test numeric relationships:

\begin{verbatim}
abs(X, X?) :- X? >= 0 | true.
abs(X, Y?) :- X? < 0 | Y := 0 - X?.

max(X, Y, X?) :- X? >= Y? | true.
max(X, Y, Y?) :- X? < Y? | true.
\end{verbatim}

Arithmetic comparison guards (Appendix~\ref{appendix:guard-unification}) test numeric relationships between values. The guard \verb|X? >= 0| succeeds if the reader \verb|X?| is bound to a non-negative number, suspends if \verb|X?| is unbound, and fails if \verb|X?| is bound to a negative number. When guards are mutually exclusive (as \verb|X? >= 0| and \verb|X? < 0| are), exactly one clause commits for any ground numeric input.

\subsection{Recursive Numeric Functions}
\label{sec:recursive-numeric}

\paragraph{Factorial.} Factorial demonstrates simple numeric recursion:

\begin{verbatim}
factorial(0, 1).
factorial(N, F?) :-
    N? > 0 |
    N1 := N? - 1,
    factorial(N1?, F1),
    F := N? * F1?.
\end{verbatim}

\paragraph{Tail-Recursive Factorial.} Using an accumulator:

\begin{verbatim}
factorial(N, F?) :- fact_acc(N?, 1, F).

fact_acc(0, Acc, Acc?).
fact_acc(N, Acc, F?) :-
    N? > 0 |
    Acc1 := Acc? * N?,
    N1 := N? - 1,
    fact_acc(N1?, Acc1?, F).
\end{verbatim}

\paragraph{Fibonacci.} The Fibonacci sequence demonstrates exponential concurrent spawning:

\begin{verbatim}
fib(0, 0).
fib(1, 1).
fib(N, F?) :-
    N? > 1 |
    N1 := N? - 1,
    N2 := N? - 2,
    fib(N1?, F1),
    fib(N2?, F2),
    F := F1? + F2?.
\end{verbatim}

This implementation spawns two recursive processes for each call. Computing \verb|fib(N?, F)| creates $O(2^N)$ processes---the process tree mirrors the call tree of the naive recursive algorithm.

\paragraph{Linear Fibonacci.} An efficient tail-recursive version:

\begin{verbatim}
fib_linear(N, F?) :- fib_acc(N?, 0, 1, F).

fib_acc(0, A, _, A?).
fib_acc(N, A, B, F?) :-
    N? > 0 |
    N1 := N? - 1,
    AB := A? + B?,
    fib_acc(N1?, B?, AB?, F).
\end{verbatim}

\subsection{Flattening Nested Lists}
\label{sec:flatten}

Flattening converts a nested list structure into a single-level list:

\begin{verbatim}
flatten(Xs, Ys?) :- flatten_dl(Xs?, Ys, []).

flatten_dl([], Front?, Front).
flatten_dl([X|Xs], Front?, Back) :-
    ground(X?), is_list(X?) |
    flatten_dl(X?, Front, Mid?),
    flatten_dl(Xs?, Mid, Back?).
flatten_dl([X|Xs], [X?|Front?], Back) :-
    otherwise |
    flatten_dl(Xs?, Front, Back?).
\end{verbatim}

The \verb|is_list(X?)| guard (Appendix~\ref{appendix:guard-unification}) succeeds if \verb|X?| is bound to a proper list (either \verb|[]| or a cons cell whose tail is a proper list), suspends if \verb|X?| is unbound, and fails otherwise. Combined with \verb|ground(X?)|, this ensures we only recursively flatten complete list structures.

\subsection{Binary Trees}
\label{sec:recursive-structures}

Binary trees are represented as:
\begin{itemize}
\item \verb|empty| --- the empty tree
\item \verb|node(Value, Left, Right)| --- a node with value and two subtrees
\end{itemize}

\paragraph{Tree Sum.} Summing all values in a numeric tree:

\begin{verbatim}
tree_sum(empty, 0).
tree_sum(node(V, L, R), S?) :-
    tree_sum(L?, SL),
    tree_sum(R?, SR),
    S := V? + SL? + SR?.
\end{verbatim}

The two recursive calls spawn concurrently. For a balanced tree of $n$ nodes, this creates $O(n)$ processes with $O(\log n)$ sequential depth.

\paragraph{List to Balanced Tree.} Converting a sorted list to a balanced BST:

\begin{verbatim}
list_to_bst([], empty).
list_to_bst(Xs, node(Mid?, L?, R?)) :-
    Xs =\= [] |
    length(Xs?, Len),
    Half := Len? // 2,
    split_at(Xs?, Half?, Left, Mid, Right),
    list_to_bst(Left?, L),
    list_to_bst(Right?, R).
\end{verbatim}

The guard \verb|Xs =\= []| (Appendix~\ref{appendix:guard-unification}) is an inequality test that succeeds when \verb|Xs| is bound to a non-empty list, suspends when \verb|Xs| is unbound, and fails when \verb|Xs| is the empty list.

%% ============================================
%% Section 2: Recursive List Processing
%% ============================================

\section{Recursive List Processing}
\label{sec:recursive-lists}

This section presents sorting algorithms, demonstrating how concurrent processes naturally arise from recursive structure.

\subsection{Insertion Sort}

Insertion sort builds a sorted list by inserting each element into its correct position:

\begin{verbatim}
insertion_sort([], []).
insertion_sort([X|Xs], Sorted?) :-
    insertion_sort(Xs?, SortedTail),
    insert(X?, SortedTail?, Sorted).

insert(X, [], [X?]).
insert(X, [Y|Ys], [X?|[Y?|Ys?]]) :- X? < Y? | true.
insert(X, [Y|Ys], [Y?|Zs?]) :- X? >= Y? | insert(X?, Ys?, Zs).
\end{verbatim}

The guards \verb|X? < Y?| and \verb|X? >= Y?| ensure deterministic clause selection.

\subsection{Merge Sort}
\label{sec:mergesort}

Merge sort achieves $O(n \log n)$ complexity by dividing the list in half, sorting each half recursively, and merging the results:

\begin{verbatim}
mergesort([], []).
mergesort([X], [X?]).
mergesort(Xs, Sorted?) :-
    split(Xs?, Left, Right),
    mergesort(Left?, SortedL),
    mergesort(Right?, SortedR),
    merge_sorted(SortedL?, SortedR?, Sorted).

split([], [], []).
split([X], [X?], []).
split([X,Y|Xs], [X?|Left?], [Y?|Right?]) :- split(Xs?, Left, Right).

merge_sorted([], Ys, Ys?).
merge_sorted(Xs, [], Xs?).
merge_sorted([X|Xs], [Y|Ys], [X?|Zs?]) :-
    X? =< Y? |
    merge_sorted(Xs?, [Y?|Ys?], Zs).
merge_sorted([X|Xs], [Y|Ys], [Y?|Zs?]) :-
    Y? < X? |
    merge_sorted([X?|Xs?], Ys?, Zs).
\end{verbatim}

The two recursive \verb|mergesort| calls are independent and spawn as concurrent processes.

\subsection{Quicksort}
\label{sec:quicksort}

Quicksort partitions elements around a pivot, using difference lists to avoid the cost of appending:

\begin{verbatim}
quicksort(Unsorted, Sorted?) :- qsort(Unsorted?, Sorted, []).

qsort([X|Unsorted], Sorted?, Rest) :-
    number(X?) |
    partition(Unsorted?, X?, Smaller, Larger),
    qsort(Smaller?, Sorted, [X?|Sorted1?]),
    qsort(Larger?, Sorted1, Rest?).
qsort([], Rest?, Rest).

partition([X|Xs], A, Smaller?, [X?|Larger?]) :-
    A? < X? | partition(Xs?, A?, Smaller, Larger).
partition([X|Xs], A, [X?|Smaller?], Larger?) :-
    A? >= X? | partition(Xs?, A?, Smaller, Larger).
partition([], A, [], []) :- number(A?) | true.
\end{verbatim}

The \verb|number(X?)| guard is a type-testing guard (Appendix~\ref{appendix:guard-unification}). It succeeds if \verb|X?| is bound to a numeric value; it suspends if \verb|X?| is unbound; and it fails if \verb|X?| is bound to a non-numeric term.

\subsection{Parallel Sorting}
\label{sec:parallel-sorting}

Both merge sort and quicksort exhibit natural parallelism:

\begin{center}
\begin{tabular}{lll}
\textbf{Algorithm} & \textbf{Parallelism} & \textbf{Synchronization Point} \\
\hline
Merge sort & Two-way split & Merge waits for both halves \\
Quicksort & Two-way partition & Parent waits for both partitions \\
\end{tabular}
\end{center}

The concurrent spawning follows the recursive structure:
\begin{itemize}
\item Each recursive call creates a new process
\item Processes synchronize through reader variables
\item The parent suspends on \verb|SortedL?| and \verb|SortedR?| until children complete
\end{itemize}

%% ============================================
%% Section 3: Recursive Structure Processing
%% ============================================

\section{Recursive Structure Processing}
\label{sec:structure-processing}

This section presents predicates that recursively traverse term structures: distributing non-ground streams, observing communication on shared variables, and freezing terms for snapshots.

\subsection{Non-Ground Stream Distributor}

[TO BE WRITTEN]

\subsection{General Communication Observer}

[TO BE WRITTEN]

\subsection{Term Freezer}

[TO BE WRITTEN]

%% ============================================
%% Exercises
%% ============================================

\section{Exercises}
\label{sec:recursive-exercises}

\subsection{Arithmetic}

\begin{enumerate}
\item \textbf{GCD.} Implement the greatest common divisor using Euclid's algorithm:
\begin{verbatim}
gcd(X, 0, X?).
gcd(X, Y, G?) :- Y? > 0 | R := X? mod Y?, gcd(Y?, R?, G).
\end{verbatim}
Trace the execution for \verb|gcd(48, 18, G)|.

\item \textbf{Power.} Implement \verb|power(Base, Exp, Result)| computing $\mathit{Base}^{\mathit{Exp}}$ for non-negative integer exponents. First write a naive version, then optimize using repeated squaring.

\item \textbf{Prime Testing.} Implement \verb|is_prime(N)| that succeeds if \verb|N| is prime.

\item \textbf{Sum of List.} Implement \verb|sum(Xs, S)| that computes the sum of a numeric stream using an accumulator.

\item \textbf{Memoized Fibonacci.} Design a Fibonacci implementation that avoids redundant computation by memoizing results.
\end{enumerate}

\subsection{Sorting}

\begin{enumerate}
\item \textbf{Bubble Sort.} Implement bubble sort in \GLP. How does its parallelism compare to insertion sort?

\item \textbf{Three-Way Partition.} Modify quicksort to use three-way partitioning (less than, equal to, greater than pivot).

\item \textbf{Hybrid Sort.} Implement a hybrid sorting algorithm that uses insertion sort for small sublists and merge sort for larger lists.

\item \textbf{Stable Merge Sort.} Verify that the merge sort implementation is stable.

\item \textbf{Natural Merge Sort.} Implement natural merge sort, which identifies already-sorted runs in the input.
\end{enumerate}
