% chapters/ch07_channels_state.tex - Channels and State

\chapter{Channels and State}
\label{ch:channels-state}

This chapter shows how reader/writer pairs naturally give rise to bidirectional channels and stateful servers.

\section{Bidirectional Channels}

A single reader/writer pair provides one-way communication. Two pairs provide bidirectional communication:

\begin{verbatim}
channel(In?, Out) :- ...
\end{verbatim}

\section{Request-Response Patterns}

[To be developed: client-server communication]

\section{Stateful Servers (Monitors)}

A \emph{monitor} is a process that maintains local state and serves requests to inspect or modify that state. The term comes from Hoare's original concept~\cite{hoare1974monitors}. In \GLP, monitors receive requests via a merged input stream and respond using incomplete messages.

\subsection{A Simple Accumulator}

The simplest monitor maintains a numeric accumulator:

\begin{verbatim}
monitor(Reqs) :- monitor(Reqs?, 0).

monitor([add(N)|Reqs], Sum) :-
    Sum1 := Sum? + N?, monitor(Reqs?, Sum1?).
monitor([subtract(N)|Reqs], Sum) :-
    Sum1 := Sum? - N?, monitor(Reqs?, Sum1?).
monitor([value(V)|Reqs], Sum) :-
    ground(Sum?) | V = Sum?, monitor(Reqs?, Sum?).
monitor([], _).
\end{verbatim}

The monitor handles three request types:
\begin{itemize}
\item \verb|add(N)| --- add \verb|N| to the accumulator
\item \verb|subtract(N)| --- subtract \verb|N| from the accumulator
\item \verb|value(V)| --- bind \verb|V| to the current sum (incomplete message)
\end{itemize}

The \verb|ground(Sum?)| guard in the \verb|value| clause permits replication of \verb|Sum?| to both the response variable and the recursive call.

\subsection{Incomplete Messages}

The \verb|value(V)| request demonstrates \emph{incomplete messages}---messages containing unbound variables that the receiver fills in. The client sends \verb|value(V?)| retaining reader \verb|V?|, and the monitor binds writer \verb|V| to the current sum. This provides bidirectional communication without explicit reply channels.

\subsection{Multiple Clients}

Multiple clients connect to a monitor through a merge network:

\begin{verbatim}
test_monitor(V1?, V2?) :-
    client1(V1, Xs),
    client2(V2, Ys),
    merge(Xs?, Ys?, Zs),
    monitor(Zs?).
\end{verbatim}

Each client produces a stream of requests. The merge combines them into a single stream consumed by the monitor. Client responses arrive via their respective incomplete message variables.

\subsection{Timing and Interleaving}

Consider two clients with different timing:

\begin{verbatim}
% Client 1: immediate requests
client1(V, [add(5), add(3), value(V?)|Xs?]) :- client1_done(Xs).
client1_done([]).

% Client 2: delayed requests (waits 100ms)
client2(V, Ys?) :-
    wait(100) |
    Ys = [add(10), subtract(2), value(V?)|Ys1?],
    client2_done(Ys1).
client2_done([]).
\end{verbatim}

The \verb|wait(100)| guard suspends client2 for 100 milliseconds, allowing client1 to complete first:

\begin{verbatim}
GLP> test_monitor(V1, V2).
client1(X1, X2) :- client1_done(X6)
client2(X3, X4) → suspended
monitor_loop([add(5)|...], 0) :- ...
monitor_loop([add(3)|...], 5) :- ...
monitor_loop([value(X1?)|...], 8) :- =/2(X1, 8), ...
client2(X3, X4) :- ...        % resumes after 100ms
monitor_loop([add(10)|...], 8) :- ...
monitor_loop([subtract(2)|...], 18) :- ...
monitor_loop([value(X3?)|...], 16) :- =/2(X3, 16), ...
V1 = 8
V2 = 16
→ succeeds
\end{verbatim}

Client1 queries at sum=8 (after 5+3). Client2 queries at sum=16 (after 5+3+10-2). The timing determines what state each client observes.

\subsection{Dynamic Client Addition}

A fixed merge tree limits the number of clients. For dynamically-changing client sets, existing clients can onboard new clients using the dynamic merge pattern from Chapter~\ref{ch:streams}:

\begin{verbatim}
merge([merge(Ws)|Xs], Ys, Zs?) :-
    merger(Ws?, Xs?, Xs1), merge(Xs1?, Ys?, Zs).
\end{verbatim}

A client sends \verb|merge(NewClientStream)| to splice in a new participant.

\section{State Machines}

[To be developed: encoding state machines in GLP]

\section{Exercises}

\begin{enumerate}
\item[$\star$] Implement a simple counter server.
\item[$\star\star$] Implement a key-value store server.
\item[$\star\star\star$] Implement a replicated state machine.
\end{enumerate}
