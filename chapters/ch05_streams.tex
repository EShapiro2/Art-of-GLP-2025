\chapter{Streams}
\label{ch:streams}

\section{Introduction}

A \emph{stream} is an incrementally-constructed, potentially-indefinite list. Unlike a complete list that exists all at once, a stream is built element by element during computation. The producer may continue indefinitely, or may eventually close the stream by binding its tail to the empty list \verb|[]|.

This distinction has important consequences for consumer design:
\begin{itemize}
\item If a stream is \emph{bounded} (will eventually close), the consumer should have a clause for \verb|[]| to handle termination.
\item If a stream is \emph{indefinite} (never intended to close), the consumer should \emph{not} have a clause for \verb|[]|. Instead, it should fail if the stream unexpectedly terminates, signaling an error condition.
\end{itemize}

This design principle ensures that protocol violations are detected rather than silently ignored.

\section{Producers and Consumers}

The simplest stream pattern pairs a producer that generates elements with a consumer that processes them. Consider a producer that counts down from $N$:

\begin{verbatim}
producer([], 0).
producer([N?|Xs?], N) :- N? > 0 | N1 := N? - 1, producer(Xs, N1?).
\end{verbatim}

The producer has two clauses:
\begin{itemize}
\item When $N = 0$, close the stream with \verb|[]|
\item Otherwise, emit $N$ as the head, decrement, and continue with the tail
\end{itemize}

Note the output parameter pattern: the stream head \verb|[N?|Xs?]| uses readers in the structure, paired with writers \verb|N| and \verb|Xs| that produce values.

A consumer that sums stream elements:

\begin{verbatim}
consumer([], Sum, Sum?).
consumer([X|Xs], Sum, Result?) :- ground(X?) |
    Sum1 := Sum? + X?,
    consumer(Xs?, Sum1?, Result).
\end{verbatim}

The \verb|ground(X?)| guard ensures we only consume elements that are fully available.

\subsection{Concurrent Execution}

When producer and consumer run concurrently, they interleave:

\begin{verbatim}
GLP> producer(H, 5), consumer(H?, 0, R).
producer(X1, 5) :- :=/2(X3, -(5, 1)), producer(X4, X3?)
consumer([5 | X4?], 0, X2) :- :=/2(X5, +(0, 5)), consumer(X4?, X5?, X6)
:=/2(X3, -(5, 1)) :- true
producer(X4, 4) :- :=/2(X7, -(4, 1)), producer(X8, X7?)
:=/2(X5, +(0, 5)) :- true
consumer([4 | X8?], 5, X6) :- :=/2(X9, +(5, 4)), consumer(X8?, X9?, X10)
...
producer(X20, 0) :- true
consumer([], 15, X22) :- true
R = 15
→ succeeds
\end{verbatim}

The trace shows interleaving: the producer emits an element, the consumer processes it, the producer emits another, and so on. Neither runs to completion before the other starts---they cooperate through the shared stream.

\section{Stream Merging}

Multiple input streams can be merged into a single output stream:

\begin{verbatim}
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Ys?, Xs?, Zs).
merge(Xs, [Y|Ys], [Y?|Zs?]) :- merge(Xs?, Ys?, Zs).
merge([], [], []).
\end{verbatim}

The first two clauses swap the input streams after each element, ensuring fair interleaving. The third clause terminates when both inputs are exhausted.

\subsection{Tracing a Merge Computation}

Initial goal: \verb|merge([1,2], [a,b], Out)|

\begin{enumerate}
\item \textbf{Reduce} with clause 1: extract \verb|1|, swap inputs
\begin{itemize}
\item New goal: \verb|merge([a,b], [2], Z1)|
\item Output so far: \verb|Out = [1|Z1?]|
\end{itemize}

\item \textbf{Reduce} with clause 1: extract \verb|a|, swap inputs
\begin{itemize}
\item New goal: \verb|merge([2], [b], Z2)|
\item Output so far: \verb|Out = [1,a|Z2?]|
\end{itemize}

\item Continue alternating...

\item Final result: \verb|Out = [1, a, 2, b]|
\end{enumerate}

The output stream is constructed incrementally. Each reduction extends the output by one element while the tail remains a future.

\section{Cooperative Stream Production}

Multiple producers can cooperate on a single stream by passing the tail writer between them. Each producer extends the stream and hands control to the next:

\begin{verbatim}
% Bob produces two a's then hands tail to Alice
bob([a,a|Tail?], Result?) :- alice(Tail, Result).

% Alice produces three b's then hands tail to Bob
alice([b,b,b|Tail?], Result?) :- bob_finish(Tail, Result).

% Bob produces two more a's then closes
bob_finish([a,a], done).
\end{verbatim}

\begin{verbatim}
GLP> bob(Stream, Done).
bob(X1, X2) :- alice(X3, X4)
alice(X3, X4) :- bob_finish(X5, X6)
bob_finish(X5, X6) :- true
Stream = [a, a, b, b, b, a, a]
Done = done
→ succeeds
\end{verbatim}

The stream is produced cooperatively: Bob writes \verb|[a,a|...]|, Alice continues with \verb|[b,b,b|...]|, Bob finishes with \verb|[a,a]|.

A reader walks the stream until hitting the end:

\begin{verbatim}
reader([], Count, Count?).
reader([X|Xs], Count, Result?) :- ground(X?) |
    Count1 := Count? + 1,
    reader(Xs?, Count1?, Result).
\end{verbatim}

\begin{verbatim}
GLP> bob(Stream, _), reader(Stream?, 0, Count).
...
reader([], 7, X22) :- true
Count = 7
→ succeeds
\end{verbatim}

The reader counts 7 elements: two a's, three b's, two more a's.

\section{Difference Lists}

A \emph{difference list} represents the difference between two potentially-indefinite streams. While streams may be unbounded, their difference is always finite---hence it represents a list.

\subsection{Representation}

A difference list has two components:
\begin{itemize}
\item The \emph{head}: a list structure with an unbound variable at its end (a ``hole'')
\item The \emph{tail}: the writer variable that can fill the hole
\end{itemize}

For example, the list \verb|[1,2]| as a difference list:
\begin{verbatim}
Head: [1,2|T?]    (structure with hole T?)
Tail: T           (writer that can fill the hole)
\end{verbatim}

An empty difference list:
\begin{verbatim}
Head: T?
Tail: T
\end{verbatim}

The ``list'' is whatever lies between the current head and the eventual tail binding.

\subsection{Creating Difference Lists}

To create a difference list with $N$ empty slots:

\begin{verbatim}
create_dl(0, H?, H).
create_dl(N, [_|H?], T) :- N? > 0 | N1 := N? - 1, create_dl(N1?, H, T?).
\end{verbatim}

\begin{verbatim}
GLP> create_dl(3, H, T?).
create_dl(3, H, T) :- :=/2(X1, -(3, 1)), create_dl(X1?, X2, T?)
:=/2(X1, -(3, 1)) :- true
create_dl(2, X2, T?) :- :=/2(X3, -(2, 1)), create_dl(X3?, X4, T?)
:=/2(X3, -(2, 1)) :- true
create_dl(1, X4, T?) :- :=/2(X5, -(1, 1)), create_dl(X5?, X6, T?)
:=/2(X5, -(1, 1)) :- true
create_dl(0, X6, T?) :- true
H = [_, _, _ | T?]
T = <unbound>
→ succeeds
\end{verbatim}

The result is a structure with three empty slots, followed by the open tail.

\subsection{Converting Lists}

To convert a standard list to a difference list:

\begin{verbatim}
list_to_dl([], T?, T).
list_to_dl([X|Xs], [X?|Ys?], T) :- list_to_dl(Xs?, Ys, T?).
\end{verbatim}

\begin{verbatim}
GLP> list_to_dl([1, 2, 3], H, T?).
list_to_dl([1, 2, 3], H, T?) :- list_to_dl([2, 3], X1, T?)
list_to_dl([2, 3], X1, T?) :- list_to_dl([3], X2, T?)
list_to_dl([3], X2, T?) :- list_to_dl([], X3, T?)
list_to_dl([], X3, T?) :- true
H = [1, 2, 3 | T?]
T = <unbound>
→ succeeds
\end{verbatim}

To close a difference list into a standard list, bind the tail to empty:

\begin{verbatim}
close_dl(H, T, H?) :- T? = [].
\end{verbatim}

\begin{verbatim}
GLP> close_dl(H, [], [a, b, c]).
H = [a, b, c]
→ succeeds
\end{verbatim}

\subsection{Constant-Time Append}

The power of difference lists: O(1) concatenation. To append two difference lists, unify the first tail with the second head:

\begin{verbatim}
append_dl(H1, T1?, T1, T2?, H1?, T2).
\end{verbatim}

The arguments are:
\begin{enumerate}
\item \verb|H1|: first difference list head (input)
\item \verb|T1?|: first tail as reader (pairs with arg 3)
\item \verb|T1|: second head (input, bound to close first tail)
\item \verb|T2?|: second tail as reader (input)
\item \verb|H1?|: result head (output)
\item \verb|T2|: result tail (output)
\end{enumerate}

The key is arguments 2 and 3: \verb|T1?| and \verb|T1| form a reader/writer pair within the clause. The goal passes the first tail writer at position 2 and the second head at position 3. The clause binds them together through the pair.

\subsection{Detailed Unification Trace}

Let us append \verb|[1,2]| and \verb|[3,4]|:

\begin{verbatim}
Goal:   append_dl([1,2|T1?], T1, [3,4|T2?], T2, H, T?)
Clause: append_dl(Ha, Ta?, Ta, Tb?, Ha?, Tb).
\end{verbatim}

\begin{center}
\begin{tabular}{clll}
\textbf{Arg} & \textbf{Goal} & \textbf{Head} & \textbf{Binding} \\
\hline
1 & \verb|[1,2|T1?]| & \verb|Ha| & \verb|Ha := [1,2|T1?]| \\
2 & \verb|T1| & \verb|Ta?| & \verb|T1 := Ta?| \\
3 & \verb|[3,4|T2?]| & \verb|Ta| & \verb|Ta := [3,4|T2?]| \\
4 & \verb|T2| & \verb|Tb?| & \verb|T2 := Tb?| \\
5 & \verb|H| & \verb|Ha?| & \verb|H := Ha?| \\
6 & \verb|T?| & \verb|Tb| & \verb|Tb := T?| \\
\end{tabular}
\end{center}

The critical binding is at argument 3: \verb|Ta := [3,4|T2?]|. Its reader counterpart delivers:
\[
\mathtt{Ta?} := \mathtt{[3,4|T2?]}
\]

Since argument 2 bound \verb|T1 := Ta?|, the reader counterpart flows through:
\[
\mathtt{T1?} := \mathtt{[3,4|T2?]}
\]

This fills the hole in \verb|[1,2|T1?]|, yielding \verb|[1,2,3,4|T2?]|.

The append completed in constant time---six unifications regardless of list length.

\subsection{Complete Append Example}

Here is a full example: convert two lists to difference lists, append them, and close the result:

\begin{verbatim}
GLP> list_to_dl([1,2], H1, T1), list_to_dl([3,4], H2, T2),
     append_dl(H1?, T1, H2?, T2, R, T?), close_dl(R?, T, Result).
Result = [1, 2, 3, 4]
→ succeeds
\end{verbatim}

The sequence:
\begin{enumerate}
\item \verb|list_to_dl([1,2], H1, T1)| creates difference list \verb|([1,2|T1?], T1)|
\item \verb|list_to_dl([3,4], H2, T2)| creates difference list \verb|([3,4|T2?], T2)|
\item \verb|append_dl| unifies \verb|T1| with \verb|[3,4|T2?]|, filling the first hole
\item \verb|close_dl| binds \verb|T| to \verb|[]|, closing the result
\end{enumerate}

All operations except the initial conversions are O(1).

\subsection{Why Difference Lists Work in GLP}

Difference lists rely on:
\begin{enumerate}
\item Holding an ``open'' structure with an unbound reader at the end
\item Later instantiating the paired writer to extend the structure
\end{enumerate}

In GLP, this maps to reader/writer pairs:
\begin{itemize}
\item The structure contains a \emph{reader} at the hole position
\item We hold the paired \emph{writer} to fill it later
\item SRSW ensures exactly one writer exists---no conflicts
\item When the writer is bound, the reader receives the value
\end{itemize}

\section{Bounded Buffers}

When a fast producer meets a slow consumer, unbounded buffering can exhaust memory. A \emph{bounded buffer} limits how far the producer can advance beyond the consumer.

\subsection{List-Based Bounded Buffer}

The simplest technique: the consumer's pattern determines buffer capacity. Consider:

\begin{verbatim}
bb_consumer([X1,X2|Xs?]) :- ground(X1?) | bb_consumer([X2?|Xs]).
\end{verbatim}

The pattern \verb|[X1,X2|Xs?]| requires \emph{two} elements to be visible before consuming one. This creates backpressure: if the producer is only one element ahead, the consumer suspends.

The buffer capacity is one: the producer can be at most one element ahead of the consumer.

For buffer size $N$, require $N+1$ visible elements:
\begin{verbatim}
% Buffer size 2
bb_cons2([X1,X2,X3|Xs?]) :- ground(X1?) | bb_cons2([X2?,X3?|Xs]).
\end{verbatim}

\subsection{Backpressure in Action}

The trace reveals backpressure. With buffer size 2, the consumer requires two visible elements:

\begin{verbatim}
bb_cons2([X1,X2|Xs?], Sum, Result?) :- ground(X1?) |
    Sum1 := Sum? + X1?,
    bb_cons2([X2?|Xs], Sum1?, Result).
bb_cons2([X], Sum, Result?) :- ground(X?) | Result := Sum? + X?.
bb_cons2([], Sum, Sum?).
\end{verbatim}

\begin{verbatim}
GLP> slow_producer(H, 5), bb_cons2(H?, 0, R).
slow_producer(X1, 5) :- ...
bb_cons2([5 | X4?], 0, X2) → suspended    ← waiting for 2nd element
slow_producer(X4, 4) :- ...
bb_cons2([5, 4 | X6?], 0, X2) :- ...      ← now has 2, proceeds
...
R = 15
→ succeeds
\end{verbatim}

The key moment: after the producer emits 5, the consumer sees \verb|[5 | X4?]|---only one element with an unbound tail. The pattern \verb|[X1,X2|Xs?]| requires two, so \verb|bb_cons2| suspends.

Only when the producer emits 4, giving \verb|[5, 4 | X6?]|, can the consumer proceed. This is backpressure: the consumer cannot outpace the producer by more than the buffer size.

\subsection{Difference List Bounded Buffer}

With difference lists, buffer capacity is explicit. The consumer creates the buffer and advances the tail as it consumes:

\begin{verbatim}
% Create buffer with N slots
create_dl(0, H?, H).
create_dl(N, [_|H?], T) :- N? > 0 | N1 := N? - 1, create_dl(N1?, H, T?).

% Producer fills slots
bb_producer([], 0).
bb_producer([N?|Xs?], N) :- N? > 0 | N1 := N? - 1, bb_producer(Xs, N1?).

% Consumer reads and advances tail to free slots
consumer([], Sum, Sum?).
consumer([X|Xs], Sum, Result?) :- ground(X?) |
    Sum1 := Sum? + X?,
    consumer(Xs?, Sum1?, Result).
\end{verbatim}

\begin{verbatim}
GLP> bb_producer(H, 3), consumer(H?, 0, R).
H = [3, 2, 1]
R = 6
→ succeeds
\end{verbatim}

\section{Stream Transducers}

A \emph{transducer} transforms an input stream into an output stream. Each element of input produces zero, one, or more elements of output.

\subsection{Copier}

The identity transducer:

\begin{verbatim}
copier([], []).
copier([X|Xs], [X?|Ys?]) :- copier(Xs?, Ys).
\end{verbatim}

\begin{verbatim}
GLP> copier([1, 2, 3], Out).
copier([1, 2, 3], Out) :- copier([2, 3], X1)
copier([2, 3], X1) :- copier([3], X2)
copier([3], X2) :- copier([], X3)
copier([], X3) :- true
Out = [1, 2, 3]
→ succeeds
\end{verbatim}

\subsection{Duplicator}

Each input element appears twice in output:

\begin{verbatim}
duplicator([], []).
duplicator([X|Xs], [X?,X?|Ys?]) :- ground(X?) | duplicator(Xs?, Ys).
\end{verbatim}

The \verb|ground(X?)| guard enables two occurrences of \verb|X?| without violating SRSW.

\begin{verbatim}
GLP> duplicator([1, 2], Out).
duplicator([1, 2], Out) :- duplicator([2], X1)
duplicator([2], X1) :- duplicator([], X2)
duplicator([], X2) :- true
Out = [1, 1, 2, 2]
→ succeeds
\end{verbatim}

\subsection{Separator}

Insert a marker (here, 0) after each element:

\begin{verbatim}
separator([], []).
separator([X|Xs], [X?,0|Ys?]) :- separator(Xs?, Ys).
\end{verbatim}

\begin{verbatim}
GLP> separator([a, b], Out).
separator([a, b], Out) :- separator([b], X1)
separator([b], X1) :- separator([], X2)
separator([], X2) :- true
Out = [a, 0, b, 0]
→ succeeds
\end{verbatim}

\subsection{Differentiator}

Output the difference between consecutive elements:

\begin{verbatim}
differentiator([], []).
differentiator([_], []).
differentiator([X,Y|Xs], [D?|Ds?]) :- ground(X?), ground(Y?) |
    D := Y? - X?,
    differentiator([Y?|Xs?], Ds).
\end{verbatim}

\begin{verbatim}
GLP> differentiator([1, 4, 7], Out).
differentiator([1, 4, 7], Out) :- :=/2(X1, -(4, 1)), differentiator([4 | [7]], X2)
:=/2(X1, -(4, 1)) :- true
differentiator([4 | [7]], X2) :- :=/2(X3, -(7, 4)), differentiator([7 | []], X4)
:=/2(X3, -(7, 4)) :- true
differentiator([7 | []], X4) :- true
Out = [3, 3]
→ succeeds
\end{verbatim}

The sequence 1, 4, 7 has differences 3, 3.

\subsection{Integrator}

Output the running sum:

\begin{verbatim}
integrator(Xs, Ys?) :- integrator_acc(Xs?, 0, Ys).
integrator_acc([], _, []).
integrator_acc([X|Xs], Acc, Out?) :- ground(X?) |
    Sum := Acc? + X?,
    emit_sum(Sum?, Xs?, Out).
emit_sum(V, Xs, [V?|Ys?]) :- ground(V?) | integrator_acc(Xs?, V?, Ys).
\end{verbatim}

\begin{verbatim}
GLP> integrator([1, 2, 3, 4], Out).
Out = [1, 3, 6, 10]
→ succeeds
\end{verbatim}

The running sums: 1, 1+2=3, 1+2+3=6, 1+2+3+4=10.

\subsection{Chaining Transducers}

Transducers compose naturally:

\begin{verbatim}
GLP> duplicator([1,2], Mid), separator(Mid?, Out).
duplicator([1, 2], X1) :- duplicator([2], X3)
separator([1, 1 | X3?], Out) :- separator([1 | X3?], X6)
duplicator([2], X3) :- duplicator([], X5)
separator([1 | [2, 2 | X5?]], X6) :- separator([2, 2 | X5?], X7)
duplicator([], X5) :- true
separator([2, 2 | []], X7) :- separator([2 | []], X8)
separator([2 | []], X8) :- separator([], X9)
separator([], X9) :- true
Out = [1, 0, 1, 0, 2, 0, 2, 0]
→ succeeds
\end{verbatim}

The trace shows interleaving: \verb|duplicator| produces elements that \verb|separator| immediately processes.

\section{Stream Observers}

An \emph{observer} monitors a stream without disrupting the communication between producer and consumer. This is useful for logging, debugging, or creating audit trails.

\subsection{Forwarding Observer}

The simplest observer sits between producer and consumer, forwarding elements while creating a copy:

\begin{verbatim}
observer([X|Xs], [X?|Ys?], [X?|Zs?]) :- ground(X?) | observer(Xs?, Ys, Zs).
observer([], [], []).
\end{verbatim}

Arguments:
\begin{enumerate}
\item Input stream from producer
\item Output stream to consumer (forwarded)
\item Observation stream (copy)
\end{enumerate}

The \verb|ground(X?)| guard is required because \verb|X?| appears twice---once forwarded to the consumer, once copied to the observation stream.

\begin{verbatim}
GLP> producer(Xs, 5), observer(Xs?, Ys, Copy), consumer(Ys?, 0, Sum).
Sum = 15
Copy = [5, 4, 3, 2, 1]
→ succeeds
\end{verbatim}

The observer transparently relays elements while building the observation copy.

\subsection{Observing Cooperative Streams}

A harder problem: observe a stream being \emph{cooperatively} constructed, where you don't know in advance which party is writing at any moment.

Consider bob and alice cooperatively writing a stream, handing the tail back and forth. The observer must:
\begin{enumerate}
\item Detect who is currently writing
\item Copy elements to the observation stream
\item Forward correctly regardless of direction
\end{enumerate}

\begin{verbatim}
observe([X|Xs], Ys?, [X?|Zs?]) :- ground(X?) |
    Ys = [X?|Ys1?], observe(Xs?, Ys1, Zs).
observe([X|Xs?], Ys, [X?|Zs?]) :- ground(X?) |
    Ys = [X?|Ys1], observe(Ys1?, Xs, Zs).
observe([], [], []).
\end{verbatim}

The two clauses handle opposite directions:
\begin{itemize}
\item Clause 1: First argument has writer tail \verb|Xs|, second has reader tail \verb|Ys?|. The first stream is producing.
\item Clause 2: First argument has reader tail \verb|Xs?|, second has writer tail \verb|Ys|. The second stream is producing.
\end{itemize}

\subsection{Clause Selection via Writer-to-Writer Failure}

How does clause selection work? Consider a goal where the first stream is producing:

\begin{verbatim}
Goal: observe([a|Tail], S2?, Copy)    where Tail is a writer
\end{verbatim}

Try clause 1: \verb|observe([X|Xs], Ys?, ...)|
\begin{itemize}
\item Unify goal's \verb|Tail| (writer) with head's \verb|Xs| (writer)
\item Writer-to-writer unification \emph{fails}
\item Try next clause
\end{itemize}

Try clause 2: \verb|observe([X|Xs?], Ys, ...)|
\begin{itemize}
\item Unify goal's \verb|Tail| (writer) with head's \verb|Xs?| (reader)
\item Succeeds: writer bound to reader
\end{itemize}

When the second stream is producing, the pattern reverses: clause 1 succeeds, clause 2 would fail.

This technique relies on writer-to-writer unification being \emph{immediate failure}, not suspension. If WxW suspended on an empty set, clause 2 would never be tried. The observer pattern demonstrates that WxW failure is semantically meaningful for clause selection, not merely an optimization.

\subsection{Observing Bob and Alice}

Recall cooperative production:

\begin{verbatim}
bob([a,a|Tail?], Result?) :- alice(Tail, Result).
alice([b,b,b|Tail?], Result?) :- bob_finish(Tail, Result).
bob_finish([a,a], done).
\end{verbatim}

To observe this cooperative stream:

\begin{verbatim}
GLP> observe(S1, S2, Copy), bob(S1?, Done), S2 = [].
Copy = [a, a, b, b, b, a, a]
Done = done
→ succeeds
\end{verbatim}

The observer detects each handover and continues copying from whichever side is currently producing. The final \verb|S2 = []| closes the observation when production ends.

\section{Exercises}

\begin{enumerate}
\item Write a transducer \verb|filter(Pred, In, Out)| that outputs only elements satisfying predicate \verb|Pred|.

\item Write \verb|take(N, In, Out)| that outputs the first $N$ elements of a stream.

\item Write \verb|zip(Xs, Ys, Zs)| that pairs corresponding elements: \verb|zip([1,2], [a,b], Zs)| yields \verb|Zs = [(1,a), (2,b)]|.

\item Implement a round-robin scheduler: given a list of streams, output one element from each in turn.

\item Design a difference list representation for queues with O(1) enqueue and dequeue. Test with concurrent producers and consumers.

\item Explain why the \verb|differentiator| needs two elements visible (\verb|[X,Y|Xs]|) while most transducers need only one.

\item The \verb|integrator| and \verb|differentiator| are inverses in calculus. Show that \verb|integrator| followed by \verb|differentiator| on \verb|[1,2,3,4]| yields \verb|[1,2,3,4]| (after handling boundary).
\end{enumerate}
