\chapter{Streams}
\label{ch:streams}

\section{Introduction}

A \emph{stream} is an incrementally-constructed, potentially-indefinite list. Unlike a complete list that exists all at once, a stream is built element by element during computation. The producer may continue indefinitely, or may eventually close the stream by binding its tail to the empty list \verb|[]|.

This distinction has important consequences for consumer design:
\begin{itemize}
\item If a stream is \emph{bounded} (will eventually close), the consumer should have a clause for \verb|[]| to handle termination.
\item If a stream is \emph{indefinite} (never intended to close), the consumer should \emph{not} have a clause for \verb|[]|. Instead, it should fail if the stream unexpectedly terminates, signaling an error condition.
\end{itemize}

This design principle ensures that protocol violations are detected rather than silently ignored.

\section{Producers and Consumers}

The simplest stream pattern pairs a producer that generates elements with a consumer that processes them. Consider a producer that counts down from $N$:

\begin{verbatim}
producer([], 0).
producer([N?|Xs?], N) :- N? > 0 | N1 := N? - 1, producer(Xs, N1?).
\end{verbatim}

The producer has two clauses:
\begin{itemize}
\item When $N = 0$, close the stream with \verb|[]|
\item Otherwise, emit $N$ as the head, decrement, and continue with the tail
\end{itemize}

Note the output parameter pattern: the stream head \verb|[N?|Xs?]| uses readers in the structure, paired with writers \verb|N| and \verb|Xs| that produce values.

A consumer that sums stream elements:

\begin{verbatim}
consumer([], Sum, Sum?).
consumer([X|Xs], Sum, Result?) :- ground(X?) |
    Sum1 := Sum? + X?,
    consumer(Xs?, Sum1?, Result).
\end{verbatim}

The \verb|ground(X?)| guard ensures we only consume elements that are fully available.

\subsection{Concurrent Execution}

When producer and consumer run concurrently, they interleave:

\begin{verbatim}
GLP> producer(H, 5), consumer(H?, 0, R).
producer(X1, 5) :- :=/2(X3, -(5, 1)), producer(X4, X3?)
consumer([5 | X4?], 0, X2) :- :=/2(X5, +(0, 5)), consumer(X4?, X5?, X6)
...
producer(X20, 0) :- true
consumer([], 15, X22) :- true
R = 15
→ succeeds
\end{verbatim}

The trace shows interleaving: the producer emits an element, the consumer processes it, the producer emits another, and so on. Neither runs to completion before the other starts—they cooperate through the shared stream.

\section{Stream Merging}

Multiple input streams can be merged into a single output stream:

\begin{verbatim}
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Ys?, Xs?, Zs).
merge(Xs, [Y|Ys], [Y?|Zs?]) :- merge(Xs?, Ys?, Zs).
merge([], [], []).
\end{verbatim}

The first two clauses swap the input streams after each element, ensuring fair interleaving. The third clause terminates when both inputs are exhausted.

\subsection{Tracing a Merge Computation}

Initial goal: \verb|merge([1,2], [a,b], Out)|

\begin{enumerate}
\item \textbf{Reduce} with clause 1: extract \verb|1|, swap inputs
\begin{itemize}
\item New goal: \verb|merge([a,b], [2], Z1)|
\item Output so far: \verb|Out = [1|Z1?]|
\end{itemize}

\item \textbf{Reduce} with clause 1: extract \verb|a|, swap inputs
\begin{itemize}
\item New goal: \verb|merge([2], [b], Z2)|
\item Output so far: \verb|Out = [1,a|Z2?]|
\end{itemize}

\item Continue alternating...

\item Final result: \verb|Out = [1, a, 2, b]|
\end{enumerate}

The output stream is constructed incrementally. Each reduction extends the output by one element while the tail remains a future.

\section{Cooperative Stream Production}

Multiple producers can cooperate on a single stream by passing the tail writer between them. Each producer extends the stream and hands control to the next:

\begin{verbatim}
% Bob produces two a's then hands tail to Alice
bob([a,a|Tail?], Result?) :- alice(Tail, Result).

% Alice produces three b's then hands tail to Bob
alice([b,b,b|Tail?], Result?) :- bob_finish(Tail, Result).

% Bob produces two more a's then closes
bob_finish([a,a], done).
\end{verbatim}

\begin{verbatim}
GLP> bob(Stream, Done).
bob(X1, X2) :- alice(X3, X4)
alice(X3, X4) :- bob_finish(X5, X6)
bob_finish(X5, X6) :- true
Stream = [a, a, b, b, b, a, a]
Done = done
→ succeeds
\end{verbatim}

The stream is produced cooperatively: Bob writes \verb|[a,a|...]|, Alice continues with \verb|[b,b,b|...]|, Bob finishes with \verb|[a,a]|.

A reader walks the stream until hitting the end:

\begin{verbatim}
reader([], Count, Count?).
reader([X|Xs], Count, Result?) :- ground(X?) |
    Count1 := Count? + 1,
    reader(Xs?, Count1?, Result).
\end{verbatim}

\begin{verbatim}
GLP> bob(Stream, _), reader(Stream?, 0, Count).
...
reader([], 7, X22) :- true
Count = 7
→ succeeds
\end{verbatim}

The reader counts 7 elements: two a's, three b's, two more a's.

\section{Difference Lists}

A \emph{difference list} represents the difference between two potentially-indefinite streams. While streams may be unbounded, their difference is always finite—hence it represents a list.

\subsection{Representation}

A difference list has two components:
\begin{itemize}
\item The \emph{head}: a list structure with an unbound variable at its end (a ``hole'')
\item The \emph{tail}: the writer variable that can fill the hole
\end{itemize}

For example, the list \verb|[1,2]| as a difference list:
\begin{verbatim}
Head: [1,2|T?]    (structure with hole T?)
Tail: T           (writer that can fill the hole)
\end{verbatim}

An empty difference list:
\begin{verbatim}
Head: T?
Tail: T
\end{verbatim}

The ``list'' is whatever lies between the current head and the eventual tail binding.

\subsection{Creating Difference Lists}

To create a difference list with $N$ empty slots:

\begin{verbatim}
create_dl(0, H?, H).
create_dl(N, [_|H?], T) :- N? > 0 | N1 := N? - 1, create_dl(N1?, H, T?).
\end{verbatim}

\begin{verbatim}
GLP> create_dl(3, H, T?).
create_dl(3, H, T) :- :=/2(X1, -(3, 1)), create_dl(X1?, X2, T?)
...
H = [_, _, _ | T?]
T = <unbound>
→ succeeds
\end{verbatim}

The result is a structure with three empty slots, followed by the open tail.

\subsection{Converting Lists}

To convert a standard list to a difference list:

\begin{verbatim}
list_to_dl([], T?, T).
list_to_dl([X|Xs], [X?|Ys?], T) :- list_to_dl(Xs?, Ys, T?).
\end{verbatim}

\begin{verbatim}
GLP> list_to_dl([1, 2, 3], H, T?).
list_to_dl([1, 2, 3], H, T?) :- list_to_dl([2, 3], X1, T?)
...
H = [1, 2, 3 | T?]
T = <unbound>
→ succeeds
\end{verbatim}

To close a difference list into a standard list, bind the tail to empty:

\begin{verbatim}
close_dl(H?, [], H).
\end{verbatim}

\begin{verbatim}
GLP> close_dl(H, [], [a, b, c]).
H = [a, b, c]
→ succeeds
\end{verbatim}

\subsection{Constant-Time Append}

The power of difference lists: O(1) concatenation. To append two difference lists, unify the first tail with the second head:

\begin{verbatim}
append_dl(H1, T1?, T1, T2?, H1?, T2).
\end{verbatim}

The arguments are:
\begin{enumerate}
\item \verb|H1|: first difference list head (input)
\item \verb|T1?|: first tail as reader (pairs with arg 3)
\item \verb|T1|: second head (input, bound to close first tail)
\item \verb|T2?|: second tail as reader (input)
\item \verb|H1?|: result head (output)
\item \verb|T2|: result tail (output)
\end{enumerate}

The key is arguments 2 and 3: \verb|T1?| and \verb|T1| form a reader/writer pair within the clause. The goal passes the first tail writer at position 2 and the second head at position 3. The clause binds them together through the pair.

\subsection{Detailed Unification Trace}

Let us append \verb|[1,2]| and \verb|[3,4]|:

\begin{verbatim}
Goal:   append_dl([1,2|T1?], T1, [3,4|T2?], T2, H, T?)
Clause: append_dl(Ha, Ta?, Ta, Tb?, Ha?, Tb).
\end{verbatim}

\begin{center}
\begin{tabular}{clll}
\textbf{Arg} & \textbf{Goal} & \textbf{Head} & \textbf{Binding} \\
\hline
1 & \verb|[1,2|T1?]| & \verb|Ha| & \verb|Ha := [1,2|T1?]| \\
2 & \verb|T1| & \verb|Ta?| & \verb|T1 := Ta?| \\
3 & \verb|[3,4|T2?]| & \verb|Ta| & \verb|Ta := [3,4|T2?]| \\
4 & \verb|T2| & \verb|Tb?| & \verb|T2 := Tb?| \\
5 & \verb|H| & \verb|Ha?| & \verb|H := Ha?| \\
6 & \verb|T?| & \verb|Tb| & \verb|Tb := T?| \\
\end{tabular}
\end{center}

The critical binding is at argument 3: \verb|Ta := [3,4|T2?]|. Its reader counterpart delivers:
\[
\mathtt{Ta?} := \mathtt{[3,4|T2?]}
\]

Since argument 2 bound \verb|T1 := Ta?|, the reader counterpart flows through:
\[
\mathtt{T1?} := \mathtt{[3,4|T2?]}
\]

This fills the hole in \verb|[1,2|T1?]|, yielding \verb|[1,2,3,4|T2?]|.

The append completed in constant time—six unifications regardless of list length.

\subsection{Why Difference Lists Work in GLP}

Difference lists rely on:
\begin{enumerate}
\item Holding an ``open'' structure with an unbound reader at the end
\item Later instantiating the paired writer to extend the structure
\end{enumerate}

In GLP, this maps to reader/writer pairs:
\begin{itemize}
\item The structure contains a \emph{reader} at the hole position
\item We hold the paired \emph{writer} to fill it later
\item SRSW ensures exactly one writer exists—no conflicts
\item When the writer is bound, the reader receives the value
\end{itemize}

\section{Bounded Buffers}

When a fast producer meets a slow consumer, unbounded buffering can exhaust memory. A \emph{bounded buffer} limits how far the producer can advance beyond the consumer.

\subsection{List-Based Bounded Buffer}

The simplest technique: the consumer's pattern determines buffer capacity. Consider:

\begin{verbatim}
bb_consumer([X1,X2|Xs?]) :- ground(X1?) | bb_consumer([X2?|Xs]).
\end{verbatim}

The pattern \verb|[X1,X2|Xs?]| requires \emph{two} elements to be visible before consuming one. This creates backpressure: if the producer is only one element ahead, the consumer suspends.

The buffer capacity is one: the producer can be at most one element ahead of the consumer.

For buffer size $N$, require $N+1$ visible elements:
\begin{verbatim}
% Buffer size 2
bb_cons2([X1,X2,X3|Xs?]) :- ground(X1?) | bb_cons2([X2?,X3?|Xs]).
\end{verbatim}

\subsection{Difference List Bounded Buffer}

With difference lists, buffer capacity is explicit. The consumer creates the buffer and advances the tail as it consumes:

\begin{verbatim}
% Create buffer with N slots
create_dl(0, H?, H).
create_dl(N, [_|H?], T) :- N? > 0 | N1 := N? - 1, create_dl(N1?, H, T?).

% Producer fills slots
bb_producer([], 0).
bb_producer([N?|Xs?], N) :- N? > 0 | N1 := N? - 1, bb_producer(Xs, N1?).

% Consumer reads and advances tail to free slots
consumer([], Sum, Sum?).
consumer([X|Xs], Sum, Result?) :- ground(X?) |
    Sum1 := Sum? + X?,
    consumer(Xs?, Sum1?, Result).
\end{verbatim}

\begin{verbatim}
GLP> create_dl(2, H, T?), bb_producer(H?, 5), consumer(H?, 0, R).
...
R = 15
→ succeeds
\end{verbatim}

The \verb|create_dl(2, H, T?)| creates two empty slots. The producer fills slots from the head; the consumer reads from the head. The difference between producer position and consumer position is bounded by the initial buffer size.

\section{Stream Transducers}

A \emph{transducer} transforms an input stream into an output stream. Each element of input produces zero, one, or more elements of output.

\subsection{Copier}

The identity transducer:

\begin{verbatim}
copier([], []).
copier([X|Xs], [X?|Ys?]) :- copier(Xs?, Ys).
\end{verbatim}

\begin{verbatim}
GLP> copier([1, 2, 3], Out).
Out = [1, 2, 3]
→ succeeds
\end{verbatim}

\subsection{Duplicator}

Each input element appears twice in output:

\begin{verbatim}
duplicator([], []).
duplicator([X|Xs], [X?,X?|Ys?]) :- ground(X?) | duplicator(Xs?, Ys).
\end{verbatim}

The \verb|ground(X?)| guard enables two occurrences of \verb|X?| without violating SRSW.

\begin{verbatim}
GLP> duplicator([1, 2], Out).
Out = [1, 1, 2, 2]
→ succeeds
\end{verbatim}

\subsection{Separator}

Insert a marker (here, 0) after each element:

\begin{verbatim}
separator([], []).
separator([X|Xs], [X?,0|Ys?]) :- separator(Xs?, Ys).
\end{verbatim}

\begin{verbatim}
GLP> separator([a, b], Out).
Out = [a, 0, b, 0]
→ succeeds
\end{verbatim}

\subsection{Differentiator}

Output the difference between consecutive elements:

\begin{verbatim}
differentiator([], []).
differentiator([_], []).
differentiator([X,Y|Xs], [D?|Ds?]) :- ground(X?), ground(Y?) |
    D := Y? - X?,
    differentiator([Y?|Xs?], Ds).
\end{verbatim}

\begin{verbatim}
GLP> differentiator([1, 4, 7], Out).
Out = [3, 3]
→ succeeds
\end{verbatim}

The sequence 1, 4, 7 has differences 3, 3.

\subsection{Integrator}

Output the running sum:

\begin{verbatim}
integrator(Xs, Ys?) :- integrator_acc(Xs?, 0, Ys).
integrator_acc([], _, []).
integrator_acc([X|Xs], Acc, [Sum?|Ys?]) :- ground(X?) |
    Sum := Acc? + X?,
    integrator_acc(Xs?, Sum?, Ys).
\end{verbatim}

\begin{verbatim}
GLP> integrator([1, 2, 3, 4], Out).
Out = [1, 3, 6, 10]
→ succeeds
\end{verbatim}

The running sums: 1, 1+2=3, 1+2+3=6, 1+2+3+4=10.

\subsection{Chaining Transducers}

Transducers compose naturally:

\begin{verbatim}
GLP> duplicator([1,2], Mid), separator(Mid?, Out).
duplicator([1, 2], X1) :- duplicator([2], X3)
separator([1, 1 | X3?], Out) :- separator([1 | X3?], X6)
...
Out = [1, 0, 1, 0, 2, 0, 2, 0]
→ succeeds
\end{verbatim}

The trace shows interleaving: \verb|duplicator| produces elements that \verb|separator| immediately processes.

\section{Stream Observers}

[To be developed]

\section{Exercises}

\begin{enumerate}
\item Write a transducer \verb|filter(Pred, In, Out)| that outputs only elements satisfying predicate \verb|Pred|.

\item Write \verb|take(N, In, Out)| that outputs the first $N$ elements of a stream.

\item Write \verb|zip(Xs, Ys, Zs)| that pairs corresponding elements: \verb|zip([1,2], [a,b], Zs)| yields \verb|Zs = [(1,a), (2,b)]|.

\item Implement a round-robin scheduler: given a list of streams, output one element from each in turn.

\item Design a difference list representation for queues with O(1) enqueue and dequeue. Test with concurrent producers and consumers.

\item Explain why the \verb|differentiator| needs two elements visible (\verb|[X,Y|Xs]|) while most transducers need only one.

\item The \verb|integrator| and \verb|differentiator| are inverses in calculus. Show that \verb|integrator| followed by \verb|differentiator| on \verb|[1,2,3,4]| yields \verb|[1,2,3,4]| (after handling boundary).
\end{enumerate}
