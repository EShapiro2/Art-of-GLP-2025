% chapters/ch05_streams.tex - Streams

\chapter{Streams}
\label{ch:streams}

Streams---incrementally constructed lists---are the fundamental communication mechanism in \GLP. A producer extends a stream; a consumer reads from it. Reader/writer pairs synchronize their interaction.

\section{Producer and Consumer}

\Program{Stream Producer}
\begin{verbatim}
producer([N?|Xs?], N) :- N1 := N? + 1, producer(Xs, N1?).
\end{verbatim}

The producer takes two arguments: the stream to extend and the current value. It writes the current value to the stream head, increments, and recurses. The stream argument is a writer; the producer owns it.

\Program{Stream Consumer}
\begin{verbatim}
consumer([X|Xs], Sum) :- Sum1 := Sum? + X?, consumer(Xs?, Sum1?).
\end{verbatim}

The consumer reads from the stream head, adds it to the running sum, and recurses. The stream argument is a reader; the consumer observes it.

\section{Concurrent Execution}

Running producer and consumer together:

\begin{verbatim}
GLP> producer(Xs, 0), consumer(Xs?, 0).
\end{verbatim}

The producer owns the stream writer \verb|Xs|; the consumer holds the reader \verb|Xs?|. They execute concurrently, synchronized by the stream.

With a reduction limit of 8:

\begin{verbatim}
GLP> producer(Xs, 0), consumer(Xs?, 0).  [limit 8]

producer(Xs, 0), consumer(Xs?, 0)
  -> producer writes Xs = [0|Xs1]
producer(Xs1, 1), consumer([0|Xs1]?, 0)
  -> consumer reads 0, computes 0+0=0
producer(Xs1, 1), consumer(Xs1?, 0)
  -> producer writes Xs1 = [1|Xs2]
producer(Xs2, 2), consumer([1|Xs2]?, 0)
  -> consumer reads 1, computes 0+1=1
producer(Xs2, 2), consumer(Xs2?, 1)
  -> producer writes Xs2 = [2|Xs3]
producer(Xs3, 3), consumer([2|Xs3]?, 1)
  -> consumer reads 2, computes 1+2=3
producer(Xs3, 3), consumer(Xs3?, 3)
  -> producer writes Xs3 = [3|Xs4]
producer(Xs4, 4), consumer([3|Xs4]?, 3)

Xs = [0, 1, 2, 3 | Xs4]
-> limit reached
\end{verbatim}

The trace shows interleaved execution. Neither process dominates; fairness ensures both make progress. After 8 reductions, the stream contains \verb|[0, 1, 2, 3 | ...]| and the sum is 3.

\section{Suspension and Synchronization}

What if the consumer runs faster than the producer? It suspends:

\begin{verbatim}
GLP> consumer(Xs?, 0).  [Xs unbound]

consumer(Xs?, 0)
  -> suspended on Xs?
\end{verbatim}

The consumer cannot match \verb|[X|Xs]| against an unbound variable. It waits until someone writes to \verb|Xs|.

When the producer writes:

\begin{verbatim}
GLP> Xs = [1|Xs1], consumer(Xs?, 0).

consumer([1|Xs1]?, 0)
  -> consumer reads 1, computes 0+1=1
consumer(Xs1?, 1)
  -> suspended on Xs1?
\end{verbatim}

The consumer processes one element and suspends again, waiting for more data.

\section{Stream Termination}

The programs above run forever. To terminate, the producer closes the stream:

\Program{Bounded Producer}
\begin{verbatim}
producer([], 0).
producer([N?|Xs?], N) :- N > 0 | N1 := N? - 1, producer(Xs, N1?).
\end{verbatim}

\Program{Terminating Consumer}
\begin{verbatim}
consumer([], Sum, Sum?).
consumer([X|Xs], Sum, Result?) :-
    Sum1 := Sum? + X?, consumer(Xs?, Sum1?, Result).
\end{verbatim}

\begin{verbatim}
GLP> producer(Xs, 3), consumer(Xs?, 0, R).

producer(Xs, 3), consumer(Xs?, 0, R)
  -> producer writes Xs = [3|Xs1]
producer(Xs1, 2), consumer([3|Xs1]?, 0, R)
  -> consumer reads 3
producer(Xs1, 2), consumer(Xs1?, 3, R)
  -> producer writes Xs1 = [2|Xs2]
producer(Xs2, 1), consumer([2|Xs2]?, 3, R)
  -> consumer reads 2
producer(Xs2, 1), consumer(Xs2?, 5, R)
  -> producer writes Xs2 = [1|Xs3]
producer(Xs3, 0), consumer([1|Xs3]?, 5, R)
  -> consumer reads 1
producer(Xs3, 0), consumer(Xs3?, 6, R)
  -> producer writes Xs3 = []
consumer([], 6, R)
  -> consumer terminates
R = 6
-> succeeds
\end{verbatim}

The producer counts down from 3, producing \verb|[3, 2, 1]|, then closes with \verb|[]|. The consumer sums to 6 and binds the result.
