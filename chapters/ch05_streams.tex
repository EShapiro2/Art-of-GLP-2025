% chapters/ch05_streams.tex - Streams

\chapter{Streams}
\label{ch:streams}

Streams---incrementally constructed lists---are the fundamental communication mechanism in \GLP. A producer extends a stream; a consumer reads from it. Reader/writer pairs synchronize their interaction.

\section{Producer and Consumer}

\Program{Stream Producer}
\begin{verbatim}
producer([N?|Xs?], N) :- N1 := N? + 1, producer(Xs, N1?).
\end{verbatim}

The producer takes two arguments: the stream to extend and the current value. It writes the current value to the stream head, increments, and recurses. The stream argument is a writer; the producer owns it.

\Program{Stream Consumer}
\begin{verbatim}
consumer([X|Xs], Sum) :- Sum1 := Sum? + X?, consumer(Xs?, Sum1?).
\end{verbatim}

The consumer reads from the stream head, adds it to the running sum, and recurses. The stream argument is a reader; the consumer observes it.

\section{Concurrent Execution}

Running producer and consumer together:

\begin{verbatim}
GLP> producer(Xs, 0), consumer(Xs?, 0).
\end{verbatim}

The producer owns the stream writer \verb|Xs|; the consumer holds the reader \verb|Xs?|. They execute concurrently, synchronized by the stream.

With a reduction limit of 8:

\begin{verbatim}
GLP> producer(Xs, 0), consumer(Xs?, 0).  [limit 8]

producer(Xs, 0), consumer(Xs?, 0)
  -> producer writes Xs = [0|Xs1]
producer(Xs1, 1), consumer([0|Xs1]?, 0)
  -> consumer reads 0, computes 0+0=0
producer(Xs1, 1), consumer(Xs1?, 0)
  -> producer writes Xs1 = [1|Xs2]
producer(Xs2, 2), consumer([1|Xs2]?, 0)
  -> consumer reads 1, computes 0+1=1
producer(Xs2, 2), consumer(Xs2?, 1)
  -> producer writes Xs2 = [2|Xs3]
producer(Xs3, 3), consumer([2|Xs3]?, 1)
  -> consumer reads 2, computes 1+2=3
producer(Xs3, 3), consumer(Xs3?, 3)
  -> producer writes Xs3 = [3|Xs4]
producer(Xs4, 4), consumer([3|Xs4]?, 3)

Xs = [0, 1, 2, 3 | Xs4]
-> limit reached
\end{verbatim}

The trace shows interleaved execution. Neither process dominates; fairness ensures both make progress. After 8 reductions, the stream contains \verb|[0, 1, 2, 3 | ...]| and the sum is 3.

\section{Suspension and Synchronization}

What if the consumer runs faster than the producer? It suspends:

\begin{verbatim}
GLP> consumer(Xs?, 0).  [Xs unbound]

consumer(Xs?, 0)
  -> suspended on Xs?
\end{verbatim}

The consumer cannot match \verb|[X|Xs]| against an unbound variable. It waits until someone writes to \verb|Xs|.

When the producer writes:

\begin{verbatim}
GLP> Xs = [1|Xs1], consumer(Xs?, 0).

consumer([1|Xs1]?, 0)
  -> consumer reads 1, computes 0+1=1
consumer(Xs1?, 1)
  -> suspended on Xs1?
\end{verbatim}

The consumer processes one element and suspends again, waiting for more data.

\section{Stream Termination}

The programs above run forever. To terminate, the producer closes the stream:

\Program{Bounded Producer}
\begin{verbatim}
producer([], 0).
producer([N?|Xs?], N) :- N > 0 | N1 := N? - 1, producer(Xs, N1?).
\end{verbatim}

\Program{Terminating Consumer}
\begin{verbatim}
consumer([], Sum, Sum?).
consumer([X|Xs], Sum, Result?) :-
    Sum1 := Sum? + X?, consumer(Xs?, Sum1?, Result).
\end{verbatim}

\begin{verbatim}
GLP> producer(Xs, 3), consumer(Xs?, 0, R).

producer(Xs, 3), consumer(Xs?, 0, R)
  -> producer writes Xs = [3|Xs1]
producer(Xs1, 2), consumer([3|Xs1]?, 0, R)
  -> consumer reads 3
producer(Xs1, 2), consumer(Xs1?, 3, R)
  -> producer writes Xs1 = [2|Xs2]
producer(Xs2, 1), consumer([2|Xs2]?, 3, R)
  -> consumer reads 2
producer(Xs2, 1), consumer(Xs2?, 5, R)
  -> producer writes Xs2 = [1|Xs3]
producer(Xs3, 0), consumer([1|Xs3]?, 5, R)
  -> consumer reads 1
producer(Xs3, 0), consumer(Xs3?, 6, R)
  -> producer writes Xs3 = []
consumer([], 6, R)
  -> consumer terminates
R = 6
-> succeeds
\end{verbatim}

The producer counts down from 3, producing \verb|[3, 2, 1]|, then closes with \verb|[]|. The consumer sums to 6 and binds the result.

\section{Stream Merging}

The \verb|merge| program combines two input streams into one output stream:

\begin{verbatim}
merge([X|Xs],Ys,[X?|Zs?]) :- merge(Ys?,Xs?,Zs).
merge(Xs,[Y|Ys],[Y?|Zs?]) :- merge(Xs?,Ys?,Zs).
merge([],[],[]).
\end{verbatim}

Note the argument swapping in the recursive calls: \verb|merge(Ys?,Xs?,Zs)| ensures fair interleaving when both streams are available.

\subsection{Tracing a Merge Computation}

Let us trace a computation with the merge program to see how asynchronous communication works.

Initial goal: \verb|merge([1,2], [a,b], Out)|

\begin{enumerate}
\item Configuration: goal is \verb|merge([1,2], [a,b], Out)|, no pending messages.

\item \textbf{Reduce} with clause 1:
\begin{itemize}
\item Unify head: $\{X := 1, Xs := [2], Ys := [a,b], Out := [1|Z_1?]\}$
\item New goal: \verb|merge([a,b], [2], Z_1)|
\item The output $Out$ is now $[1|Z_1?]$---the first element is determined, the tail awaits.
\end{itemize}

\item \textbf{Reduce} with clause 1 (arguments were swapped):
\begin{itemize}
\item Unify: extracts $a$ from first argument
\item New goal: \verb|merge([2], [b], Z_2)|
\item Now $Z_1 = [a|Z_2?]$, so $Out = [1,a|Z_2?]$
\end{itemize}

\item Continue alternating until both input lists are empty...

\item Final result: $Out = [1, a, 2, b]$
\end{enumerate}

The output stream is constructed incrementally. Each reduction step extends the output by one element while the tail remains a future (unbound reader). This incremental construction is the essence of stream processing in GLP.
