% chapters/ch10_arithmetic.tex - Arithmetic

\chapter{Arithmetic}
\label{ch:arithmetic}

This chapter covers arithmetic programming in \GLP, from symbolic Peano arithmetic to efficient built-in operations. We also present recursive numeric functions that demonstrate concurrent spawning patterns.

\section{Peano Arithmetic}
\label{sec:peano}

Peano arithmetic represents natural numbers using zero and successor:
\begin{itemize}
\item \verb|0| represents zero
\item \verb|s(N)| represents the successor of \verb|N| (i.e., $N + 1$)
\end{itemize}

Thus: \verb|s(0)| is 1, \verb|s(s(0))| is 2, \verb|s(s(s(0)))| is 3, and so on.

\paragraph{Addition.} Addition in Peano arithmetic:

\begin{verbatim}
plus(0, Y, Y?).
plus(s(X), Y, s(Z?)) :- plus(X?, Y?, Z).
\end{verbatim}

The first clause: $0 + Y = Y$. The second clause: $s(X) + Y = s(X + Y)$---adding a successor on the left produces a successor in the result.

\paragraph{Multiplication.} Multiplication builds on addition:

\begin{verbatim}
times(0, _, 0).
times(s(X), Y, Z?) :- times(X?, Y?, P), plus(Y?, P?, Z).
\end{verbatim}

The first clause: $0 \times Y = 0$. The second clause: $s(X) \times Y = Y + (X \times Y)$.

\paragraph{Comparison.} Less-than comparison:

\begin{verbatim}
less(0, s(_)).
less(s(X), s(Y)) :- less(X?, Y?).
\end{verbatim}

Zero is less than any successor; for successors, compare the predecessors.

Peano arithmetic is elegant but inefficient---representing $n$ requires $O(n)$ space, and operations take $O(n)$ or $O(n^2)$ time. For practical computation, we use built-in arithmetic.

\section{Integer Arithmetic}
\label{sec:integer-arithmetic}

\GLP provides efficient built-in arithmetic through the assignment operator \verb|:=| and arithmetic guards.

\paragraph{Assignment.} The operator \verb|X := Expr| evaluates the arithmetic expression \verb|Expr| and assigns the result to the writer \verb|X|:

\begin{verbatim}
double(X, Y?) :- Y := X? * 2.
average(X, Y, Avg?) :- Avg := (X? + Y?) / 2.
\end{verbatim}

The expression on the right must be ground (all values known) for evaluation to proceed. If any reader in the expression is unbound, the assignment suspends.

\paragraph{Arithmetic Guards.} Comparison guards test numeric relationships:

\begin{verbatim}
abs(X, X?) :- X? >= 0 | true.
abs(X, Y?) :- X? < 0 | Y := 0 - X?.

max(X, Y, X?) :- X? >= Y? | true.
max(X, Y, Y?) :- X? < Y? | true.
\end{verbatim}

Guards suspend until the comparison can be evaluated. The \verb|abs/2| example uses mutually exclusive guards to select the appropriate clause.

\paragraph{Available Operations.}
\begin{center}
\begin{tabular}{ll}
\textbf{Operation} & \textbf{Syntax} \\
\hline
Addition & \verb|X? + Y?| \\
Subtraction & \verb|X? - Y?| \\
Multiplication & \verb|X? * Y?| \\
Division & \verb|X? / Y?| \\
Integer division & \verb|X? // Y?| \\
Modulo & \verb|X? mod Y?| \\
Power & \verb|X? ** Y?| \\
\end{tabular}
\end{center}

\section{Recursive Numeric Functions}
\label{sec:recursive-numeric}

\subsection{Factorial}

Factorial demonstrates simple numeric recursion:

\begin{verbatim}
factorial(0, 1).
factorial(N, F?) :-
    N? > 0 |
    N1 := N? - 1,
    factorial(N1?, F1),
    F := N? * F1?.
\end{verbatim}

The guard \verb|N? > 0| ensures we take the recursive case only for positive $N$. The recursive call computes $(N-1)!$, then we multiply by $N$.

\paragraph{Tail-Recursive Factorial.} Using an accumulator:

\begin{verbatim}
factorial(N, F?) :- fact_acc(N?, 1, F).

fact_acc(0, Acc, Acc?).
fact_acc(N, Acc, F?) :-
    N? > 0 |
    Acc1 := Acc? * N?,
    N1 := N? - 1,
    fact_acc(N1?, Acc1?, F).
\end{verbatim}

The accumulator \verb|Acc| carries the running product. This version is tail-recursive and can be optimized to use constant stack space.

\subsection{Fibonacci}
\label{sec:fibonacci}

The Fibonacci sequence ($0, 1, 1, 2, 3, 5, 8, 13, \ldots$) where each number is the sum of the two preceding ones:

\begin{verbatim}
fib(0, 0).
fib(1, 1).
fib(N, F?) :-
    N? > 1 |
    N1 := N? - 1,
    N2 := N? - 2,
    fib(N1?, F1),
    fib(N2?, F2),
    F := F1? + F2?.
\end{verbatim}

\paragraph{Exponential Concurrent Spawning.} This implementation spawns two recursive processes for each call. Computing \verb|fib(N?, F)| creates $O(2^N)$ processes---the process tree mirrors the call tree of the naive recursive algorithm.

Each \verb|fib| call:
\begin{enumerate}
\item Spawns \verb|fib(N1?, F1)| as a concurrent process
\item Spawns \verb|fib(N2?, F2)| as a concurrent process
\item Suspends on \verb|F := F1? + F2?| until both complete
\end{enumerate}

While highly parallel, this is inefficient---the same subproblems are computed repeatedly. For example, \verb|fib(5, F)| computes \verb|fib(3, _)| twice and \verb|fib(2, _)| three times.

\paragraph{Linear Fibonacci.} An efficient tail-recursive version:

\begin{verbatim}
fib_linear(N, F?) :- fib_acc(N?, 0, 1, F).

fib_acc(0, A, _, A?).
fib_acc(N, A, B, F?) :-
    N? > 0 |
    N1 := N? - 1,
    AB := A? + B?,
    fib_acc(N1?, B?, AB?, F).
\end{verbatim}

This maintains two accumulators \verb|A| and \verb|B| representing consecutive Fibonacci numbers, achieving $O(N)$ time and constant additional space.

\section{Flattening Nested Lists}
\label{sec:flatten}

Flattening converts a nested list structure into a single-level list. This combines arithmetic type testing with difference list accumulation.

\begin{verbatim}
flatten(Xs, Ys?) :- flatten_dl(Xs?, Ys, []).

flatten_dl([], Front?, Front).
flatten_dl([X|Xs], Front?, Back) :-
    ground(X?), is_list(X?) |
    flatten_dl(X?, Front, Mid?),
    flatten_dl(Xs?, Mid, Back?).
flatten_dl([X|Xs], [X?|Front?], Back) :-
    otherwise |
    flatten_dl(Xs?, Front, Back?).
\end{verbatim}

\paragraph{Type-Testing Guards.} The guard \verb|ground(X?), is_list(X?)| tests whether \verb|X| is a ground list (fully instantiated). If so, we recursively flatten it. The \verb|otherwise| guard catches all other cases---non-list elements are added directly to the output.

\paragraph{Difference List Threading.} The accumulator pattern \verb|flatten_dl(Input, Front, Back)| means ``flattening \verb|Input| fills the hole between \verb|Front| and \verb|Back|.'' When we encounter a nested list, we flatten it into \verb|Front--Mid|, then flatten the rest into \verb|Mid--Back|.

\paragraph{Example.}
\begin{verbatim}
?- flatten([[1,2],[3,[4,5]],6], F).
F = [1,2,3,4,5,6]
\end{verbatim}

The nested structure \verb|[[1,2],[3,[4,5]],6]| is recursively flattened. The sublists \verb|[1,2]|, \verb|[3,[4,5]]|, and the atom \verb|6| are processed in order, with \verb|[3,[4,5]]| further flattened to extract \verb|3|, \verb|4|, and \verb|5|.

\section{Recursive Structures: Binary Trees}
\label{sec:recursive-structures}

Binary trees are a fundamental recursive data structure. In \GLP, we represent them as:
\begin{itemize}
\item \verb|empty| --- the empty tree
\item \verb|node(Value, Left, Right)| --- a node with value and two subtrees
\end{itemize}

\subsection{Tree Traversal}

\paragraph{In-Order Traversal.} Visiting left subtree, node, then right subtree:

\begin{verbatim}
in_order(empty, []).
in_order(node(V, L, R), Vs?) :-
    in_order(L?, Ls),
    in_order(R?, Rs),
    append(Ls?, [V?|Rs?], Vs).
\end{verbatim}

This produces a sorted list for binary search trees.

\paragraph{Difference List Traversal.} More efficient using difference lists:

\begin{verbatim}
in_order_dl(Tree, Vs?) :- in_order_dl(Tree?, Vs, []).

in_order_dl(empty, Vs?, Vs).
in_order_dl(node(V, L, R), Front?, Back) :-
    in_order_dl(L?, Front, [V?|Mid?]),
    in_order_dl(R?, Mid, Back?).
\end{verbatim}

The accumulator pattern threads through both subtrees, achieving $O(n)$ time without append.

\paragraph{Pre-Order and Post-Order.} Varying the visit order:

\begin{verbatim}
%% Pre-order: node, left, right
pre_order(empty, []).
pre_order(node(V, L, R), [V?|Vs?]) :-
    pre_order(L?, Ls),
    pre_order(R?, Rs),
    append(Ls?, Rs?, Vs).

%% Post-order: left, right, node
post_order(empty, []).
post_order(node(V, L, R), Vs?) :-
    post_order(L?, Ls),
    post_order(R?, Rs),
    append(Ls?, Rs?, LRs?),
    append(LRs?, [V?], Vs).
\end{verbatim}

\subsection{Tree Computations}

\paragraph{Tree Sum.} Summing all values in a numeric tree:

\begin{verbatim}
tree_sum(empty, 0).
tree_sum(node(V, L, R), S?) :-
    tree_sum(L?, SL),
    tree_sum(R?, SR),
    S := V? + SL? + SR?.
\end{verbatim}

The two recursive calls spawn concurrently. For a balanced tree of $n$ nodes, this creates $O(n)$ processes with $O(\log n)$ sequential depth.

\paragraph{Tree Height.} Computing the depth:

\begin{verbatim}
tree_height(empty, 0).
tree_height(node(_, L, R), H?) :-
    tree_height(L?, HL),
    tree_height(R?, HR),
    H := 1 + max(HL?, HR?).
\end{verbatim}

\paragraph{Tree Size.} Counting nodes:

\begin{verbatim}
tree_size(empty, 0).
tree_size(node(_, L, R), N?) :-
    tree_size(L?, NL),
    tree_size(R?, NR),
    N := 1 + NL? + NR?.
\end{verbatim}

\subsection{Building Trees}

\paragraph{List to Balanced Tree.} Converting a sorted list to a balanced binary search tree:

\begin{verbatim}
list_to_bst([], empty).
list_to_bst(Xs, node(Mid?, L?, R?)) :-
    Xs =\= [] |
    length(Xs?, Len),
    Half := Len? // 2,
    split_at(Xs?, Half?, Left, Mid, Right),
    list_to_bst(Left?, L),
    list_to_bst(Right?, R).

split_at([X|Xs], 0, [], X?, Xs?).
split_at([X|Xs], N, [X?|Left?], Mid?, Right) :-
    N? > 0 |
    N1 := N? - 1,
    split_at(Xs?, N1?, Left, Mid, Right).
\end{verbatim}

The split extracts the middle element as the root, then recursively builds subtrees from the left and right halves.

\paragraph{Concurrent Tree Construction.} The two \verb|list_to_bst| calls in the recursive case spawn concurrently, building left and right subtrees in parallel.

\subsection{Tree Search and Modification}

\paragraph{Binary Search.} Finding a value in a BST:

\begin{verbatim}
bst_member(V, node(V, _, _)).
bst_member(V, node(N, L, _)) :- V? < N? | bst_member(V?, L?).
bst_member(V, node(N, _, R)) :- V? > N? | bst_member(V?, R?).
\end{verbatim}

The guards direct the search left or right based on comparison.

\paragraph{BST Insert.} Adding a value:

\begin{verbatim}
bst_insert(V, empty, node(V?, empty, empty)).
bst_insert(V, node(N, L, R), node(N?, L1?, R?)) :-
    V? < N? |
    bst_insert(V?, L?, L1).
bst_insert(V, node(N, L, R), node(N?, L?, R1?)) :-
    V? > N? |
    bst_insert(V?, R?, R1).
bst_insert(V, node(V, L, R), node(V?, L?, R?)).
\end{verbatim}

Duplicate values are handled by the last clause, which preserves the existing node.

\section{Exercises}
\label{sec:arithmetic-exercises}

\begin{enumerate}
\item \textbf{GCD.} Implement the greatest common divisor using Euclid's algorithm:
\begin{verbatim}
gcd(X, 0, X?).
gcd(X, Y, G?) :- Y? > 0 | R := X? mod Y?, gcd(Y?, R?, G).
\end{verbatim}
Trace the execution for \verb|gcd(48, 18, G)|.

\item \textbf{Power.} Implement \verb|power(Base, Exp, Result)| computing $\mathit{Base}^{\mathit{Exp}}$ for non-negative integer exponents. First write a naive version, then optimize using repeated squaring.

\item \textbf{Prime Testing.} Implement \verb|is_prime(N)| that succeeds if \verb|N| is prime. Use trial division up to $\sqrt{N}$.

\item \textbf{Sum of List.} Implement \verb|sum(Xs, S)| that computes the sum of a numeric stream. Use an accumulator for efficiency.

\item \textbf{Memoized Fibonacci.} Design a Fibonacci implementation that avoids redundant computation by memoizing results. (Hint: use a stream to communicate computed values.)
\end{enumerate}
