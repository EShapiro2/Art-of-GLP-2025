%% Chapter: Basic Concurrent Programming
%% Part I, Chapter 4
%% NOTE: This chapter has NO type annotations - untyped GLP programming

\chapter{Basic Concurrent Programming}
\label{ch:basic-concurrent}

This chapter introduces \GLP programming through progressively richer examples.

%% ============================================
%% Section 1: Programming with Constants
%% ============================================

\section{Programming with Constants}
\label{sec:constants}

\subsection{Unit Clauses}

A \emph{unit clause} is a clause with an empty body. The simplest \GLP programs consist of unit clauses with constant arguments.

\begin{verbatim}
p(a).
\end{verbatim}

This clause defines \verb|p/1| with a single solution: \verb|p(a)| holds.

\paragraph{Goal with matching constant.}

\begin{verbatim}
GLP> p(a).
p(a) :- true
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

\paragraph{Goal with non-matching constant.}

\begin{verbatim}
GLP> p(b).
-> fails
\end{verbatim}
%% [TBC - trace from GLP Programming]

\paragraph{Goal with writer argument.}

\begin{verbatim}
GLP> p(X).
p(X) :- true
X = a
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

The writer \verb|X| receives the value \verb|a| from the clause head.

\paragraph{Goal with reader argument.}

\begin{verbatim}
GLP> p(X?).
p(X?) -> suspended
\end{verbatim}
%% [TBC - trace from GLP Programming]

A reader cannot receive a value---it can only observe a value produced elsewhere. With no writer to bind \verb|X|, the goal suspends.

\subsection{Conjunctive Goals}

When goals share a variable, execution order affects behavior.

\paragraph{Writer then reader.}

\begin{verbatim}
GLP> p(X), p(X?).
p(X) :- true
p(a) :- true
X = a
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

The first goal binds \verb|X = a|. The second goal, with reader \verb|X?|, succeeds since \verb|p(a)| matches.

\paragraph{Reader then writer.}

\begin{verbatim}
GLP> p(X?), p(X).
p(X?) -> suspended
p(X) :- true
p(a) :- true
X = a
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

The first goal suspends on the unbound reader. The second goal binds \verb|X = a|. The first goal reactivates and succeeds.

\subsection{Multiple Clauses}

When multiple clauses define a predicate, the first applicable clause is selected:

\begin{verbatim}
q(b).
q(a).
\end{verbatim}

\paragraph{Goal with writer argument.}

\begin{verbatim}
GLP> q(X).
q(X) :- true
X = b
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

With a writer argument, \verb|q(X)| commits to the first clause. Since \verb|q(b)| is first, \verb|X| is bound to \verb|b|.

\subsection{Conjunctive Goals with Different Predicates}

Combining \verb|p/1| and \verb|q/1| reveals how bindings propagate.

\paragraph{Writer from p, reader to q.}

\begin{verbatim}
GLP> p(X), q(X?).
p(X) :- true
q(a) :- true
X = a
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

The binding \verb|X = a| from \verb|p(X)| flows to \verb|q(X?)|, which succeeds because \verb|q(a)| matches.

\paragraph{Reader from p, writer from q.}

\begin{verbatim}
GLP> p(X?), q(X).
p(X?) -> suspended
q(X) :- true
p(b) -> fails
X = b
-> fails
\end{verbatim}
%% [TBC - trace from GLP Programming]

The goal \verb|p(X?)| suspends. Then \verb|q(X)| binds \verb|X = b|. When \verb|p(X?)| reactivates, it becomes \verb|p(b)|, which fails.

\subsection{Binary Unit Clauses}

\begin{verbatim}
p(a,b).
\end{verbatim}

\paragraph{Goal with two writers.}

\begin{verbatim}
GLP> p(X,Y).
p(X,Y) :- true
X = a
Y = b
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

\subsection{Shared Variables in Goals}

\begin{verbatim}
p(a,a).
\end{verbatim}

\paragraph{Writer-reader order.}

\begin{verbatim}
GLP> p(X,X?).
p(X,X?) :- true
X = a
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

When \verb|X| appears as both writer and reader in the same goal, the writer occurrence binds \verb|X|, and the reader occurrence observes that binding.

\subsection{Logic Gates}

Digital logic gates provide a natural example of dataflow computation:

\begin{verbatim}
and(1,1,1).
and(1,0,0).
and(0,1,0).
and(0,0,0).

or(1,1,1).
or(1,0,1).
or(0,1,1).
or(0,0,0).

not(1,0).
not(0,1).

xor(1,1,0).
xor(1,0,1).
xor(0,1,1).
xor(0,0,0).
\end{verbatim}

\begin{verbatim}
GLP> and(1,1,X).
and(1,1,X) :- true
X = 1
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

\subsection{Clauses with Bodies}

A NAND gate inverts the output of an AND gate:

\begin{verbatim}
nand(A,B,Z?) :- and(A?,B?,W), not(W?,Z).
\end{verbatim}

\begin{verbatim}
GLP> nand(1,1,X).
nand(1,1,X) :- and(1,1,W), not(W?,Z)
and(1,1,W) :- true
not(1,Z) :- true
X = 0
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

\begin{formal}{Produces and Consumes Parameters}
\label{formal:produces-consumes}

In \GLP, a clause \emph{produces} a value through a reader in the head, and
\emph{consumes} a value through a writer in the head.

Consider \verb|nand(A,B,Z?) :- and(A?,B?,W), not(W?,Z).|

\mypara{Produces}
The third parameter \verb|Z?| is a reader in the head. The body contains the
paired writer \verb|Z|, which produces the output value.

\mypara{Consumes}
The first two parameters \verb|A| and \verb|B| are writers in the head. The
body contains the paired readers \verb|A?| and \verb|B?|, which consume the
input values.

\mypara{Summary}
\begin{center}
\begin{tabular}{lll}
\textbf{Parameter role} & \textbf{Head} & \textbf{Body} \\
\hline
Produces & reader & writer \\
Consumes & writer & reader \\
\end{tabular}
\end{center}

These conventions follow from term matching (Definition~\ref{definition:term-matching})
and the SRSW constraint.
\end{formal}

\subsection{Guards for Multiple Reader Occurrences}

A half-adder takes two input bits and produces a sum and carry:

\begin{verbatim}
half_adder(A,B,Sum?,Carry?) :-
    ground(A?), ground(B?) |
    xor(A?,B?,Sum), and(A?,B?,Carry).
\end{verbatim}

The \verb|ground(A?)| and \verb|ground(B?)| guards are necessary because \verb|A?| and \verb|B?| each appear twice in the body. The guards ensure both inputs are fully bound before the body executes, permitting multiple reader occurrences (see Formal Box~\ref{formal:guards-multiple-reads}).

\begin{verbatim}
GLP> half_adder(1,1,S,C).
half_adder(1,1,S,C) :- xor(1,1,S), and(1,1,C)
xor(1,1,S) :- true
and(1,1,C) :- true
S = 0
C = 1
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

\subsection{Compound Circuits}

A full-adder adds three bits:

\begin{verbatim}
full_adder(A,B,Cin,Sum?,Cout?) :-
    half_adder(A?,B?,S1,C1),
    half_adder(S1?,Cin?,Sum,C2),
    or(C1?,C2?,Cout).
\end{verbatim}

Each reader appears only once in the body, so no guards are needed.

\begin{verbatim}
GLP> full_adder(1,1,1,S,C).
...
S = 1
C = 1
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

%% ============================================
%% Section 2: Streams
%% ============================================

\section{Streams}
\label{sec:streams}

A \emph{stream} is an incrementally-constructed list. Unlike a complete list that exists all at once, a stream is built element by element during computation.

\begin{itemize}
\item If a stream is \emph{bounded} (will eventually close), the consumer should have a clause for \verb|[]|.
\item If a stream is \emph{indefinite}, the consumer should \emph{not} have a clause for \verb|[]|---it should fail if the stream unexpectedly terminates.
\end{itemize}

\subsection{Producers and Consumers}

A producer that counts down from $N$:

\begin{verbatim}
producer([], 0).
producer([N?|Xs?], N) :- N? > 0 | N1 := N? - 1, producer(Xs, N1?).
\end{verbatim}

A consumer that sums stream elements:

\begin{verbatim}
consumer([], Sum, Sum?).
consumer([X|Xs], Sum, Result?) :- ground(X?) |
    Sum1 := Sum? + X?,
    consumer(Xs?, Sum1?, Result).
\end{verbatim}

\begin{formal}{SRSW in Continuation Calls}
\label{formal:srsw-continuations}

The recursive call passes readers \verb|Xs?|, \verb|Sum1?|---not writers.

\mypara{Why Readers in Continuations?}
When the goal matches the head, the writer \verb|Xs| receives a value.
It cannot appear as writer again in the body. Its paired reader \verb|Xs?|
must be used instead.

\textbf{Principle:} In continuation calls, pass readers for values already
received.
\end{formal}

\subsubsection{Concurrent Execution}

\begin{verbatim}
GLP> producer(H, 5), consumer(H?, 0, R).
producer(X1, 5) :- producer(X4, 4)
consumer([5 | X4?], 0, X2) :- consumer(X4?, 5, X6)
...
producer(X20, 0) :- true
consumer([], 15, X22) :- true
R = 15
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

\subsection{List Reversal}

\subsubsection{Naive Reverse}

\begin{verbatim}
reverse([], []).
reverse([X|Xs], Ys?) :-
    reverse(Xs?, Zs),
    append(Zs?, [X?], Ys).

append([], Ys, Ys?).
append([X|Xs], Ys, [X?|Zs?]) :- append(Xs?, Ys?, Zs).
\end{verbatim}

This is $O(n^2)$.

\subsubsection{Reverse with Accumulator}

\begin{verbatim}
reverse(Xs, Ys?) :- reverse_acc(Xs?, [], Ys).

reverse_acc([], Acc, Acc?).
reverse_acc([X|Xs], Acc, Ys?) :- reverse_acc(Xs?, [X?|Acc?], Ys).
\end{verbatim}

Total work: $O(n)$.

\begin{verbatim}
GLP> reverse([a,b,c], Ys).
reverse([a,b,c], Ys) :- reverse_acc([a,b,c], [], Ys)
reverse_acc([a,b,c], [], Ys) :- reverse_acc([b,c], [a], Ys)
reverse_acc([b,c], [a], Ys) :- reverse_acc([c], [b,a], Ys)
reverse_acc([c], [b,a], Ys) :- reverse_acc([], [c,b,a], Ys)
reverse_acc([], [c,b,a], Ys) :- true
Ys = [c,b,a]
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

\subsection{Stream Merging}

\subsubsection{Simple Fair Merge}

\begin{verbatim}
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Ys?, Xs?, Zs).
merge(Xs, [Y|Ys], [Y?|Zs?]) :- merge(Xs?, Ys?, Zs).
merge([], Ys, Ys?).
merge(Xs, [], Xs?).
\end{verbatim}

The key to fairness is swapping inputs: \verb|merge(Ys?, Xs?, Zs)|.

The two base cases \verb|merge([], Ys, Ys?)| and \verb|merge(Xs, [], Xs?)| have two advantages over a single \verb|merge([], [], [])| base case. First, merge terminates as soon as either stream closes, rather than requiring both to terminate---important when one stream may be indefinite. Second, when one stream closes, the entire remaining stream is copied to the output in a single step (\verb|Ys?| or \verb|Xs?|), rather than element-by-element through continued recursive calls.

\begin{verbatim}
GLP> merge([1,2,3], [a,b], Xs).
...
Xs = [1, a, 2, b, 3]
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

\subsubsection{Dynamic Merge}

\begin{verbatim}
dmerge([merge(Ws)|Xs], Ys, Zs?) :-
    dmerger(Ws?, Xs?, Xs1), dmerge(Xs1?, Ys?, Zs).
dmerge(Xs, [merge(Ws)|Ys], Zs?) :-
    dmerger(Ws?, Ys?, Ys1), dmerge(Xs?, Ys1?, Zs).
dmerge([X|Xs], Ys, [X?|Zs?]) :-
    tuple(X?), ~(X? =?= merge(_)) | dmerge(Ys?, Xs?, Zs).
dmerge([X|Xs], Ys, [X?|Zs?]) :-
    constant(X?) | dmerge(Ys?, Xs?, Zs).
dmerge(Xs, [Y|Ys], [Y?|Zs?]) :-
    tuple(Y?), ~(Y? =?= merge(_)) | dmerge(Xs?, Ys?, Zs).
dmerge(Xs, [Y|Ys], [Y?|Zs?]) :-
    constant(Y?) | dmerge(Xs?, Ys?, Zs).
dmerge([], [], []).

dmerger(Ws, Xs, Out?) :- dmerge(Ws?, Xs?, Out).
\end{verbatim}

\subsubsection{Static Balanced Merge Tree}

\begin{verbatim}
merge_tree([Xs], Xs?).
merge_tree([X,Y|Rest], Out?) :-
    merge_layer([X?,Y?|Rest?], Layer),
    merge_tree(Layer?, Out).

merge_layer([], []).
merge_layer([Xs], [Xs?]).
merge_layer([Xs,Ys|Rest], [Zs?|Layer?]) :-
    merge(Xs?, Ys?, Zs),
    merge_layer(Rest?, Layer).
\end{verbatim}

\subsection{Stream Distribution}

\subsubsection{Broadcast Distribution}

\begin{verbatim}
distribute([X|Xs], [X?|Ys?], [X?|Zs?]) :- ground(X?) | distribute(Xs?, Ys, Zs).
distribute([], [], []).
\end{verbatim}

The \verb|ground(X?)| guard permits replication.

\subsubsection{Indexed Distribution}

\begin{verbatim}
distribute_indexed([send(1,X)|In], [X?|Out1?], Out2) :-
    distribute_indexed(In?, Out1, Out2).
distribute_indexed([send(2,X)|In], Out1, [X?|Out2?]) :-
    distribute_indexed(In?, Out1, Out2).
distribute_indexed([], [], []).
\end{verbatim}

\subsection{Stream Observers}

\begin{verbatim}
observer([X|Xs], [X?|Ys?], [X?|Zs?]) :- ground(X?) | observer(Xs?, Ys, Zs).
observer([], [], []).
\end{verbatim}

\subsection{Ripple-Carry Adder}

An n-bit ripple-carry adder chains full-adders:

\begin{verbatim}
adder([],[],Cin,[Cin?]).
adder([A|As],[B|Bs],Cin,[S?|Ss?]) :-
    full_adder(A?,B?,Cin?,S,Cout),
    adder(As?,Bs?,Cout?,Ss).
\end{verbatim}

\begin{verbatim}
GLP> adder([1,0,1],[1,1,0],0,R).
...
R = [0,0,0,1]
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

The result \verb|[0,0,0,1]| is 1011 in binary (LSB first), which is 11: $5 + 6 = 11$.

\subsection{Buffered Communication}

\subsubsection{Sliding Window Buffer}

\begin{verbatim}
bb :- consumer([X1?, X2? | Xs]), producer(1, [X1, X2 | Xs?]).

consumer([X1, X2, X3 | Xs?]) :- known(X1?) | consumer([X2?, X3? | Xs]).

producer(N, [N? | Xs]) :- number(N?) | N1 := N? + 1, producer(N1?, Xs?).
\end{verbatim}

The buffer size (2) is the number of pre-allocated slots. The following trace uses a terminating version:

\begin{verbatim}
bb_test :- consumer([X1?, X2? | Xs], 10), producer(1, [X1, X2 | Xs?]).

consumer([X1, X2, X3 | Xs?], N) :- known(X1?), N? > 0 |
    N1 := N? - 1, consumer([X2?, X3? | Xs], N1?).
consumer(_, 0).

producer(N, [N? | Xs]) :- number(N?) | N1 := N? + 1, producer(N1?, Xs?).
\end{verbatim}

\begin{verbatim}
GLP> bb_test.
consumer([X1? | [X2? | X3]], 10) -> suspended
producer(1, [X1 | [X2 | X3?]]) :- producer(2, [X2 | X3?])
consumer([1 | [X2? | X3]], 10) :- consumer([X2? | [X6? | X7]], 9)
producer(2, [X2 | [X6 | X7?]]) :- producer(3, [X6 | X7?])
consumer([2 | [X6? | X7]], 9) :- consumer([X6? | [X10? | X11]], 8)
producer(3, [X6 | [X10 | X11?]]) :- producer(4, [X10 | X11?])
...
consumer([11 | [X42? | X43]], 0) :- true
producer(12, [X42 | X43?]) :- producer(13, X43?)
producer(13, X43?) -> suspended
-> succeeds
\end{verbatim}

The consumer suspends until the producer fills the first slot. Once running, they alternate: consumer processes $N$, producer writes $N+2$. When the consumer terminates, the producer suspends---no demand for element 13.

\subsection{Objects and Monitors}

Processes maintaining state in recursive parameters are the \GLP realization of \emph{objects}. A \emph{monitor} is an object accessed by multiple clients through a merge.

\subsubsection{Counter}

\begin{verbatim}
counter(In) :- counter_loop(In?, 0).

counter_loop([clear|In], _) :- counter_loop(In?, 0).
counter_loop([add|In], C) :- C1 := C? + 1, counter_loop(In?, C1?).
counter_loop([read(C?)|In], C) :- number(C?) | counter_loop(In?, C?).
counter_loop([], _).
\end{verbatim}

\begin{verbatim}
GLP> counter([add, add, add, read(X), clear, add, read(Y), []]).
...
X = 3
Y = 1
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

\begin{formal}{Which Guards Enable Multiple Reader Occurrences?}
\label{formal:guards-multiple-reads}

The counter's \verb|read| clause uses \verb|number(C?)| to enable replication.
Here \verb|C?| appears twice in the body.

\mypara{The Danger of Replicating Readers}
If \verb|C?|'s value contains an unbound writer, both occurrences
would have access to it---violating single-writer.

\mypara{Ground Guard}
The guard \verb|ground(C?)| succeeds only if \verb|C?| contains no unbound
variables.

\mypara{Type Guards}
Type guards like \verb|constant(X?)|, \verb|number(X?)|, and \verb|integer(X?)|
also enable multiple reader occurrences---these types cannot contain variables.

\mypara{The known Guard Does Not Enable Multiple Reads}
The guard \verb|known(X?)| only tests that \verb|X?| is bound to \emph{some}
value---which may contain unbound variables.

\textbf{Summary:}
\begin{center}
\begin{tabular}{ll}
\textbf{Guard} & \textbf{Multiple reads?} \\
\hline
\verb|ground(X?)| & Yes \\
\verb|constant(X?)| & Yes \\
\verb|number(X?)| & Yes \\
\verb|integer(X?)| & Yes \\
\verb|tuple(X?)| & No \\
\verb|known(X?)| & No \\
\end{tabular}
\end{center}
\end{formal}

\subsubsection{Accumulator}

\begin{verbatim}
accumulator(In) :- acc_loop(In?, 0).

acc_loop([add(N)|In], Sum) :- number(N?) |
    Sum1 := Sum? + N?, acc_loop(In?, Sum1?).
acc_loop([read(Sum?)|In], Sum) :- number(Sum?) | acc_loop(In?, Sum?).
acc_loop([], _).
\end{verbatim}

Multiple clients through a merge:

\begin{verbatim}
test_acc :-
    merge(Client1?, Client2?, In),
    accumulator(In?),
    client1(Client1),
    client2(Client2).

client1([add(10), add(20), read(X) | []]) :- number(X?) | true.
client2([add(5), read(Y) | []]) :- number(Y?) | true.
\end{verbatim}

%% ============================================
%% Section 3: Recursive Programming
%% ============================================

\section{Recursive Programming}
\label{sec:recursive}

We distinguish \emph{tail recursion} (iteration by a single process) from \emph{true recursion} (concurrent processes forming a computation tree).

\subsection{Peano Arithmetic}

Peano arithmetic represents natural numbers using zero and successor:

\begin{verbatim}
plus(0, Y, Y?).
plus(s(X), Y, s(Z?)) :- plus(X?, Y?, Z).

times(0, _, 0).
times(s(X), Y, Z?) :- tuple(Y?) | times(X?, Y?, XY), plus(XY?, Y?, Z).

lesseq(0, X) :- natural_number(X?) | true.
lesseq(s(X), s(Y)) :- lesseq(X?, Y?).

natural_number(0).
natural_number(s(X)) :- natural_number(X?).
\end{verbatim}

\subsection{Integer Arithmetic}

\begin{verbatim}
double(X, Y?) :- Y := X? * 2.
average(X, Y, Avg?) :- Avg := (X? + Y?) / 2.

abs(X, X?) :- X? >= 0 | true.
abs(X, Y?) :- X? < 0 | Y := 0 - X?.

max(X, Y, X?) :- X? >= Y? | true.
max(X, Y, Y?) :- X? < Y? | true.
\end{verbatim}

\subsection{Recursive Numeric Functions}

\paragraph{Factorial.}

\begin{verbatim}
factorial(0, 1).
factorial(1, 1).
factorial(N, F?) :-
    N? > 1 |
    N1 := N? - 1,
    factorial(N1?, F1),
    F := N? * F1?.
\end{verbatim}

\paragraph{Tail-Recursive Factorial.}

\begin{verbatim}
factorial(N, F?) :- fact_acc(N?, 1, F).

fact_acc(0, Acc, Acc?).
fact_acc(N, Acc, F?) :-
    N? > 0 |
    Acc1 := Acc? * N?,
    N1 := N? - 1,
    fact_acc(N1?, Acc1?, F).
\end{verbatim}

\paragraph{Fibonacci.}

\begin{verbatim}
fib(0, 0).
fib(1, 1).
fib(N, F?) :-
    N? > 1 |
    N1 := N? - 1,
    N2 := N? - 2,
    fib(N1?, F1),
    fib(N2?, F2),
    F := F1? + F2?.
\end{verbatim}

This spawns $O(2^N)$ processes.

\paragraph{Linear Fibonacci.}

\begin{verbatim}
fib_linear(N, F?) :- fib_acc(N?, 0, 1, F).

fib_acc(0, A, _, A?).
fib_acc(N, A, B, F?) :-
    N? > 0 |
    N1 := N? - 1,
    AB := A? + B?,
    fib_acc(N1?, B?, AB?, F).
\end{verbatim}

\subsection{Flattening Nested Lists}

\begin{verbatim}
flatten(Xs, Ys?) :- flatten_acc(Xs?, [], Ys).

flatten_acc([], Acc, Acc?).
flatten_acc([X|Xs], Acc, Ys?) :-
    ground(X?), is_list(X?) |
    flatten_acc(X?, Acc?, Acc1),
    flatten_acc(Xs?, Acc1?, Ys).
flatten_acc([X|Xs], Acc, Ys?) :-
    otherwise |
    flatten_acc(Xs?, [X?|Acc?], Ys).
\end{verbatim}

\subsection{Binary Trees}

\begin{verbatim}
tree_sum(void, 0).
tree_sum(tree(V, L, R), S?) :-
    tree_sum(L?, SL),
    tree_sum(R?, SR),
    S := V? + SL? + SR?.
\end{verbatim}

The two recursive calls spawn concurrently.

\subsection{Insertion Sort}

\begin{verbatim}
insertion_sort([], []).
insertion_sort([X|Xs], Sorted?) :-
    insertion_sort(Xs?, SortedTail),
    insert(X?, SortedTail?, Sorted).

insert(X, [], [X?]).
insert(X, [Y|Ys], [X?|[Y?|Ys?]]) :- X? < Y? | true.
insert(X, [Y|Ys], [Y?|Zs?]) :- X? >= Y? | insert(X?, Ys?, Zs).
\end{verbatim}

\subsection{Merge Sort}

\begin{verbatim}
mergesort([], []).
mergesort([X], [X?]).
mergesort([A,B|Xs], Sorted?) :-
    split2(A?, B?, Xs?, Left, Right),
    mergesort(Left?, SortedL),
    mergesort(Right?, SortedR),
    merge_sorted(SortedL?, SortedR?, Sorted).

split2(A, B, [], [A?], [B?]).
split2(A, B, [X], [A?,X?], [B?]).
split2(A, B, [X,Y|Xs], [A?|Left?], [B?|Right?]) :-
    split2(X?, Y?, Xs?, Left, Right).

merge_sorted([], Ys, Ys?).
merge_sorted(Xs, [], Xs?).
merge_sorted([X|Xs], [Y|Ys], [X?|Zs?]) :-
    number(X?), number(Y?), X? =< Y? |
    merge_sorted(Xs?, [Y?|Ys?], Zs).
merge_sorted([X|Xs], [Y|Ys], [Y?|Zs?]) :-
    number(X?), number(Y?), X? > Y? |
    merge_sorted([X?|Xs?], Ys?, Zs).
\end{verbatim}

\begin{verbatim}
GLP> mergesort([3,1,4,1,5,9,2,6], S).
...
S = [1,1,2,3,4,5,6,9]
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

\subsection{Non-Ground Stream Distributor}

For messages containing unbound subterms:

\begin{verbatim}
distribute_ng([X|Xs], [Y?|Ys?], [Z?|Zs?]) :-
    copy(X?, Y, Z),
    distribute_ng(Xs?, Ys, Zs).
distribute_ng([], [], []).

copy(X, Y, Z) :- constant(X?) | Y = X?, Z = X?.
copy(X, Y, Z) :- number(X?) | Y = X?, Z = X?.
copy(X, Y, Z) :- compound(X?) |
    X? =.. [F|Args],
    copy_list(Args?, Args1, Args2),
    Y =.. [F?|Args1?],
    Z =.. [F?|Args2?].

copy_list([], [], []).
copy_list([H|T], [H1?|T1?], [H2?|T2?]) :-
    copy(H?, H1, H2),
    copy_list(T?, T1, T2).
\end{verbatim}

If a subterm is unbound, none of the guards succeed, so the goal suspends. When the producer later binds the subterm, copying proceeds.

\subsection{Tree Substitution}

\begin{verbatim}
substitute(_, _, void, void).
substitute(X, Y, tree(Leaf, Left, Right), tree(Leaf1?, Left1?, Right1?)) :-
    ground(X?), ground(Y?) |
    replace(X?, Y?, Leaf?, Leaf1),
    substitute(X?, Y?, Left?, Left1),
    substitute(X?, Y?, Right?, Right1).

replace(X, Y, Z, Y?) :- ground(X?), X? =?= Z? | true.
replace(X, _, Z, Z?) :- ground(X?), ~(X? =?= Z?) | true.
\end{verbatim}

%% ============================================
%% Section 4: Metaprogramming
%% ============================================

\section{Metaprogramming}
\label{sec:meta}

Programs that manipulate, interpret, and transform other programs. In logic programming, programs are data: clauses are terms, goals are terms.

\subsection{Programs as Data}

A \GLP clause:
\begin{verbatim}
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Xs?, Ys?, Zs).
\end{verbatim}

can be represented using a \verb|reduce/2| encoding:
\begin{verbatim}
reduce(merge([X|Xs], Ys, [X?|Zs?]), merge(Xs?, Ys?, Zs)).
reduce(merge(Xs, [Y|Ys], [Y?|Zs?]), merge(Xs?, Ys?, Zs)).
reduce(merge([], [], []), true).
\end{verbatim}

\subsection{Trust Mode Meta-Interpreter}

\begin{verbatim}
run(M, true).                                    % halt
run(M, (A,B)) :- run(M?, A?), run(M?, B?).       % fork
run(M, M1 # G) :- run(M1?, G?).                  % cross-module
run(M, A) :- tuple(A?) | M # reduce(A?, B), run(M?, B?).  % reduce
\end{verbatim}

\begin{itemize}
\item \textbf{Halt}: \verb|true| terminates.
\item \textbf{Fork}: Conjunction spawns two processes.
\item \textbf{Cross-module}: \verb|M1 # G| switches modules.
\item \textbf{Reduce}: Look up clause, continue with body.
\end{itemize}

\begin{verbatim}
GLP> run(merge, merge([1,2], [3,4], Zs)).
...
Zs = [1, 3, 2, 4]
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

\subsection{Fail-safe Meta-Interpreter}

Reports failures using short-circuit:

\begin{verbatim}
run(M, true, L, L?).                             % halt - close circuit
run(M, (A,B), L, R?) :-                          % fork - split chain
    run(M?, A?, L?, Mid),
    run(M?, B?, Mid?, R).
run(M, M1 # G, L, R?) :- run(M1?, G?, L?, R).    % cross-module
run(M, failed(A), L, [failed(A?)|L?]).           % report failure
run(M, A, L, R?) :-                              % reduce
    tuple(A?) |
    M # reduce(A?, B),
    run(M?, B?, L?, R).
\end{verbatim}

The object program must include:
\begin{verbatim}
reduce(A, failed(A?)) :- otherwise | true.
\end{verbatim}

\subsection{Control Meta-Interpreter}

Adds control stream for suspend/resume/abort:

\begin{verbatim}
run(M, true, _, L, L?).                          % halt
run(M, (A,B), Cs, L, R?) :-                      % fork
    ground(Cs?) |
    run(M?, A?, Cs?, L?, Mid),
    run(M?, B?, Cs?, Mid?, R).
run(M, M1 # G, Cs, L, R?) :-                     % cross-module
    run(M1?, G?, Cs?, L?, R).
run(M, A, [suspend|Cs], L, R?) :-                % suspend
    suspended_run(M?, A?, Cs?, L?, R).
run(M, A, Cs, L, R?) :-                          % reduce
    tuple(A?) |
    M # reduce(A?, B),
    run(M?, B?, Cs?, L?, R).

suspended_run(M, A, [resume|Cs], L, R?) :-       % resume
    run(M?, A?, Cs?, L?, R).
suspended_run(_, A, [abort|_], L, [A?|L?]).      % abort + dump
\end{verbatim}

The \verb|ground(Cs?)| guard allows the control stream to be shared among all forked processes.

\subsection{Tracing Meta-Interpreter}

Builds an execution tree:

\begin{verbatim}
run(M, true, true).                              % halt
run(M, (A,B), fork(TA?, TB?)) :-                 % fork
    run(M?, A?, TA),
    run(M?, B?, TB).
run(M, A, reduction(A_copy?, I?, TB?)) :-        % reduce
    tuple(A?) |
    copy(A?, A_exec, A_copy),
    M # reduce(A_exec?, B, I),
    run(M?, B?, TB).
\end{verbatim}

The \verb|copy/3| predicate (Section~\ref{sec:recursive}) creates independent copies: \verb|A_exec| drives execution, \verb|A_copy| is frozen for the trace.

The object program provides clause indices:
\begin{verbatim}
reduce(merge([X|Xs], Ys, [X?|Zs?]), merge(Xs?, Ys?, Zs), 1).
reduce(merge(Xs, [Y|Ys], [Y?|Zs?]), merge(Xs?, Ys?, Zs), 2).
reduce(merge([], [], []), true, 3).
\end{verbatim}

\begin{verbatim}
GLP> run(merge, merge([1,2], [a,b], Zs), Tree).
Zs = [1, a, 2, b]
Tree = reduction(merge([1,2], [a,b], [1,a,2,b]), 1,
         reduction(merge([2], [a,b], [a,2,b]), 2,
           ...))
-> succeeds
\end{verbatim}
%% [TBC - trace from GLP Programming]

Given a trace, replay executes deterministically:
\begin{verbatim}
replay(M, true, true).
replay(M, fork(T1, T2), (A?, B?)) :-
    replay(M?, T1?, A),
    replay(M?, T2?, B).
replay(M, reduction(_, I, SubTree), Goal?) :-
    M # reduce_by_index(I?, Goal, Body),
    replay(M?, SubTree?, Body?).
\end{verbatim}
