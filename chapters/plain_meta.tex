% chapters/ch13_plain_meta.tex - Plain Metaprogramming

\chapter{Metaprogramming}
\label{ch:plain-meta}

This chapter introduces metaprogramming---programs that manipulate programs. In logic programming, programs are data: clauses are terms, goals are terms. This fundamental property enables powerful metaprogramming techniques for interpreting, transforming, and analyzing programs.

\section{Programs as Data}
\label{sec:programs-as-data}

A \GLP clause like:
\begin{verbatim}
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Xs?, Ys?, Zs).
\end{verbatim}

can be represented as a term:
\begin{verbatim}
clause(merge([X|Xs], Ys, [X?|Zs?]), merge(Xs?, Ys?, Zs))
\end{verbatim}

Or using a \verb|reduce/2| encoding where the first argument is the goal pattern and the second is the body:
\begin{verbatim}
reduce(merge([X|Xs], Ys, [X?|Zs?]), merge(Xs?, Ys?, Zs)).
\end{verbatim}

This representation allows programs to examine, modify, and execute other programs.

\section{The Vanilla Meta-Interpreter}
\label{sec:vanilla-meta}

The simplest meta-interpreter for logic programming:

\begin{verbatim}
solve(true).
solve((A, B)) :- solve(A), solve(B).
solve(A) :- clause(A, B), solve(B).
\end{verbatim}

This interpreter:
\begin{itemize}
\item Terminates on \verb|true|
\item Handles conjunction by solving both conjuncts
\item Reduces a goal by finding a matching clause and solving its body
\end{itemize}

\section{The GLP Plain Meta-Interpreter}
\label{sec:glp-plain-meta}

The \GLP version uses \verb|reduce/2| encoding and adds concurrency:

\begin{verbatim}
run(true).                              % halt
run((A,B)) :- run(A?), run(B?).         % fork
run(A) :- known(A) | reduce(A?,B), run(B?).  % reduce
\end{verbatim}

The \verb|known(A)| guard (Appendix~\ref{appendix:guard-unification}) tests whether the term \verb|A| has a known principal functor---that is, whether we can determine which predicate is being called. Unlike \verb|ground|, which requires all subterms to be bound, \verb|known| succeeds as soon as the outer structure is determined. For example, \verb|known(merge([X|Xs], Ys, Zs))| succeeds even if \verb|X|, \verb|Xs|, \verb|Ys|, and \verb|Zs| are unbound, because the functor \verb|merge/3| is known. The guard suspends if \verb|A| is an unbound reader, since clause selection cannot proceed until we know which predicate to reduce.

\paragraph{The Fork Rule.} When running a conjunction \verb|(A,B)|, we spawn two concurrent processes: \verb|run(A?)| and \verb|run(B?)|. The readers \verb|A?| and \verb|B?| ensure the conjuncts are processed after any bindings from the parent.

\paragraph{The Reduce Rule.} The guard \verb|known(A)| ensures the goal is sufficiently instantiated before attempting reduction. The \verb|reduce(A?,B)| call finds a matching clause and returns the body in \verb|B|.

\paragraph{Program Encoding.} The object program is encoded as \verb|reduce/2| facts:

\begin{verbatim}
%% merge encoded for meta-interpreter
reduce(merge([X|Xs],Ys,[X?|Zs?]), merge(Xs?,Ys?,Zs)).
reduce(merge(Xs,[Y|Ys],[Y?|Zs?]), merge(Xs?,Ys?,Zs)).
reduce(merge([],[],[]), true).
\end{verbatim}

\paragraph{Example Execution.}
\begin{verbatim}
?- run(merge([1,2],[3,4],Z)).
Z = [1,3,2,4] (or another valid interleaving)
\end{verbatim}

The meta-interpreter executes the encoded merge program, producing merged results.

\section{Fail-Safe Meta-Interpreter}
\label{sec:failsafe-meta}

The plain meta-interpreter aborts on failure (no matching \verb|reduce| clause). The \emph{fail-safe} meta-interpreter reports failures instead:

\begin{verbatim}
run(true, []).                              % halt
run((A,B), Zs?) :-                          % fork
    run(A?, Xs), run(B?, Ys),
    merge(Xs?, Ys?, Zs).
run(fail(A), [fail(A?)]).                   % report failure
run(A, Xs?) :- known(A) | reduce(A?,B), run(B?,Xs).  % reduce
\end{verbatim}

The second argument collects failure reports as a stream. Each failure produces \verb|fail(Goal)| in the output.

\paragraph{Failure Handling.} The program encoding must include a catch-all clause:
\begin{verbatim}
reduce(A, failed(A)) :- otherwise | true.
\end{verbatim}

When no specific \verb|reduce| clause matches, this clause fires, marking the goal as failed. The meta-interpreter then reports \verb|fail(A)|.

\paragraph{Failure Merging.} The fork rule merges failure reports from both branches. A conjunction \verb|(A,B)| collects failures from both \verb|A| and \verb|B|, even if one succeeds.

\paragraph{Debugging Use.} The failure stream enables debugging:
\begin{verbatim}
run(MyProgram?, Failures), analyze_failures(Failures?).
\end{verbatim}

Failed goals are collected for analysis without aborting the entire computation.

\section{Termination Detection}
\label{sec:termination-detection}

In distributed systems, detecting when all processes have terminated is non-trivial---the ``distributed termination detection'' problem. The \emph{short-circuit} technique solves this elegantly in \GLP.

\subsection{The Short-Circuit Technique}

We thread a ``chain'' through the computation as a difference list:

\begin{verbatim}
reduce(P, true, Chain--Chain?).              % halt - close circuit
reduce(P, (A, B), Left--Right) :-            % fork - split chain
    reduce(P?, A?, Left?--Middle),
    reduce(P?, B?, Middle?--Right).
reduce(P, Goal, Left--Right) :-              % reduce - pass chain
    Goal =\= true, Goal =\= (_, _),
    clause(Goal?, P?, Body) |
    reduce(P?, Body?, Left?--Right).
\end{verbatim}

\paragraph{How It Works.}
\begin{enumerate}
\item Start with \verb|reduce(Program, Goal, done--Done)|
\item Each \verb|true| (termination) closes part of the circuit: \verb|Chain--Chain?|
\item Forks split the chain: left branch gets \verb|Left--Middle|, right gets \verb|Middle--Right|
\item When all branches terminate, the circuit closes: \verb|Done| unifies with \verb|done|
\end{enumerate}

\paragraph{Circuit Closing.} The difference list acts as a logical ``wire.'' Each \verb|true| connects its input to its output. When all parallel paths terminate, the initial \verb|done| propagates through to \verb|Done|.

\paragraph{Usage.}
\begin{verbatim}
reduce(Program, MyGoal, done--Done), wait_for(Done?).
wait_for(done).
\end{verbatim}

The \verb|wait_for| goal suspends until \verb|Done?| becomes \verb|done|, indicating complete termination.

\subsection{Why This Works}

Consider a fork:
\begin{verbatim}
reduce(P, (A, B), Left--Right) :-
    reduce(P?, A?, Left?--Middle),
    reduce(P?, B?, Middle?--Right).
\end{verbatim}

\begin{itemize}
\item \verb|A| receives chain \verb|Left--Middle|
\item \verb|B| receives chain \verb|Middle--Right|
\item When \verb|A| terminates: \verb|Left| connects to \verb|Middle|
\item When \verb|B| terminates: \verb|Middle| connects to \verb|Right|
\item Both terminated: \verb|Left| connects to \verb|Right| (transitively)
\end{itemize}

The chain closes only when \emph{all} parallel branches have terminated.

\section{Program Transformation}
\label{sec:program-transformation}

Meta-interpreters can transform programs by modifying the interpretation:

\paragraph{Adding Instrumentation.}
\begin{verbatim}
run_counted(true, 0).
run_counted((A,B), N?) :-
    run_counted(A?, NA), run_counted(B?, NB),
    N := NA? + NB?.
run_counted(A, N?) :- known(A) |
    reduce(A?,B), run_counted(B?, NB), N := NB? + 1.
\end{verbatim}

This counts reduction steps.

\paragraph{Partial Evaluation.} A meta-interpreter can partially evaluate a program:
\begin{verbatim}
pe(true, true).
pe((A,B), (PA?, PB?)) :- pe(A?, PA), pe(B?, PB).
pe(A, PA?) :- known(A), reduce(A,B) | pe(B?, PA).
pe(A, A?) :- unknown(A) | true.  % leave unresolved
\end{verbatim}

The \verb|unknown(A)| guard is the complement of \verb|known|: it succeeds when \verb|A|'s principal functor is not yet determined (i.e., \verb|A| is an unbound variable). This allows the partial evaluator to preserve goals that cannot yet be reduced, leaving them for later instantiation.

Reducible goals are simplified; unresolved goals are preserved.

\section{Exercises}
\label{sec:meta-exercises}

\begin{enumerate}
\item \textbf{Step Counter.} Modify the plain meta-interpreter to count the number of reduction steps taken.

\item \textbf{Depth Limiter.} Add a depth limit to prevent infinite recursion. The interpreter should fail (or report) when the depth exceeds a threshold.

\item \textbf{Choice Point Collector.} Modify the fail-safe meta-interpreter to collect choice points---goals where multiple \verb|reduce| clauses match.

\item \textbf{Call Graph.} Write a meta-interpreter that builds a call graph showing which predicates call which others.

\item \textbf{Time-Bounded Execution.} Combine termination detection with a timeout mechanism that aborts computation after a time limit.
\end{enumerate}
