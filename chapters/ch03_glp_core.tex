\section{GLP}\label{section:GLP}

We present GLP as an extension of Logic Programs: The syntax is extended with reader variables $X?$, where $X$ and $X?$ form a reader/writer pair, and with the Single-Reader/Single-Writer syntactic restriction on clauses.  For example, here is the quintessential concurrent logic program for merging two streams (incrementally constructed, potentially unbounded lists), written in GLP.  Its first two arguments are the input streams to be merged,  the third is the merged output stream:

\Program{GLP Fair Stream Merger}\label{program:merge}
\begin{small}
\begin{verbatim}
merge([X|Xs],Ys,[X?|Zs?]) :- merge(Ys?,Xs?,Zs). % output from first stream
merge(Xs,[Y|Ys],[Y?|Zs?]) :- merge(Xs?,Ys?,Zs). % output from second stream
merge([],[],[]).                                % terminate on empty streams
\end{verbatim}
\end{small}
Note that in each clause, each reader or writer occurs at most once.

The operational semantics of GLP extends that of LP as follows:
\begin{enumerate}
\item \textbf{Synchronisation}: Unification may only instantiate writers, so in addition to succeed/fail, unification may suspend if it requires instantiating readers.

\item \textbf{Communication}: When a unifying writer substitution binds a writer $X$ to a term $T$, the message  $X? := T$ encoding its paired reader assignment is created and added to the configuration. Its application happens asynchronously, realizing a message $T$ from the single occurrence of $X$ to the single occurrence of $X?$.

\item \textbf{Deterministic clause selection}: The first applicable clause is chosen, not nondeterministically as in LP. This provides for the fairness of \verb|merge| presented above:  As long as the two input streams are available the output dovetails the two inputs, due to switching their order in the recursive call of the first clause; as long as only one stream is available, its elements are copied to the output; and when both streams are unavailable the goal suspends.
\end{enumerate}

The remainder of this section presents GLP syntax, nondeterministic operational semantics, and safety properties. A deterministic `workstation implementation-ready' transition-system specification for GLP is presented in Appendix~\ref{appendix:irGLP}.

\subsection{GLP Syntax}

\mypara{Reader/Writer pairs}
GLP extends Logic Programs with paired reader/writer variables, where a \emph{writer} $X$ is a single-assignment variable (promise) and its \emph{paired reader $X?$} provides read-only access to the (future) value of $X$. We denote by $V$ the set of all writers, $V?$ the set of all readers and, $\mathcal{V} = V \cup V?$ the set of all variables, where for each writer $X \in V$ there exists a paired reader $X? \in V?$.
We view $?$ as an identity suffix operator on non-writers, namely  $(X?)?=X?$ for $X?\in V?$ and $T?=T$ for $T\notin \calV$.
We use $\calA_?$ and $\calG_?$ to denote the set of all atoms and goals, respectively, over $\calV$ (i.e., goals that may contain both readers and writers), and for a GLP program $M$,  $\calA_?(M)$  and $\calG_?(M)$ to denote the subsets of  $\calA_?$ and $\calG_?$, respectively,  restricted to the vocabulary of $M$.


\mypara{Single-Reader/Single Writer (SRSW)} The fundamental requirement in GLP is \emph{single-writer}: any writer may occur at most once in any state of a computation, ensuring there can be no conflict when writing on a logic variable. We extend it to the \emph{single-reader/single-writer (SRSW) requirement} that any reader also occurs at most once. The reason is that with multiple instances of a reader, instantiating the writer to a term containing another writer would give all instances of the paired reader access to that writer, violating the single-writer requirement.
The SRSW requirement is realized by two complementary concepts:
\begin{enumerate}
    \item \emph{SRSW syntactic restriction on clauses}: Variables in a clause occur as reader/writer pairs, with exactly one of each.
    \item \emph{SRSW invariant}:  Given a resolvent that satisfies the SRSW requirement, applying to it a goal reduction with a clause that satisfies the SRSW syntactic restriction produces a new resolvent that also satisfies the SRSW requirement.
\end{enumerate}
This SRSW syntactic restriction excludes programs like the equality definition $X=X$ as it has two occurrences of the writer $X$. At the same time it
eliminates the need for distributed atomic unification~\cite{kleinman1990distributed}—replacing it with efficient point-to-point communication of a single assignment from the single occurrence of a writer to the single occurrence of its paired reader.

\mypara{No writer-to-writer binding (WxW)}
In addition, GLP requires \emph{no writer-to-writer} binding (WxW).  A reader/writer pair $X?/X$ is a communication channel from the writer $X$ to the reader $X?$.
It two writers $X$ and $Y$ are unified during execution, the SRSW requirement implies that no occurrences of either $X$ or $Y$ are left to instantiate them, and therefore their paired readers $X?$ and $Y?$ will be left \emph{abandoned}.  Combined,  the WxW and SRSW restrictions ensure that communication channels are properly closed, with no reader is left abandoned by their paired variable.\footnote{We discuss below a relaxation, allowing a reader to abandon its paired writer using anonymous variables $_$, which useful in case there is no need to read the channel any more.}

\subsection{GLP Operational semantics}

\begin{definition}[Writer and Reader Substitution, Reader Counterpart, Suspension Set, Writer MGU]\label{definition:GLP-unification}

A substitution $\sigma$ is a \temph{writer substitution} if  $\sigma$:
\begin{enumerate}
    \item only binds writers: $V_\sigma \subset V$
    \item does not bind writers to writers: if $X\ne X\sigma$ for $X\in V$ then $X\sigma\notin V$
    \item does not form cycles through readers:  $X?$ does not occur in $X\sigma$ for any $X \in V_\sigma$
\end{enumerate}
A substitution $\sigma$ is a \temph{reader substitution} if $V_\sigma \subset V?$.
If $\sigma$ is a writer substitution then its \temph{reader counterpart} is the reader substitution  $\sigma?$  defined by $X?\sigma? = X\sigma$ for every $X\in V_\sigma$.

The \temph{suspension set} of a (regular) substitution $\sigma$ is $W_\sigma:= \{X?\in V? : X?\sigma \notin \calV\}$.

The \temph{writer unification} of two terms:
\begin{enumerate}
    \item \temph{succeeds with $\sigma$} if they have a writer mgu $\sigma$.
    \item else \temph{suspends on $W_\sigma$} if they have a (regular) mgu $\sigma$
    \item else \temph{fails}
\end{enumerate}
\end{definition}
\begin{remark}
If a writer mgu exists it is unique, rather than unique up to renaming,  since it does not include writer-to-writer assignments.
If writer-to-writer assignments were allowed then, by the single-writer restriction, the assignment would leave their two paired readers \emph{abandoned}, namely without a writer that can provide them with a value.
The occurs check condition for the reader counterpart ensures that no writer is bound to a term containing its paired reader, preventing the formation of circular terms, as proven in Proposition~\ref{proposition:acyclicity}.
\end{remark}

\begin{remark}[Writer-to-Writer Failure]
The formal definition as stated would have writer-to-writer unification suspend on an empty set: the regular mgu $\{X := Y\}$ exists but violates condition 2, and $W_\sigma = \emptyset$ since no readers are involved.

However, suspending on an empty set is operationally meaningless---there is nothing to wait for. By the SRSW requirement, after binding writer $X$ to writer $Y$, no other occurrence of either writer remains to instantiate them. Their paired readers $X?$ and $Y?$ would be \emph{abandoned}---forever waiting for values that will never arrive.

More importantly, writer-to-writer failure is \emph{semantically significant} for clause selection. Programs can use WxW failure to discriminate between clauses based on whether an argument position contains a writer or reader tail. For example, an observer of a cooperatively-constructed stream uses two clauses:
\begin{verbatim}
observe([X|Xs], Ys?, ...) :- ...   % first stream producing
observe([X|Xs?], Ys, ...) :- ...   % second stream producing
\end{verbatim}
Clause selection depends on WxW failure: if the goal has a writer tail, it fails against a clause head with a writer tail, succeeding against one with a reader tail.

Therefore, writer-to-writer unification \emph{fails} rather than suspending. This should be understood as part of the formal semantics: the definition of writer mgu (Definition~\ref{definition:GLP-unification}) excludes writer-to-writer bindings, and when the only regular mgu is excluded, the terms have no writer mgu, hence no regular mgu satisfying the requirements, hence unification fails.
\end{remark}

\subsection{Understanding Writer Unification}

The definition of writer unification has three cases in priority order: succeed, suspend, fail. To determine the outcome for two terms, work through the cases systematically.

\mypara{Deriving outcomes from the definition}
Given two terms to unify:
\begin{enumerate}
    \item First, check if a \emph{writer mgu} exists---a most general unifier that satisfies all three conditions of a writer substitution (only binds writers, no writer-to-writer bindings, no cycles through readers).
    \item If yes, unification \emph{succeeds} with that substitution.
    \item If no writer mgu exists, check if a \emph{regular mgu} exists (standard unification ignoring reader/writer distinctions).
    \item If a regular mgu exists, compute the suspension set $W_\sigma$: the goal readers that would be mapped to non-variables. Unification \emph{suspends} on $W_\sigma$.
    \item If no regular mgu exists, unification \emph{fails}.
\end{enumerate}

\mypara{Example derivations}
Consider unifying goal $g$ with clause head $h$ in the following cases:

\begin{itemize}
\item $g = f(X, a)$, $h = f(b, Y)$: Regular mgu is $\{X := b, Y := a\}$. This binds only writers to non-writers. All three conditions of writer substitution are satisfied. \emph{Succeeds} with $\{X := b, Y := a\}$.

\item $g = f(X?, a)$, $h = f(b, Y)$: Regular mgu would be $\{X? := b, Y := a\}$. But this binds reader $X?$, violating condition 1 of writer substitution. No writer mgu exists. Regular mgu exists, so compute $W_\sigma = \{X?\}$ (goal reader mapped to non-variable $b$). \emph{Suspends} on $\{X?\}$.

\item $g = f(a, b)$, $h = f(a, c)$: No mgu exists ($b \neq c$). \emph{Fails}.

\item $g = f(X)$, $h = f(Y)$: Regular mgu is $\{X := Y\}$ (or $\{Y := X\}$). Both $X$ and $Y$ are writers, so this violates condition 2 of writer substitution. No writer mgu. But regular mgu exists with $W_\sigma = \emptyset$ (no readers involved). By the formal definition, this would \emph{suspend on $\emptyset$}---but as noted above, the implementation treats this as failure.
\end{itemize}

\mypara{Summary of unification outcomes}
The following table summarizes writer unification outcomes, derived from the formal definition:

\begin{center}
\begin{tabular}{lll}
\textbf{Goal} & \textbf{Head} & \textbf{Result} \\
\hline
$f(\ldots)$ & $g(\ldots)$ & fails (different functors) \\
ground & ground & succeeds if equal, fails if different \\
writer & writer & fails (pragmatic---abandoned readers) \\
writer & non-writer & succeeds, writer bound \\
reader & writer & succeeds, writer bound to reader \\
reader & non-writer & suspends \\
compound & compound & recursive unification \\
\end{tabular}
\end{center}

\begin{remark}[Programming Style: Fold Unifications into the Head]
When a clause needs to test the structure of an argument, fold the pattern directly into the clause head rather than using explicit unification in the guard.

For example, to process a list with at least two elements:
\begin{verbatim}
% Avoid: explicit unification in guard
merge_tree(Streams, Out?) :-
    Streams = [_,_|_] |
    merge_layer(Streams?, Layer),
    merge_tree(Layer?, Out).

% Prefer: pattern in head
merge_tree([X,Y|Rest], Out?) :-
    merge_layer([X?,Y?|Rest?], Layer),
    merge_tree(Layer?, Out).
\end{verbatim}

The second form is correct GLP style. The first form has \verb|Streams| appearing both in the head (as writer) and in the guard (as another occurrence), which can confuse SRSW analysis. By folding the structural test into the head pattern, the clause clearly shows that \verb|X|, \verb|Y|, and \verb|Rest| are bound by pattern matching and then read in the body.

This principle applies generally: if you find yourself writing \verb|X = Pattern| in a guard where \verb|X| comes from the head, restructure the clause to put the pattern directly in the head.
\end{remark}

Renaming  (Definition~\ref{definition:renaming}) is extended to respect variable pairing:
\begin{definition}[GLP Renaming]\label{definition:GLP-renaming}
 Two GLP terms $T, T'$ have a variable in common if for some writer $X\in V$, either $X$ or $X?$ occur in $T$ and either $X$ or $X?$ occur in $T'$. A \temph{GLP renaming} is a renaming substitution $\sigma: \mathcal{V} \mapsto \mathcal{V}$ such that for each $X\in V$: $X\sigma \in V$ and $X?\sigma = (X\sigma)?$.
\end{definition}

\begin{definition}[GLP Goal/Clause Reduction]\label{definition:GLP-goal-clause-reduction}
 Given GLP goal $A$ and clause $C$,  with $H \verb|:-| B$ being the result of the GLP renaming of $C$ apart from $A$,
 the \temph{GLP reduction} of $A$ with $C$ \temph{succeeds with result} $(B,\sigma)$,
\temph{suspends on $W$}, or \temph{fails}, respectively, depending on the result of the writer unification of $A$ and $H$.
\end{definition}

The GLP operational semantics is defined via the following transition system, which employs the notions defined above to extend LP (Definition~\ref{definition:lp-ts}). It abstracts-away goal suspension and failure; these are used in the implementation-ready specifications (Appendixes~\ref{appendix:irGLP} and~\ref{appendix:irmaGLP}) for explicit goal scheduling, suspension and activation.
\begin{definition}[GLP Transition System]\label{definition:GLP-ts}
Given a GLP program $M$, an \temph{asynchronous resolvent} over $M$ is a pair $(G,\sigma)$ where $G\in \calG_?(M)$ and $\sigma$ is a reader substitution.
%
A transition system $GLP = (\calC,c0,\calT)$ is a \temph{GLP transition system} over $M$ and initial goal $G_0 \in \mathcal{G}_?(M)$ satisfying SRSW if:
\begin{enumerate}
    \item $\calC$ is the set of all asynchronous resolvents over $M$
    \item $c0= (G_0,\emptyset)$
    \item $\calT$ is the set of all transitions $(G,\sigma)\rightarrow (G',\sigma')$ satisfying:
    \begin{enumerate}
        \item \textbf{Reduce:} there exists an atom $A \in G$ such that $C \in M$ is the first clause for which the GLP reduction of $A$ with $C$ succeeds with result $(B,\hat\sigma)$,  $G' = (G \setminus \{A\} \cup B)\hat\sigma$, and $\sigma' = \sigma \circ \hat\sigma?$
        \item \textbf{Communicate:} $\hat\sigma = \{X?:=T\} \in \sigma$, $G'= G\hat\sigma$, and $\sigma' = \sigma \setminus \hat\sigma$
\end{enumerate}
\end{enumerate}
\end{definition}
The monotonicity of GLP goal/clause reduction (Proposition~\ref{proposition:GLP-monotonicity}) allows a simple \emph{GLP fairness requirement}: A goal that can be reduced is eventually reduced.


\mypara{Guards and system predicates}
GLP also includes \emph{guards}—predicates that test runtime conditions (e.g., \verb|ground(X)| tests if \verb|X| contains no variables) without modifying state, appearing after clause heads separated by \verb=|=—and \emph{system predicates} that provide access to the GLP runtime state and operating system and hardware capabilities (variable state and name, arithmetic evaluation, timestamps). Guards enable conditional clause selection. The \verb|ground(X)| guard allows relaxing the single-reader constraint for \verb|X?| for the clause it occurs in, as having multiple occurrences of \verb|X?| instantiated to a ground term does not violate the fundamental single-writer requirement.
Their specification appears in Appendix~\ref{appendix:guards-system}.


\subsection{GLP Safety}

Here we prove that, like LP, GLP computations are deductions, but, unlike LP, a goal that can be reduced in a configuration can still be reduced in any subsequent configuration of the computation.

\mypara{GLP computations are deductions}  First we show that the extensions of GLP over LP do not take it outside of the logic programming realm.

\begin{definition}[Pure Logic Variant]\label{definition:pure-logic}
Given a GLP term or goal $T$, the \temph{pure logic variant} $L(T)$ of $T$ is defined by replacing every reader $X?$ in $T$ with its paired writer $X$. Given a GLP computation  $r$, its pure logic variant $L(r)$ is the result of replacing every configuration $(G,\sigma)$ in $r$ by $L(G)$,  removing duplications and labelling the remaining transitions by the mgu of their respective reduction.
\end{definition}
Note that duplications as above result from Communicate transitions.

\begin{restatable}[GLP Computations are Deductions]{proposition}{GLPComputationsareDeductions}\label{theorem:GLP-computation-deduction}
For any finite GLP run $r$, let
$L(r) = G0\xrightarrow{\sigma_1}G_1\xrightarrow{\sigma_2}\ldots G_n$,
with $\sigma = \sigma_1\cdot \ldots \cdot \sigma_n$, then  $(G_ :- G_n)\sigma$ is a logical consequence of $L(M)$.
\end{restatable}

Next, we establish essential safety properties for GLP that distinguish it from standard LP. The key is monotonicity—once a goal becomes reducible in GLP, it remains reducible.

\mypara{SRSW}
\begin{restatable}[SRSW Invariant]{proposition}{SRSWInvariant}\label{proposition:srsw-preservation}
If the initial goal $G_0$ in a $GLP$ run satisfies SRSW, then every goal in the run satisfies SRSW.
\end{restatable}

\mypara{Acyclicity}
The occurs check in readers prevents the formation of circular terms.

\begin{restatable}[Acyclicity]{proposition}{Acyclicity}\label{proposition:acyclicity}
If the initial goal $G_0$ in a $GLP$ run contains no circular terms, then no goal in the run contains a circular term.
\end{restatable}

\mypara{Monotonicity}
Unlike LP where variable instantiation can cause a previously reducible goal to fail, GLP exhibits monotonicity. In a run, if a goal $A$ can be reduced at some point, it remains reducible at all future points in that run, where
``future" implies that readers in $A$  (and only readers) have been further instantiated by other goal reductions.

\begin{restatable}[Reader-Instance]{lemma}{ReaderOnlyInstantiation}\label{lemma:reader-only}
In any $GLP$ run $G_0 \rightarrow G_1 \rightarrow \cdots$, if $G_i \rightarrow G_{i+1}$ via reduction with substitution $\sigma?$ does not reduce $A \in G_{i}$, then $A\tau \in G_{i+1}$ where $\tau$ instantiates only readers.
\end{restatable}

\begin{restatable}[Monotonicity]{proposition}{Monotonicity}\label{proposition:GLP-monotonicity}
In any $GLP$ run $G_0 \rightarrow G_1 \rightarrow \cdots$, if atom $A \in G_i$ can reduce with clause $C$, then for any $j > i$, either $A$ has been reduced by step $j$, or there exists $A' \in G_j$ where $A' = A\tau$ for some reader substitution $\tau$, and $A'$ can reduce with $C$.
\end{restatable}

\subsection{Deterministic Transition System for Concurrent GLP}\label{subsection:irGLP}

This section specifies a workstation (single-agent) implementation-ready transition system for GLP with deterministic execution.

The nondeterministic GLP transition system (Definition~\ref{definition:GLP-ts}) specifies \emph{what} computations are valid without prescribing \emph{how} to execute them. The implementation-ready transition system makes three deterministic choices:
\begin{enumerate}
    \item \textbf{Goal order}: Goals are processed front-to-back from an ordered queue. The first goal is selected for reduction.
    \item \textbf{Clause order}: Clauses are tried top-to-bottom. The ``first applicable clause'' is the textually first clause in $M$ for which reduction succeeds.
    \item \textbf{Unification order}: Compound term arguments are unified left-to-right, depth-first. Unification stops at the first suspension or failure encountered.
\end{enumerate}

The left-to-right unification order means: if argument $i$ causes suspension but argument $j > i$ would cause failure, the implementation suspends rather than fails. When the suspended reader is later instantiated and the goal retried, the failure at argument $j$ will then be detected. This is \emph{sound}---suspension is conservative, never incorrectly succeeding---but may delay failure detection.

\begin{definition}[Depth-First Writer Unification]\label{definition:df-unification}
The \temph{depth-first writer unification} of terms $T_1$ and $T_2$, denoted $\mathit{dfunify}(T_1, T_2)$, is defined recursively:
\begin{enumerate}
    \item If $T_1$ and $T_2$ are identical: \emph{succeeds} with $\emptyset$.
    \item If $T_1$ is a writer:
    \begin{itemize}
        \item If $T_2$ is a writer: \emph{fails}.
        \item Otherwise: \emph{succeeds} with $\{T_1 := T_2\}$.
    \end{itemize}
    \item If $T_2$ is a writer: \emph{succeeds} with $\{T_2 := T_1\}$.
    \item If $T_1$ is a reader: \emph{suspends} on $\{T_1\}$.
    \item If $T_2$ is a reader: \emph{suspends} on $\{T_2\}$.
    \item If $T_1 = f(S_1, \ldots, S_n)$ and $T_2 = g(R_1, \ldots, R_m)$:
    \begin{itemize}
        \item If $f \neq g$ or $n \neq m$: \emph{fails}.
        \item Otherwise, for $i = 1, \ldots, n$ in order:
        \begin{itemize}
            \item Compute $\mathit{dfunify}(S_i\sigma_{i-1}, R_i\sigma_{i-1})$ where $\sigma_0 = \emptyset$.
            \item If it fails: \emph{fails}.
            \item If it suspends on $W$: \emph{suspends} on $W$.
            \item If it succeeds with $\sigma'$: let $\sigma_i = \sigma_{i-1} \cup \sigma'$ and continue.
        \end{itemize}
        \item \emph{Succeeds} with $\sigma_n$.
    \end{itemize}
\end{enumerate}
\end{definition}

\begin{definition}[irGLP Configuration]
An \emph{irGLP configuration} over program $M$ is a triple $R = (Q, S, F)$ where:
\begin{itemize}
\item $Q \in \mathcal{A}^*$ is a sequence of active goals
\item $S \subseteq \mathcal{A} \times 2^{V?}$ contains suspended goals with their suspension sets
\item $F \subseteq \mathcal{A}$ contains failed goals
\end{itemize}
\end{definition}

The irGLP reduction extends GLP reduction by activating goals that were suspended on variables instantiated by the reduction, and explicitly failing goals that do not succeed or suspend.

\begin{definition}[irGLP Goal/Clause Reduction]
Given configuration $(Q, S, F)$ with $Q = A\cdot Q'$, clause $C \in M$ with head $H$ and body $B$ (renamed apart from $A$), the \emph{irGLP reduction} of $A$ with $C$:
\begin{itemize}
\item \textbf{succeeds with} $(B, \hat\sigma, R)$ if $\mathit{dfunify}(A, H)$ succeeds with $\hat\sigma$, and $R = \{G : (G, W) \in S \wedge X?\in W \wedge X?\hat\sigma? \neq X?\}$
\item \textbf{suspends with} $W$ if $\mathit{dfunify}(A, H)$ suspends on $W$
\item \textbf{fails} if $\mathit{dfunify}(A, H)$ fails
\end{itemize}
\end{definition}

\begin{definition}[Implementation-Ready GLP Transition System]
The transition system $\text{irGLP} = (\mathcal{C}, c_0, \mathcal{T})$ over $M$ and initial goal $G_0$ has configurations $\mathcal{C}$ being all irGLP configurations over $M$, with initial configuration $c_0 = (G_0, \emptyset, \emptyset)$, and transitions $\mathcal{T}$ being all transitions $(Q, S, F) \rightarrow (Q', S', F')$ where $Q = A \cdot Q_r$ and:
    \begin{enumerate}
    \item \textbf{Reduce:} If irGLP reduction of $A$ with first applicable clause $C \in M$ succeeds with $(B, \hat\sigma, R)$:
        \begin{itemize}
        \item \textbf{Activate:}  $S' = S \setminus \{(G, W) : G \in R\}$,  $F' = F$
        \item \textbf{Schedule:} $Q' = (Q_r \cdot B \cdot R)\hat\sigma\hat\sigma?$
        \end{itemize}
    \item \textbf{Suspend:} Else if $W = \bigcup_{C \in M} W_{C} \neq \emptyset$ then $Q' = Q_r$, $S' = S \cup \{(A, W)\}$, $F' = F$
    \item \textbf{Fail:} Else, $Q' = Q_r$, $S' = S$, $F' = F \cup \{A\}$.
    \end{enumerate}
\end{definition}

\begin{remark}[Immediate vs.\ Asynchronous Communication]
The GLP transition system (Definition~\ref{definition:GLP-ts}) models communication asynchronously in two steps:
\begin{enumerate}
\item \textbf{Reduce}: The writer substitution $\hat\sigma$ is applied to the goal. Its reader counterpart $\hat\sigma?$ is added to the pending substitution $\sigma$.
\item \textbf{Communicate}: Later, an assignment $\{X? := T\}$ is selected from $\sigma$ and applied to the goal.
\end{enumerate}

The irGLP transition system combines these into a single step. The Schedule operation applies both the writer substitution and its reader counterpart immediately:
\[
Q' = (Q_r \cdot B \cdot R)\hat\sigma\hat\sigma?
\]

This simplification is valid for single-agent execution because all variables are local---there is no network delay between writer and reader. The observable behavior is identical: the reader receives its value before any subsequent goal can observe it.

In multiagent GLP, where readers and writers may reside on different machines, the two-step model becomes essential. The pending substitution $\sigma$ represents messages in flight between agents.
\end{remark}

\begin{remark}[Scheduling Freedom]
The monotonicity property (Proposition~\ref{proposition:GLP-monotonicity}) ensures that a goal reducible in configuration $c$ remains reducible in any subsequent configuration. This provides significant scheduling freedom:
\begin{itemize}
\item \textbf{Any fair schedule works}: As long as every reducible goal eventually gets a turn, the computation makes progress.
\item \textbf{No complex failure handling}: Unlike systems where delays can cause failures, a message arriving late in GLP does not invalidate pending computations.
\item \textbf{Distributed execution}: In a distributed setting, network delays affect performance but not correctness.
\end{itemize}
The GLP fairness requirement is simply: a goal that can be reduced is eventually reduced.
\end{remark}

\section{Exercises}

\begin{enumerate}
\item Trace the full computation of \verb|merge([1], [a], Out)| showing all configurations.

\item What happens if we query \verb|merge(X, Y, [1,2,3])| with $X$ and $Y$ uninstantiated? Explain why.

\item Explain why monotonicity fails in standard LP. Give a concrete example where a reducible goal becomes unreducible.

\item Design a goal that never terminates but is fair (every subgoal gets reduced infinitely often).

\item Prove that if all goals in a GLP computation eventually become reducible, the computation is deadlock-free.
\end{enumerate}
