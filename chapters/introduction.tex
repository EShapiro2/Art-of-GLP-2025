% chapters/ch01_introduction.tex - Introduction

\chapter{Introduction}
\label{ch:introduction}

This book presents \GLP, a programming language designed to enable ordinary people to build and operate distributed platforms using only their personal devices. Before diving into the technical details, let us understand why such a language is needed and what makes it different from conventional programming languages.

\section{The Grassroots Vision}

Imagine social networks without corporate surveillance. Currencies without banks. Democratic institutions without centralized control. These are not utopian dreams---they are technically achievable through what we call \emph{grassroots platforms}.

\begin{quote}
Grassroots platforms are distributed applications run by cryptographically-identified people on their networked personal devices, where multiple disjoint platform instances emerge independently and coalesce when they interoperate.
\end{quote}

In a grassroots platform:
\begin{itemize}
\item \textbf{People run the platform}, not corporations. Each participant contributes their smartphone or computer.
\item \textbf{Identity is cryptographic}, not administrative. You prove who you are through digital signatures, not usernames and passwords managed by a company.
\item \textbf{Trust is personal}, not institutional. You communicate with authenticated friends, building a web of trust from the ground up.
\item \textbf{Instances grow organically}. Small groups form independently and merge when they connect.
\end{itemize}

The foundation of all grassroots platforms is the \emph{grassroots social graph}---a network where nodes represent people, edges represent authenticated friendships, and connected components arise spontaneously through befriending. Upon this foundation, grassroots social networks, cryptocurrencies, and democratic federations can be built.

\section{The Programming Challenge}

Why do we need a new programming language? Can't we build grassroots platforms using existing languages?

The challenge is that grassroots platforms operate in an environment of \emph{faulty and malicious participants}. Without proper language support:
\begin{itemize}
\item Correct participants cannot reliably identify each other
\item Secure communication channels cannot be established
\item Code integrity cannot be verified
\end{itemize}

Existing programming languages lack the necessary combination of:
\begin{enumerate}
\item Distributed execution with cryptographic security
\item Multiagent operational semantics with proven properties
\item Abstractions suitable for grassroots programming
\item Safety and liveness guarantees
\end{enumerate}

\GLP aims to close this gap.

\section{Logic Programming: A Natural Foundation}

\GLP builds on the tradition of logic programming, which views computation as logical deduction. This is not merely an aesthetic choice---it provides:

\begin{itemize}
\item \textbf{Declarative semantics}: Programs describe \emph{what} to compute, not just \emph{how}
\item \textbf{Formal foundations}: Properties can be stated and proven mathematically
\item \textbf{Natural concurrency}: Multiple goals can be pursued simultaneously
\end{itemize}

The name ``\GLP'' stands for \textbf{G}rassroots \textbf{L}ogic \textbf{P}rogramming. It extends classical logic programs with mechanisms for secure, concurrent, multiagent computation.

\section{Concurrent Logic Programming}

Standard logic programming, exemplified by Prolog, is sequential. Goals are pursued one at a time, with backtracking when choices fail. This model is unsuitable for distributed systems where multiple agents must operate concurrently.

\emph{Concurrent} logic programming, pioneered in the 1980s with languages like Concurrent Prolog, PARLOG, and GHC, introduced parallelism through \emph{committed choice}---once a clause is selected, there is no backtracking. Communication occurs through shared logical variables.

However, concurrent logic programming faced a fundamental problem: \emph{distributed unification}. When multiple processes can instantiate the same variable, ensuring consistency requires complex distributed protocols.

\section{The Single-Reader/Single-Writer Insight}

\GLP's key innovation is the \emph{Single-Reader/Single-Writer (SRSW)} discipline:
\begin{itemize}
\item Each logical variable has exactly one writer (who can assign it a value)
\item Each logical variable has exactly one reader (who can observe the value)
\item The reader and writer form a pair, establishing a communication channel
\end{itemize}

This discipline eliminates distributed unification entirely. Assignment becomes simple point-to-point communication. Yet expressive power is retained---complex communication patterns emerge from sharing readers and writers in messages.

\section{A First GLP Program}

Let us see \GLP in action with a classic example: merging two streams.

\Program{Fair Stream Merger}
\begin{verbatim}
merge([X|Xs],Ys,[X?|Zs?]) :- merge(Ys?,Xs?,Zs).
merge(Xs,[Y|Ys],[Y?|Zs?]) :- merge(Xs?,Ys?,Zs).
merge([],[],[]).
\end{verbatim}

This program merges two input streams into one output stream. Let us understand each piece:
\begin{itemize}
\item \verb|[X|Xs]| and \verb|[Y|Ys]| are input streams (lists that may grow)
\item \verb|[X?|Zs?]| is the output stream being constructed
\item \verb|X?| and \verb|Zs?| are \emph{readers}---they provide read-only access to values
\item \verb|X| and \verb|Zs| are \emph{writers}---they can be assigned values
\end{itemize}

The first clause says: ``If the first stream has element \verb|X|, output it and recursively merge, swapping the streams for fairness.'' The swap ensures both streams are treated equally.

Notice that each variable occurs exactly once as a reader and once as a writer---this is the SRSW discipline in action.

\begin{formal}{The merge Program}
The \texttt{merge} program demonstrates fundamental \GLP properties:

\begin{enumerate}
\item \textbf{SRSW Compliance}: Each variable $X$, $Xs$, $Ys$, $Zs$ occurs exactly once as a writer (in the head or body) and its paired reader ($X?$, $Xs?$, $Ys?$, $Zs?$) occurs exactly once elsewhere.

\item \textbf{Fairness}: The clause ordering combined with committed choice ensures that when both streams have elements, they are alternately selected due to the argument swap in the recursive call.

\item \textbf{Stream Processing}: The program handles infinite streams correctly---it never requires the entire input to be available before producing output.
\end{enumerate}
\end{formal}

\section{Security Through Cryptography}

\GLP integrates cryptographic security at the language level:
\begin{itemize}
\item \textbf{Identity}: Participants are identified by public/private keypairs
\item \textbf{Encryption}: Messages between agents are encrypted
\item \textbf{Signatures}: Messages are signed for authenticity
\item \textbf{Attestation}: Code integrity is verified through attestations
\end{itemize}

These mechanisms enable both cold calls (for bootstrap and connecting disconnected components) and friend-mediated introductions (the preferred trust propagation method).

\section{Book Overview}

This book presents \GLP progressively:

\mypara{Part I: Foundations} We begin with logic programs, then extend them to concurrent \GLP, establishing the core concepts of reader/writer pairs, SRSW, and committed choice. We conclude with programming using constants to illustrate fundamental dataflow.

\mypara{Part II: Concurrent Programming} We develop stream-based concurrent programming, recursive techniques adapted to SRSW, and metaprogramming---programs that interpret and transform other programs.

\mypara{Part III: Simulating Multiagent Systems} We present the culmination: protocols for the grassroots social graph, social networking, interlaced streams, cryptocurrencies, and constitutional consensus---all executing on a single GLP runtime simulating distributed agents.

Each chapter builds on previous material, with formal content in shaded boxes for readers who want rigorous foundations.

Let us begin our journey into the art of grassroots logic programming.
