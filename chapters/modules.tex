% chapters/modules.tex - Modules

\chapter{Modules}
\label{ch:modules}

A \emph{module} organizes related procedures into a unit with a name. Modules enable separate compilation, namespace management, and cross-module procedure calls.

\section{Module Basics}
\label{sec:module-basics}

\subsection{Module Identity}

By default, a module's name is its filename without the \verb|.glp| extension. A file \verb|math.glp| defines module \verb|math|. All procedures in the file belong to that module.

\subsection{Exports}

By default, all procedures in a module are \emph{exported}---callable from other modules. This ensures backward compatibility: existing single-file programs work unchanged.

\subsection{Remote Procedure Call}

The RPC syntax invokes a procedure in another module:

\begin{verbatim}
Module # Goal
\end{verbatim}

The goal \verb|Goal| executes using clauses from \verb|Module|. Variables in \verb|Goal| are shared between caller and callee---bindings made by the callee are visible to the caller.

\section{Example: Math Module}
\label{sec:math-module}

A module providing factorial and greatest common divisor:

\begin{verbatim}
%% math.glp

factorial(0, 1).
factorial(N, F?) :-
    N? > 0 |
    N1 := N? - 1,
    factorial(N1?, F1),
    F := N? * F1?.

gcd(A, 0, A?).
gcd(A, B, G?) :-
    B? > 0 |
    R := A? mod B?,
    gcd(B?, R?, G).
\end{verbatim}

A caller in another module:

\begin{verbatim}
%% main.glp

compute(Result?) :-
    math # factorial(5, F),
    math # gcd(48, 18, G),
    Result = result(F?, G?).
\end{verbatim}

The query \verb|compute(R)| yields \verb|R = result(120, 6)|.

\section{Program Encoding for Meta-Interpretation}
\label{sec:reduce-encoding}

For meta-interpretation, a module encodes its clauses as \verb|reduce/2| facts:

\begin{verbatim}
%% math.glp with reduce encoding

factorial(0, 1).
factorial(N, F?) :-
    N? > 0 |
    N1 := N? - 1,
    factorial(N1?, F1),
    F := N? * F1?.

%% Clause encoding for meta-interpreter
reduce(factorial(0, 1), true).
reduce(factorial(N, F?), (N1 := N? - 1, factorial(N1?, F1), F := N? * F1?)) :-
    N? > 0 | true.
\end{verbatim}

A meta-interpreter can access another module's clauses via RPC:

\begin{verbatim}
Module # reduce(Goal, Body)
\end{verbatim}

This retrieves the clause encoding for \verb|Goal| from \verb|Module|.

\section{Module Semantics}
\label{sec:module-semantics}

\begin{description}
\item[Isolation] Each module has its own namespace. Procedures with the same name in different modules are distinct.

\item[Shared Variables] RPC does not copy arguments. Variables in the goal are shared between caller and callee. When the callee binds a variable, the caller sees the binding.

\item[Concurrency] RPC goals execute concurrently with other goals. The caller does not block waiting for the callee to complete---it suspends only if it reads an unbound variable.

\item[No Implicit Import] A module must explicitly name the target module in each RPC. There is no implicit ``import everything'' mechanism at the specification level.
\end{description}

\section{Exercises}
\label{sec:modules-exercises}

\begin{enumerate}
\item Write a \verb|list.glp| module providing \verb|append/3|, \verb|reverse/2|, and \verb|length/2|. Call these from a main module.

\item Extend the math module with \verb|power(Base, Exp, Result)| computing $\mathit{Base}^{\mathit{Exp}}$.

\item Write a module that provides both the procedure and its \verb|reduce/2| encoding. Test that a meta-interpreter can execute the encoded program.

\item Two modules \verb|a.glp| and \verb|b.glp| each call procedures in the other. Explain why this works without special handling for circular dependencies.
\end{enumerate}
