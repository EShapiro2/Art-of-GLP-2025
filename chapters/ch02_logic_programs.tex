% chapters/ch02_logic_programs.tex - Logic Programs

\chapter{Logic Programs}
\label{ch:lp}

Before we can understand \GLP, we must understand its foundation: logic programs. This chapter introduces logic programming from the ground up, establishing concepts and notation used throughout the book.

\section{What is a Logic Program?}

A logic program is a collection of \emph{clauses} that define relationships between objects. Unlike imperative programs that describe step-by-step procedures, logic programs describe \emph{what is true}---the system figures out \emph{how} to compute.

Consider this simple example:

\begin{verbatim}
parent(tom, mary).
parent(tom, james).
parent(mary, ann).

grandparent(X, Z) :- parent(X, Y), parent(Y, Z).
\end{verbatim}

The first three lines are \emph{facts}: Tom is a parent of Mary, Tom is a parent of James, and Mary is a parent of Ann.

The fourth line is a \emph{rule}: X is a grandparent of Z if X is a parent of some Y, and Y is a parent of Z.

Given the query \verb|grandparent(tom, ann)|, the system can deduce that it is true: Tom is Mary's parent, and Mary is Ann's parent, so Tom is Ann's grandparent.

\section{Terms, Atoms, and Clauses}

Let us define the building blocks of logic programs.

\mypara{Terms} A \emph{term} is a data object. Terms are built from:
\begin{itemize}
\item \textbf{Constants}: Lowercase identifiers like \verb|tom|, \verb|mary|, numbers like \verb|42|, \verb|3.14|
\item \textbf{Variables}: Uppercase identifiers like \verb|X|, \verb|Person|, \verb|Result|
\item \textbf{Compound terms}: A functor applied to arguments, like \verb|person(tom, 42)| or \verb|[1,2,3]|
\end{itemize}

Lists are a special case of compound terms:
\begin{itemize}
\item \verb|[]| is the empty list
\item \verb|[X|Xs]| is a list with head \verb|X| and tail \verb|Xs|
\item \verb|[1,2,3]| is sugar for \verb|[1|[2|[3|[]]]]|
\end{itemize}

\mypara{Atoms} An \emph{atom} is a predicate applied to terms. For example:
\begin{itemize}
\item \verb|parent(tom, mary)| --- the atom stating Tom is Mary's parent
\item \verb|append([1,2], [3,4], Result)| --- the atom relating two lists to their concatenation
\end{itemize}

\mypara{Clauses} A \emph{clause} has the form:
\begin{verbatim}
Head :- Body.
\end{verbatim}
where Head is an atom and Body is a conjunction of atoms. A clause with an empty body is written simply as \verb|Head.| and called a \emph{fact}.

\begin{formal}{Logic Programs Syntax}
We denote by $V$ the set of all variables and $\calT$ the set of all terms. The formal syntax is defined as follows:

\begin{fdef}[Syntax]
\begin{align*}
\text{Variable} \quad X &::= \text{uppercase identifier} \\
\text{Constant} \quad c &::= \text{lowercase identifier} \mid \text{number} \\
\text{Term} \quad T &::= X \mid c \mid f(T_1, \ldots, T_n) \\
\text{Atom} \quad A &::= p(T_1, \ldots, T_n) \\
\text{Goal} \quad G &::= A_1, \ldots, A_n \\
\text{Clause} \quad C &::= A \text{ :- } G \mid A \\
\text{Program} \quad M &::= C_1, \ldots, C_m
\end{align*}
\end{fdef}

We use $\calA$ for the set of all atoms, $\calG$ for all goals, and for a program $M$, $\calA(M)$ and $\calG(M)$ for atoms and goals restricted to $M$'s vocabulary.
\end{formal}

\section{The Append Program}

The quintessential logic program defines list concatenation:

\Program{Append}
\begin{verbatim}
append([X|Xs], Ys, [X|Zs]) :- append(Xs, Ys, Zs).
append([], Ys, Ys).
\end{verbatim}

This program defines when a list is the concatenation of two others:
\begin{itemize}
\item The first clause: A list starting with \verb|X| concatenated with \verb|Ys| produces a list starting with \verb|X|, if the tail \verb|Xs| concatenated with \verb|Ys| produces \verb|Zs|.
\item The second clause: The empty list concatenated with any list \verb|Ys| produces \verb|Ys|.
\end{itemize}

The beauty is that this single definition supports multiple \emph{modes} of use:
\begin{itemize}
\item \verb|append([1,2], [3,4], Z)| computes \verb|Z = [1,2,3,4]|
\item \verb|append([1,2], Y, [1,2,3,4])| computes \verb|Y = [3,4]|
\item \verb|append(X, Y, [1,2,3])| enumerates all ways to split the list
\end{itemize}

By convention, we use plural variable names like \verb|Xs| to denote a list of \verb|X|'s.

\section{Declarative Reading}

A clause $A$ \verb|:-| $B$ can be read as a logical implication: $B$ implies $A$. More precisely, it is a universally-quantified formula:
\[
\forall \bar{X}.\, (B \Rightarrow A)
\]
where $\bar{X}$ are all variables in the clause.

A program is the conjunction of its clauses. The append program asserts:
\begin{enumerate}
\item For all X, Xs, Ys, Zs: if append(Xs, Ys, Zs) then append([X|Xs], Ys, [X|Zs])
\item For all Ys: append([], Ys, Ys)
\end{enumerate}

A query asks whether a goal is a logical consequence of the program. The system's job is to find a \emph{proof}---or equivalently, a \emph{computation}.

\section{Substitution and Unification}

Computation in logic programs revolves around \emph{substitution} and \emph{unification}.

\mypara{Substitution} A substitution maps variables to terms. We write $\{X := T\}$ for the substitution that maps $X$ to $T$. Applying substitution $\sigma$ to term $T$ produces $T\sigma$---the result of replacing each variable by its mapped term.

For example:
\begin{itemize}
\item \verb|[X|Xs]{X := 1, Xs := [2,3]}| = \verb|[1,2,3]|
\item \verb|parent(X, Y){X := tom}| = \verb|parent(tom, Y)|
\end{itemize}

\mypara{Unification} Two terms \emph{unify} if there exists a substitution making them identical. The \emph{most general unifier (mgu)} is the simplest such substitution---it doesn't instantiate variables more than necessary.

Examples:
\begin{itemize}
\item \verb|f(X, b)| and \verb|f(a, Y)| unify with mgu $\{X := a, Y := b\}$
\item \verb|f(X, X)| and \verb|f(a, b)| do not unify (X cannot be both a and b)
\item \verb|f(X, Y)| and \verb|f(Y, X)| unify with mgu $\{X := Y\}$ (or equivalently $\{Y := X\}$)
\end{itemize}

\begin{formal}{Substitution and Unification}
\begin{fdef}[Substitution, Instance, Unifier, Most-General Unifier]
\label{def:substitution}
A \emph{substitution} $\sigma$ is an idempotent function $\sigma: V \to \calT$, meaning $T\sigma\sigma = T\sigma$ for all terms $T$.

\begin{itemize}
\item $V_\sigma := \{ X \in V \mid X\sigma \ne X\}$ is the \emph{domain} of $\sigma$
\item $T\sigma$ is the term obtained by replacing each $X \in T$ by $X\sigma$
\item $T' = T\sigma$ means $T'$ is an \emph{instance} of $T$
\item $\sigma$ is a \emph{unifier} of $T, T'$ if $T\sigma = T'\sigma$
\item $\sigma$ is a \emph{most-general unifier (mgu)} if it is as general as any other unifier
\end{itemize}
\end{fdef}

We view a substitution equivalently as a set of assignments $\{X_1 := T_1, \ldots, X_n := T_n\}$.
\end{formal}

\section{Goal Reduction}

Computation proceeds by \emph{goal reduction}. Given a goal (a conjunction of atoms), we:
\begin{enumerate}
\item Select an atom from the goal
\item Find a clause whose head unifies with the atom
\item Replace the atom with the clause body, applying the unifier
\end{enumerate}

This is repeated until the goal becomes empty (success) or no clause applies (failure).

\begin{example}[Computing with Append]
Query: \verb|append([1,2], [3], Z)|

\begin{enumerate}
\item Goal: \verb|append([1,2], [3], Z)|
\item Unify with clause 1: mgu = $\{X := 1, Xs := [2], Ys := [3], Zs := Z'\}$
\item New goal: \verb|append([2], [3], Z')| with $Z = [1|Z']$
\item Unify with clause 1: mgu = $\{X := 2, Xs := [], Ys := [3], Zs := Z''\}$
\item New goal: \verb|append([], [3], Z'')| with $Z' = [2|Z'']$
\item Unify with clause 2: mgu = $\{Ys := [3], Z'' := [3]\}$
\item Goal is empty: success with $Z = [1,2,3]$
\end{enumerate}
\end{example}

\begin{formal}{Logic Programs Transition System}
\begin{fdef}[Renaming]
A \emph{renaming} is a substitution $\sigma: V \to V$ mapping variables to variables. A renaming $\sigma$ \emph{renames $T'$ apart from $T$} if $T'\sigma$ and $T$ share no variables.
\end{fdef}

\begin{fdef}[LP Goal/Clause Reduction]
Given LP goal $A$ and clause $C$, with $H$ \texttt{:-} $B$ being $C$ renamed apart from $A$:
\begin{itemize}
\item The reduction \emph{succeeds with result} $(B, \sigma)$ if $A$ and $H$ have mgu $\sigma$
\item Otherwise it \emph{fails}
\end{itemize}
\end{fdef}

\begin{fdef}[Logic Programs Transition System]
\label{def:lp-ts}
A transition system $LP = (C, c0, T)$ for program $M$ and initial goal $G_0$ where:
\begin{itemize}
\item $C = \calG(M)$ is the set of all goals
\item $c0 = G_0$ is the initial goal
\item $T$ contains all transitions $G \to G'$ where: for some $A \in G$ and $C \in M$, the reduction of $A$ with $C$ succeeds with $(B, \sigma)$, and $G' = (G \setminus \{A\} \cup B)\sigma$
\end{itemize}
\end{fdef}

A configuration is also called a \emph{resolvent}, a tribute to resolution theorem proving.
\end{formal}

\section{Nondeterminism}

Logic programs have two forms of nondeterminism:
\begin{itemize}
\item \textbf{And-nondeterminism}: Which atom to select from the goal
\item \textbf{Or-nondeterminism}: Which clause to use for reduction
\end{itemize}

Prolog resolves or-nondeterminism through depth-first search with backtracking. \GLP takes a different approach: \emph{committed choice}---the first applicable clause is chosen, with no backtracking.

\section{Computations as Deductions}

The fundamental property of logic programs is that computations correspond to logical deductions.

\begin{formal}{LP Computation is Deduction}
\begin{fdef}[Proper Run and Outcome]
A run $\rho: G_0 \xrightarrow{\sigma_1} G_1 \xrightarrow{\sigma_2} \cdots \xrightarrow{\sigma_n} G_n$ is \emph{proper} if fresh variables introduced at step $i$ do not appear in earlier goals.

The \emph{outcome} of a proper run is $(G_0 \text{ :- } G_n)\sigma$ where $\sigma = \sigma_1 \circ \cdots \circ \sigma_n$.
\end{fdef}

\begin{fprop}[LP Computation is Deduction]
\label{prop:lp-deduction}
The outcome $(G_0 \text{ :- } G_n)\sigma$ of a proper run is a logical consequence of $M$.
\end{fprop}

This means: if a computation produces a result, that result is logically entailed by the program.
\end{formal}

\section{From LP to GLP}

Logic programs provide a clean foundation, but they lack:
\begin{itemize}
\item \textbf{Concurrency}: Multiple goals proceeding in parallel
\item \textbf{Communication}: Data flowing between concurrent processes
\item \textbf{Security}: Protection in distributed settings
\end{itemize}

The next chapter extends logic programs to \GLP, addressing these limitations while preserving the fundamental property that computations are deductions.

\section{Exercises}

\begin{enumerate}
\item[$\star$] Write a logic program for \verb|member(X, List)| that succeeds if \verb|X| is an element of \verb|List|.

\item[$\star$] Write a logic program for \verb|reverse(List, Reversed)| that reverses a list.

\item[$\star\star$] Trace the execution of \verb|append(X, Y, [a,b,c])| showing all solutions.

\item[$\star\star$] Write a logic program for \verb|permutation(List, Perm)| that generates all permutations.

\item[$\star\star\star$] Prove that for any terminating computation with \verb|append|, the third argument equals the concatenation of the first two.
\end{enumerate}
