% chapters/glp_core.tex - GLP Core

\chapter{GLP Core}
\label{ch:glp-core}

\section{GLP}\label{section:GLP}

We present GLP as an extension and simplification of Logic Programs: The syntax is extended with reader variables \verb|X?|, where \verb|X| and \verb|X?| form a reader/writer pair, and with the Single-Reader/Single-Writer syntactic restriction on clauses. Term matching replaces unification. For example, here is the quintessential concurrent logic program for merging two streams (incrementally constructed, potentially unbounded lists), written in GLP. Its first two arguments are the input streams to be merged, the third is the merged output stream:

\Program{GLP Fair Stream Merger}\label{program:merge}
\begin{small}
\begin{verbatim}
merge([X|Xs],Ys,[X?|Zs?]) :- merge(Ys?,Xs?,Zs). % output from first stream
merge(Xs,[Y|Ys],[Y?|Zs?]) :- merge(Xs?,Ys?,Zs). % output from second stream
merge([],[],[]).                                % terminate on empty streams
\end{verbatim}
\end{small}
Note that in each clause, each reader or writer occurs exactly once.

The operational semantics of GLP extends and simplifies that of LP as follows:
\begin{enumerate}
\item \textbf{Term matching instead of unification}: In LP, unification computes a most-general unifier that may bind any variable on either side. In GLP, term matching is a simpler operation: it assigns values only to writers, suspends when a reader requires a value not yet available, and fails when terms are structurally incompatible or when two variables of the same kind meet. The occurs check is not performed, as it is infeasible in a multiagent setting. Circular terms may form through cross-goal communication; implementations must handle them gracefully.

\item \textbf{Synchronization}: Term matching may only assign writers, so in addition to succeed/fail, it may suspend if it requires assigning readers.

\item \textbf{Communication}: When term matching assigns a writer \verb|X| to a term \verb|T|, the message \verb|X? := T| encoding its paired reader assignment is created and added to the configuration. Its application happens asynchronously, realizing a message \verb|T| from the single occurrence of \verb|X| to the single occurrence of \verb|X?|.

\item \textbf{Deterministic clause selection}: The first applicable clause is chosen, not nondeterministically as in LP. This provides for the fairness of \verb|merge| presented above: As long as the two input streams are available the output dovetails the two inputs, due to switching their order in the recursive call of the first clause; as long as only one stream is available, its elements are copied to the output; and when both streams are unavailable the goal suspends.
\end{enumerate}

The remainder of this section presents GLP syntax, nondeterministic operational semantics, and safety properties. A deterministic `workstation implementation-ready' transition-system specification for GLP is presented in Appendix~\ref{appendix:irGLP}.

\subsection{GLP Syntax}

\mypara{Reader/Writer pairs}
GLP extends Logic Programs with paired reader/writer variables, where a \emph{writer} \verb|X| is a single-assignment variable (promise) and its \emph{paired reader} \verb|X?| provides read-only access to the (future) value of \verb|X|. We denote by $V$ the set of all writers, $V?$ the set of all readers and, $\mathcal{V} = V \cup V?$ the set of all variables, where for each writer $X \in V$ there exists a paired reader $X? \in V?$.
We view $?$ as an identity suffix operator on non-writers, namely $(X?)?=X?$ for $X?\in V?$ and $T?=T$ for $T\notin \calV$.
We use $\calG_?$ to denote the set of all goals over $\calV$, and for a GLP program $M$, $\calG_?(M)$ denotes the subset restricted to the vocabulary of $M$.

\mypara{Single-Occurrence (SO) Invariant}
The fundamental requirement in GLP is that any variable may occur at most once in any resolvent. This \emph{single-occurrence (SO) invariant} ensures there can be no conflict when assigning a writer, and no duplication when reading from a reader.

\mypara{SRSW Syntactic Restriction on Clauses}
A clause satisfies the \emph{single-reader/single-writer (SRSW) syntactic restriction} if every writer occurs exactly once and every reader occurs exactly once in the clause.

The SO invariant is maintained by the SRSW syntactic restriction: given a resolvent satisfying SO, reducing a goal with a clause satisfying SRSW produces a new resolvent satisfying SO.

This restriction excludes programs like the equality definition \verb|X=X| as it has two occurrences of the writer \verb|X|. At the same time it eliminates the need for distributed atomic unification~\cite{kleinman1990distributed}—replacing it with efficient point-to-point communication of a single assignment from the single occurrence of a writer to the single occurrence of its paired reader.

\subsection{GLP Operational Semantics}

\begin{definition}[Writers Assignment, Readers Counterpart]\label{definition:writers-assignment}
A \temph{writers assignment} $\sigma$ is a set of assignments $\{$\verb|X1|}$ := T_1, \ldots, $\verb|Xk|$ := T_k\}$ where each \verb|Xi| $\in V$ is a writer.

A \temph{readers assignment} $\sigma$ is a set of assignments where each variable in the domain is a reader.

If $\sigma$ is a writers assignment then its \temph{readers counterpart} is the readers assignment $\sigma?$ defined by \verb|X?|$\sigma? = $\verb|X|$\sigma$ for every \verb|X| $\in \mathrm{dom}(\sigma)$.
\end{definition}

\begin{definition}[Term Matching]\label{definition:term-matching}
Given two terms \verb|T1| and \verb|T2| that jointly satisfy the SO assumption (every variable occurs at most once in \verb|T1| and \verb|T2| combined), \temph{term matching} of \verb|T1| with \verb|T2| produces one of three outcomes: \temph{succeed} with a writers assignment, \temph{suspend}, or \temph{fail}. The outcome is determined by the following table, where \verb|X1|, \verb|X2| denote writers, \verb|X1?|, \verb|X2?| denote readers, and $f/n$, $f'/n'$ denote terms with functor $f$, $f'$ and arity $n$, $n'$:

\begin{center}
\begin{tabular}{l|lll}
\verb|T1| $\backslash$ \verb|T2| & Writer \verb|X2| & Reader \verb|X2?| & Term $f'/n'$ \\
\hline
Writer \verb|X1| & fail & \verb|X1| $:=$ \verb|X2?| & \verb|X1| $:=$ \verb|T2| \\
Reader \verb|X1?| & \verb|X2| $:=$ \verb|X1?| & fail & suspend \\
Term $f/n$ & \verb|X2| $:=$ \verb|T1| & suspend & see below \\
\end{tabular}
\end{center}

For matching term $f/n$ with term $f'/n'$: if $f \ne f'$ or $n \ne n'$, the match fails. Otherwise, recursively match all $n$ pairs of corresponding arguments.

Outcomes combine as follows: if any match fails, the overall match fails; otherwise, if any match suspends, the overall match suspends; otherwise, the overall match succeeds with the union of all writers assignments.
\end{definition}

\begin{remark}
Writer-to-writer matching (\verb|X1| vs \verb|X2|) fails because, by the SO invariant, no other occurrences of \verb|X1| or \verb|X2| exist to assign them values, leaving their paired readers \verb|X1?| and \verb|X2?| \emph{abandoned}.

Reader-to-reader matching (\verb|X1?| vs \verb|X2?|) fails because neither can be assigned, and they cannot be equated without violating SO.
\end{remark}

Renaming (Definition~\ref{definition:renaming}) is extended to respect variable pairing:
\begin{definition}[GLP Renaming]\label{definition:GLP-renaming}
Two GLP terms \verb|T|, \verb|T'| have a variable in common if for some writer \verb|X| $\in V$, either \verb|X| or \verb|X?| occur in \verb|T| and either \verb|X| or \verb|X?| occur in \verb|T'|. A \temph{GLP renaming} is a renaming substitution $\rho: \mathcal{V} \mapsto \mathcal{V}$ such that for each \verb|X| $\in V$: \verb|X|$\rho \in V$ and \verb|X?|$\rho = ($\verb|X|$\rho)?$.
\end{definition}

\begin{definition}[GLP Goal/Clause Reduction]\label{definition:GLP-goal-clause-reduction}
Given GLP unit goal \verb|A| and clause \verb|C|, with \verb|H| \verb|:-| \verb|B| being the result of the GLP renaming of \verb|C| apart from \verb|A|, the \temph{GLP reduction} of \verb|A| with \verb|C| fails or suspends if the term matching of \verb|A| and \verb|H| fails or suspends, respectively, and succeeds with result $(B\sigma, \sigma?)$ if the term matching succeeds with writers assignment $\sigma$.
\end{definition}



The GLP operational semantics is defined via the following transition system, which employs the notions defined above to extend LP (Definition~\ref{definition:lp-ts}). It abstracts-away goal suspension and failure; these are used in the implementation-ready specifications (Appendixes~\ref{appendix:irGLP} and~\ref{appendix:irmaGLP}) for explicit goal scheduling, suspension and activation.

\begin{definition}[GLP Transition System]\label{definition:GLP-ts}
Given a GLP program $M$, an \temph{asynchronous resolvent} over $M$ is a pair $(G,\sigma)$ where $G\in \calG_?(M)$ and $\sigma$ is a readers assignment.

A transition system $GLP = (\calC,c0,\calT)$ is a \temph{GLP transition system} over $M$ and initial goal $G_0 \in \mathcal{G}_?(M)$ satisfying SO if:
\begin{enumerate}
    \item $\calC$ is the set of all asynchronous resolvents over $M$
    \item $c0= (G_0,\emptyset)$
    \item $\calT$ is the set of all transitions $(G,\sigma)\rightarrow (G',\sigma')$ satisfying:
    \begin{enumerate}
     \item \textbf{Reduce:} there exists a unit goal $A \in G$ such that $C \in M$ is the first clause for which the GLP reduction of $A$ with $C$ succeeds with result $(B, \hat\sigma)$, $G' = (G \setminus \{A\} \cup B)\hat\sigma$, and $\sigma' = \sigma \circ \hat\sigma$
        \item \textbf{Communicate:} $\hat\sigma = \{$\verb|X?|$:=T\} \in \sigma$, $G'= G\hat\sigma$, and $\sigma' = \sigma \setminus \hat\sigma$
    \end{enumerate}
\end{enumerate}
\end{definition}

The monotonicity of GLP goal/clause reduction (Proposition~\ref{proposition:GLP-monotonicity}) allows a simple \emph{GLP fairness requirement}: A goal that can be reduced is eventually reduced.


\subsubsection{Worked Examples}

\mypara{Example 1: Success}
Goal $g = p(X, a)$, Head $h = p(b, Y)$ (after renaming).

Term matching: \verb|X| matches \verb|b|, \verb|a| matches \verb|Y|. Both are writer-to-constant.
Writers assignment: $\{$\verb|X| $\mapsto$ \verb|b|$,$ \verb|Y| $\mapsto$ \verb|a|$\}$. Succeeds.

\mypara{Example 2: Suspension}
Goal $g = p(X?, a)$, Head $h = p(b, Y)$.

First argument: \verb|X?| (goal reader) against \verb|b| (constant). Readers cannot be assigned, so term matching suspends, waiting for the paired writer \verb|X| to be assigned.

\mypara{Example 3: Failure}
Goal $g = p(a, b)$, Head $h = p(a, c)$.

First argument: \verb|a| $=$ \verb|a|, succeeds. Second argument: \verb|b| $\ne$ \verb|c|, term matching fails.

\mypara{Example 4: Writer-to-Writer Failure}
Goal $g = p(X)$, Head $h = p(Y)$.

Both \verb|X| and \verb|Y| are writers. Writer-to-writer matching fails (not suspends).

\mypara{Guards and system predicates}
GLP also includes \emph{guards}—predicates that test runtime conditions (e.g., \verb|ground(X)| tests if \verb|X| contains no variables) without modifying state, appearing after clause heads separated by \verb=|=—and \emph{system predicates} that provide access to the GLP runtime state and operating system and hardware capabilities (variable state and name, arithmetic evaluation, timestamps). Guards enable conditional clause selection. The \verb|ground(X)| guard allows relaxing the single-reader constraint for \verb|X?| for the clause it occurs in, as having multiple occurrences of \verb|X?| instantiated to a ground term does not violate the fundamental single-writer requirement.
Their specification appears in Appendix~\ref{appendix:guards-system}.

\subsection{GLP Safety}

Here we prove that, like LP, GLP computations are deductions, but, unlike LP, a goal that can be reduced in a configuration can still be reduced in any subsequent configuration of the computation.

\mypara{GLP computations are deductions}  First we show that the extensions of GLP over LP do not take it outside of the logic programming realm.

\begin{definition}[Pure Logic Variant]\label{definition:pure-logic}
Given a GLP term or goal $T$, the \temph{pure logic variant} $L(T)$ of $T$ is defined by replacing every reader \verb|X?| in $T$ with its paired writer \verb|X|. Given a GLP computation $r$, its pure logic variant $L(r)$ is the result of replacing every configuration $(G,\sigma)$ in $r$ by $L(G)$, removing duplications and labelling the remaining transitions by the mgu of their respective reduction.
\end{definition}
Note that duplications as above result from Communicate transitions.

\begin{restatable}[GLP Computations are Deductions]{proposition}{GLPComputationsareDeductions}\label{theorem:GLP-computation-deduction}
For any finite GLP run $r$, let 
$L(r) = G_0\xrightarrow{\sigma_1}G_1\xrightarrow{\sigma_2}\ldots G_n$, 
with $\sigma = \sigma_1\cdot \ldots \cdot \sigma_n$, then $(G_0 \verb|:-| G_n)\sigma$ is a logical consequence of $L(M)$.
\end{restatable}

Next, we establish essential safety properties for GLP that distinguish it from standard LP. The key is monotonicity—once a goal becomes reducible in GLP, it remains reducible.

\mypara{SO Invariant}
\begin{restatable}[SO Invariant]{proposition}{SOInvariant}\label{proposition:so-preservation}
If the initial goal $G_0$ in a $GLP$ run satisfies SO, then every goal in the run satisfies SO.
\end{restatable}

\mypara{Circular Terms}
Circular terms may form through cross-goal communication. Consider the clause \verb|p(X?,X)| and goals \verb|p(X,f(Y?)), p(Y,f(X?))|. After both reductions, \verb|X| is assigned \verb|f(Y?)| and \verb|Y| is assigned \verb|f(X?)|, yielding the circular term \verb|X = f(f(X?))|. In a multiagent setting these goals may execute on different agents, making any occurs check infeasible. Implementations must handle circular terms gracefully.

\begin{formal}{Circular Term Semantics}
\label{formal:circular-terms}
Circular terms arise when a variable appears (via its reader) within its own assigned value. The following operations must handle circular terms:

\begin{description}
\item[Dereferencing.] Following a chain of assignments must detect cycles and terminate. When a cycle is detected, dereferencing returns the circular structure itself rather than diverging.

\item[Ground test.] A term is \temph{ground} if it contains no variables. A circular term such as \verb|f(f(f(...)))| contains no variables and is therefore ground. A term like \verb|f(g(X?), f(f(...)))| where \verb|X?| is unbound is not ground, regardless of the cycle in its second argument.

\item[Equality test.] Two terms are equal if they have identical structure. For circular terms, this requires comparing corresponding positions while tracking pairs already visited. If two positions in the respective terms both point back to previously compared positions, they are equal at that point.

\item[Term copying.] Copying a circular term produces a circular copy with the same structure. The cycle in the copy is independent of the original.

\item[Term display.] Displaying a circular term must detect the cycle and use a finite representation, such as indicating the cycle point.
\end{description}
\end{formal}

\begin{example}[Circular Term Formation]
\label{example:circular-term}
Given clause \verb|p(X?,X)| and query \verb|p(X,f(Y?)), p(Y,f(X?))|:
\begin{enumerate}
\item Goal \verb|p(X,f(Y?))| reduces with clause \verb|p(X?,X)|. Term matching assigns \verb|X := f(Y?)|.
\item Goal \verb|p(Y,f(X?))| reduces with clause \verb|p(X1?,X1)| (renamed). Term matching assigns \verb|Y := f(X?)|.
\item Applying the readers counterpart: \verb|Y?| receives \verb|f(X?)| and \verb|X?| receives \verb|f(Y?)|.
\item Result: \verb|X = f(Y?) = f(f(X?))| --- a circular term.
\end{enumerate}
The term \verb|X| is ground (contains no unbound variables) despite being circular.
\end{example}

\mypara{Monotonicity}
Unlike LP where variable instantiation can cause a previously reducible goal to fail, GLP exhibits monotonicity. In a run, if a goal $A$ can be reduced at some point, it remains reducible at all future points in that run, where 
``future" implies that readers in $A$ (and only readers) have been further instantiated by other goal reductions.

\begin{restatable}[Reader-Instance]{lemma}{ReaderOnlyInstantiation}\label{lemma:reader-only}
In any $GLP$ run $G_0 \rightarrow G_1 \rightarrow \cdots$, if $G_i \rightarrow G_{i+1}$ via reduction with readers assignment $\sigma$ does not reduce $A \in G_{i}$, then $A\tau \in G_{i+1}$ where $\tau$ instantiates only readers.
\end{restatable}

\begin{restatable}[Monotonicity]{proposition}{Monotonicity}\label{proposition:GLP-monotonicity}
In any $GLP$ run $G_0 \rightarrow G_1 \rightarrow \cdots$, if unit goal $A \in G_i$ can reduce with clause $C$, then for any $j > i$, either $A$ has been reduced by step $j$, or there exists $A' \in G_j$ where $A' = A\tau$ for some readers assignment $\tau$, and $A'$ can reduce with $C$.
\end{restatable}


\section{Guards}
\label{sec:guards}

Guards are predicates that test conditions without side effects. A clause is applicable only if its guard succeeds. Guards appear between the clause head and the body, separated by \verb$|$:

\begin{verbatim}
Head :- Guard | Body.
\end{verbatim}

If the guard suspends (e.g., tests an unbound variable), the clause is not yet applicable. If the guard fails, the next clause is tried. If the guard succeeds, the clause commits and executes its body.

\subsection{Built-in Guards}
\label{sec:builtin-guards}

\mypara{Type Guards}
Type guards test the structure of a value:
\begin{itemize}
\item \verb|ground(X)| --- succeeds if \verb|X| contains no unbound variables
\item \verb|known(X)| --- succeeds if \verb|X| is bound (may contain unbound subterms)
\item \verb|unknown(X)| --- succeeds if \verb|X| is an unbound variable
\item \verb|integer(X)|, \verb|number(X)|, \verb|string(X)|, \verb|constant(X)| --- test for specific types
\item \verb|compound(X)|, \verb|tuple(X)| --- test for compound terms
\item \verb|is_list(X)| --- tests for proper list structure
\end{itemize}

The \verb|ground(X)| guard is special: it relaxes the single-reader constraint for \verb|X?| within the clause, permitting multiple reader occurrences since a ground term contains no writers.

\mypara{Arithmetic Guards}
Arithmetic guards compare numeric values:
\begin{itemize}
\item \verb|X =:= Y| --- numeric equality
\item \verb|X < Y|, \verb|X > Y|, \verb|X =< Y|, \verb|X >= Y| --- comparisons
\end{itemize}

These suspend if either operand is unbound.

\mypara{Equality Guard}
The guard \verb|X =?= Y| tests ground equality: succeeds if both are ground and equal, fails if both are ground and different, suspends if either contains unbound readers.

\mypara{Control Guards}
The \verb|otherwise| guard succeeds when all previous clauses for the predicate failed (not suspended). This enables default case handling.

\subsection{Guard Negation}
\label{sec:guard-negation}

Any negatable guard \verb|G| can be negated using \verb|~G|. The negated guard succeeds when \verb|G| fails, fails when \verb|G| succeeds, and suspends when \verb|G| suspends.

\begin{verbatim}
lookup(Key, [(K,V)|_], V?) :- Key? =?= K? | true.
lookup(Key, [(K,_)|Rest], V?) :- ~(Key? =?= K?) | lookup(Key?, Rest?, V).
\end{verbatim}

Type guards and \verb|=?=| are negatable. Arithmetic comparisons and \verb|otherwise| are not.

\subsection{Defined Guards}
\label{sec:defined-guards}

A \emph{defined guard} is a user-defined predicate that can be called in guard position. It must be a \emph{unit clause}---a clause with no guards and no body (or body \verb|true|).

\mypara{Type Tests}
A unit clause can define a type test:

\begin{verbatim}
channel(ch(_, _)).
\end{verbatim}

When called in guard position, the pattern is matched against the argument:

\begin{verbatim}
process(X, ok) :- channel(X?) | handle(X?).
process(_, error) :- otherwise | true.
\end{verbatim}

The compiler transforms this by \emph{partial evaluation}---unfolding the unit clause at compile time:

\begin{verbatim}
process(ch(_, _), ok) :- handle(ch(_, _)?).
process(_, error) :- otherwise | true.
\end{verbatim}

\mypara{Channel Operations}
Channel operations are defined as unit clauses:

\begin{verbatim}
send(X, ch(In, [X?|Out?]), ch(In?, Out)).
receive(X?, ch([X|In], Out?), ch(In?, Out)).
new_channel(ch(Xs?, Ys), ch(Ys?, Xs)).
\end{verbatim}

These enable abstract channel manipulation in guards. Consider a relay that forwards messages from a stream to a channel:

\begin{verbatim}
relay([X|In], Out?, Ch) :- send(X?, Ch?, Ch1) | relay(In?, Out, Ch1?).
relay(In?, [X?|Out?], Ch) :- receive(X, Ch?, Ch1) | relay(In, Out, Ch1?).
relay([], [], ch([], [])).
\end{verbatim}

The first clause sends stream element \verb|X| to the channel. The second receives from the channel to the output stream. The compiler unfolds the defined guards:

\begin{verbatim}
relay([X|In], Out?, ch(ChIn, [X?|ChOut?])) :- relay(In?, Out, ch(ChIn?, ChOut)).
relay(In?, [X?|Out?], ch([X|ChIn], ChOut?)) :- relay(In, Out, ch(ChIn?, ChOut)).
relay([], [], ch([], [])).
\end{verbatim}

The abstract form is clearer; the expanded form shows what actually executes.

\mypara{Channel Allocation}
The \verb|new_channel| guard allocates a cross-linked channel pair:

\begin{verbatim}
make_pair(C1?, C2?) :- new_channel(C1, C2) | true.
\end{verbatim}

Variables \verb|C1| and \verb|C2| are writers in the guard (allocated there) and readers in the head (returned to caller). After partial evaluation:

\begin{verbatim}
make_pair(ch(X1?, X2), ch(X2?, X1)).
\end{verbatim}

The channels are cross-linked: what is written to one is read from the other.

\mypara{Response Binding}
The cold-call protocol uses \verb|new_channel| to create a response:

\begin{verbatim}
bind_response(yes, accept(RemoteCh?), LocalCh?) :-
    new_channel(LocalCh, RemoteCh) | true.
bind_response(no, reject, none).
\end{verbatim}

When accepting, cross-linked channels are allocated. \verb|RemoteCh| is sent to the caller; \verb|LocalCh| is kept locally. After partial evaluation:

\begin{verbatim}
bind_response(yes, accept(ch(X2?, X1)), ch(X1?, X2)).
bind_response(no, reject, none).
\end{verbatim}

\subsection{SRSW Rules for Defined Guards}
\label{sec:srsw-defined-guards}

When a guard allocates variables (like \verb|new_channel|), those variables are writers in the guard and may be readers elsewhere:

\begin{center}
\begin{tabular}{lll}
\textbf{Position} & \textbf{Form} & \textbf{Meaning} \\
\hline
Head & \verb|X| (writer) & Receives value from caller \\
Head & \verb|X?| (reader) & Returns value to caller \\
Guard & \verb|X| (writer) & Guard provides this value \\
Guard & \verb|X?| (reader) & Reads from head or earlier guard \\
Body & \verb|X| (writer) & Body provides this value \\
Body & \verb|X?| (reader) & Reads from head or guard \\
\end{tabular}
\end{center}

For allocation guards like \verb|new_channel(C1, C2)|:
\begin{itemize}
\item \verb|C1| and \verb|C2| are writers in the guard (allocated there)
\item They appear as readers in the head (\verb|C1?|, \verb|C2?|) to return to caller
\end{itemize}

The complete reference for guards appears in Appendix~\ref{app:glp-reference}.

\section{Exercises}

\begin{enumerate}
\item Trace the full computation of \verb|merge([1], [a], Out)| showing all configurations.

\item What happens if we query \verb|merge(X, Y, [1,2,3])| with $X$ and $Y$ uninstantiated? Explain why.

\item Explain why monotonicity fails in standard LP. Give a concrete example where a reducible goal becomes unreducible.

\item Design a goal that never terminates but is fair (every subgoal gets reduced infinitely often).

\item Prove that if all goals in a GLP computation eventually become reducible, the computation is deadlock-free.
\end{enumerate}
