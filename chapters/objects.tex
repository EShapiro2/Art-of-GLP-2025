% chapters/ch11_oop.tex - Object-Oriented Programming

\chapter{Objects and Processes}
\label{ch:objects}

This chapter shows how object-oriented concepts emerge naturally from stream-based programming in \GLP. Objects are processes that maintain state and respond to messages---a perspective that unifies concurrent and object-oriented programming.

\section{Objects as Processes}
\label{sec:objects-as-processes}

An \emph{object} in \GLP is a recursive process that:
\begin{itemize}
\item Maintains internal state in recursive parameters
\item Receives messages through an input stream
\item May respond through output streams or message variables
\end{itemize}

The fundamental pattern:

\begin{verbatim}
object(State, [Msg | Msgs?], Responses?) :-
    handle(Msg?, State?, NewState, Response),
    Responses = [Response? | RestResponses?],
    object(NewState?, Msgs?, RestResponses).
\end{verbatim}

State evolves through recursive calls; the process never terminates while messages arrive.

\section{A Simple Counter}
\label{sec:counter}

The counter object demonstrates stateful message handling:

\begin{verbatim}
counter([clear|S?], _) :-
    counter(S?, 0).
counter([up|S?], State) :-
    NewState := State? + 1,
    counter(S?, NewState?).
counter([down|S?], State) :-
    NewState := State? - 1,
    counter(S?, NewState?).
counter([show(State?)|S?], State) :-
    counter(S?, State?).
counter([], _).
\end{verbatim}

The counter responds to four messages:
\begin{itemize}
\item \verb|clear| --- reset state to 0
\item \verb|up| --- increment state
\item \verb|down| --- decrement state
\item \verb|show(V)| --- return current state via \verb|V|
\end{itemize}

\paragraph{Message Pattern Matching.} Each clause pattern-matches on the message. The first element of the stream determines which clause fires---this is \emph{method dispatch} via unification.

\paragraph{State Encapsulation.} The state variable \verb|State| is local to the recursive process. External processes cannot access it directly; they must send messages. This achieves \emph{encapsulation}.

\paragraph{The show Message.} The \verb|show(State?)| message demonstrates \emph{incomplete messages}: the sender provides a variable, and the counter fills it with the current state. The sender can then read the response:

\begin{verbatim}
%% Client sends show and waits for response
use_counter([show(Val)|Input?], [show(Val)|Command?]) :-
    use_counter(Input?, Command),
    wait_write(Val?).

wait_write(X) :- known(X?) | write(X?).
\end{verbatim}

The guard \verb|known(X?)| suspends until the counter fills in \verb|Val|.

\section{Encapsulation}
\label{sec:encapsulation}

Encapsulation in \GLP emerges from the process model:

\begin{enumerate}
\item \textbf{Hidden state:} The \verb|State| parameter is internal to the recursion. No external process can directly read or modify it.

\item \textbf{Controlled interface:} Only defined message types are handled. Sending an unknown message causes suspension (no matching clause).

\item \textbf{Sequential consistency:} Messages are processed in stream order. Each message sees the state left by previous messages.
\end{enumerate}

Compare with traditional OOP:
\begin{center}
\begin{tabular}{ll}
\textbf{OOP Concept} & \textbf{GLP Realization} \\
\hline
Private fields & Recursive parameters \\
Public methods & Message patterns \\
Method call & Stream element \\
Return value & Incomplete message variable \\
\end{tabular}
\end{center}

\section{Method Dispatch}
\label{sec:method-dispatch}

Method dispatch in \GLP is pattern matching on the message stream head. The counter uses simple atom patterns (\verb|clear|, \verb|up|, \verb|down|), but richer dispatch is possible:

\begin{verbatim}
object([set(Field, Value)|S?], State) :-
    update_field(Field?, Value?, State?, NewState),
    object(S?, NewState?).
object([get(Field, Result)|S?], State) :-
    get_field(Field?, State?, Result),
    object(S?, State?).
object([method(Name, Args, Result)|S?], State) :-
    invoke(Name?, Args?, State?, NewState, Result),
    object(S?, NewState?).
\end{verbatim}

The message structure determines dispatch:
\begin{itemize}
\item \verb|set(Field, Value)| --- update a named field
\item \verb|get(Field, Result)| --- query a field
\item \verb|method(Name, Args, Result)| --- invoke named method
\end{itemize}

\section{Object Identity and Multiple Instances}
\label{sec:object-identity}

Each \verb|counter| call creates a distinct object instance with its own state. Managing multiple instances requires routing:

\begin{verbatim}
use_many_counters([create(Name)|Input?], List_of_counters) :-
    counter(Com?, 0),
    use_many_counters(Input?, [(Name?, Com)|List_of_counters?]).

use_many_counters([(Name, Cmd)|Input?], List_of_counters) :-
    send(List_of_counters?, Name?, Cmd?, NewList) |
    use_many_counters(Input?, NewList?).

%% Route message to named counter
send([(Name, [Message|Y?])|List?], Name, Message, [(Name?, Y)|List]).
send([C|List?], Name, Message, [C?|L1?]) :-
    send(List?, Name?, Message?, L1).
\end{verbatim}

The \verb|create(Name)| message spawns a new counter and registers it with the given name. Subsequent messages like \verb|(alice, up)| are routed to the named counter by \verb|send/4|.

\paragraph{Object Registry.} The \verb|List_of_counters| maintains name-to-stream mappings. This is a simple object registry---more sophisticated systems might use hash tables or hierarchical namespaces.

\section{Queue Manager: Incomplete Messages}
\label{sec:queue-manager}

The queue manager demonstrates a powerful pattern: \emph{incomplete messages} for deferred responses.

\begin{verbatim}
%% Queue as difference list: Head--Tail
%% Initial call: qm(Requests?, Q, Q)

qm([dequeue(X)|S?], [X|Head?], Tail) :-
    qm(S?, Head?, Tail?).

qm([enqueue(X)|S?], Head, [X|Tail?]) :-
    qm(S?, Head?, Tail?).
\end{verbatim}

The queue uses a difference list \verb|Head--Tail|:
\begin{itemize}
\item \verb|enqueue(X)| extends the tail: \verb|[X|Tail?]|
\item \verb|dequeue(X)| extracts from the head: \verb|[X|Head?]|
\end{itemize}

\paragraph{The Key Insight.} When the queue is empty and \verb|dequeue(X)| arrives:
\begin{enumerate}
\item \verb|X| unifies with the (unbound) head variable
\item The dequeue ``succeeds'' immediately, but \verb|X| is still unbound
\item When \verb|enqueue(V)| later arrives, \verb|V| fills the tail slot
\item Since head and tail were the same variable, \verb|X| now equals \verb|V|
\end{enumerate}

The dequeueing process receives \verb|V| through \verb|X| \emph{without explicit response communication}. This is implicit synchronization through unification.

\paragraph{Multiple Clients.} Multiple clients can share a queue manager:

\begin{verbatim}
%% Two users merged into single request stream
user1(X), user2(Y), merge(X?, Y?, Z), qm(Z?, Q, Q)
\end{verbatim}

Each user sends \verb|enqueue| and \verb|dequeue| messages. The queue manager serializes access automatically---message order determines operation order.

\section{Comparison with Actor Model}
\label{sec:actor-comparison}

\GLP objects resemble actors but with key differences:

\begin{center}
\begin{tabular}{lll}
\textbf{Feature} & \textbf{Actors} & \textbf{GLP Objects} \\
\hline
Message delivery & Asynchronous, unordered & Stream-ordered \\
Response mechanism & Explicit reply & Incomplete messages \\
State update & Internal mutation & Recursive parameter \\
Creation & \verb|spawn| & Goal spawning \\
Identity & Actor reference & Stream endpoint \\
\end{tabular}
\end{center}

The stream-ordered delivery in \GLP simplifies reasoning about state consistency but limits concurrency compared to fully asynchronous actors.

\section{Exercises}
\label{sec:oop-exercises}

\begin{enumerate}
\item \textbf{Bank Account.} Implement a bank account object with messages \verb|deposit(Amount)|, \verb|withdraw(Amount, Success)|, and \verb|balance(B)|. The withdraw should fail (set \verb|Success| to \verb|false|) if insufficient funds.

\item \textbf{Stack Object.} Implement a stack with \verb|push(X)|, \verb|pop(X)|, and \verb|empty(B)|. Use incomplete messages so \verb|pop| on an empty stack waits for the next \verb|push|.

\item \textbf{Named Object Registry.} Extend \verb|use_many_counters| to support \verb|delete(Name)| for removing objects and \verb|list(Names)| for querying all registered names.

\item \textbf{Observer Pattern.} Implement an observable counter that notifies registered observers whenever its value changes.

\item \textbf{Bounded Counter.} Modify the counter to have minimum and maximum bounds. Operations that would exceed bounds should be ignored or signal an error.
\end{enumerate}
