%% Chapter 4a: Programming with Constants
%% This chapter covers fundamental patterns with constant values

\chapter{Programming with Constants}
\label{ch:constants}

The simplest \GLP programs transform constant values. These programs illustrate fundamental patterns of reader/writer variable usage and clause selection.

\section{Unary Predicates}
\label{sec:constants-unary}

A unary predicate with one reader parameter defines a property:

\begin{verbatim}
zero(0).
one(1).
positive(1).
\end{verbatim}

These succeed when called with matching constants:

\begin{verbatim}
GLP> zero(0).
zero(0) :- true
-> succeeds

GLP> zero(1).
-> fails (no matching clause)

GLP> positive(1).
positive(1) :- true
-> succeeds
\end{verbatim}

These traces illustrate the two constant-vs-constant cases from term matching (Appendix~\ref{appendix:atomic-unification}). When the goal constant matches the head constant, term matching succeeds with the empty assignment. When they differ, term matching fails and the clause fails. The runtime tries clauses in order; if none succeed, the goal fails.

A unary predicate with one writer parameter generates a value:

\begin{verbatim}
default_value(42).
initial_state(ready).
\end{verbatim}

\begin{verbatim}
GLP> default_value(X).
default_value(X) :- true
X = 42
-> succeeds
\end{verbatim}

Here the goal argument \verb|X| is a writer and the head argument is the constant \verb|42|. Term matching succeeds with assignment $\{$\verb|X| $\leftarrow 42\}$ (Appendix~\ref{appendix:atomic-unification}, Goal Writer vs.\ Term). The writer receives the constant value directly.

\section{Parameter Passing Patterns}

Binary predicates combine input and output parameters. The most common pattern: reader for input, writer for output.

\begin{verbatim}
successor(0, 1).
successor(1, 2).
successor(2, 3).
\end{verbatim}

\begin{verbatim}
GLP> successor(0, X).
successor(0, X) :- true
X = 1
-> succeeds

GLP> successor(2, X).
successor(2, X) :- true
X = 3
-> succeeds

GLP> successor(5, X).
-> fails (no matching clause)
\end{verbatim}

Multiple outputs use multiple writers:

\begin{verbatim}
decompose(10, 1, 0).
decompose(23, 2, 3).
\end{verbatim}

\begin{verbatim}
GLP> decompose(23, Tens, Units).
decompose(23, Tens, Units) :- true
Tens = 2
Units = 3
-> succeeds
\end{verbatim}

\section{Clause Selection by Mode}

Readers in clause heads enable pattern matching---clause selection based on input values.

\begin{verbatim}
color_code(red, 1).
color_code(green, 2).
color_code(blue, 3).
\end{verbatim}

The first argument (reader) selects the clause; the second (writer) delivers the result:

\begin{verbatim}
GLP> color_code(red, X).
color_code(red, X) :- true
X = 1
-> succeeds

GLP> color_code(blue, X).
color_code(blue, X) :- true
X = 3
-> succeeds
\end{verbatim}

Multiple readers enable multi-way dispatch:

\begin{verbatim}
combine(red, blue, purple).
combine(red, yellow, orange).
combine(blue, yellow, green).
\end{verbatim}

\begin{verbatim}
GLP> combine(red, blue, X).
combine(red, blue, X) :- true
X = purple
-> succeeds

GLP> combine(blue, yellow, X).
combine(blue, yellow, X) :- true
X = green
-> succeeds
\end{verbatim}

\section{Binary Predicates}
\label{sec:constants-binary}

Some predicates work in multiple modes. Consider the \verb|not| gate:

\begin{verbatim}
not(1, 0).
not(0, 1).
\end{verbatim}

With both parameters as readers, either can drive clause selection:

\begin{verbatim}
GLP> not(1, X).
not(1, X) :- true
X = 0
-> succeeds

GLP> not(X, 1).
not(X, 1) :- true
X = 0
-> succeeds
\end{verbatim}

However, with both as unbound readers:

\begin{verbatim}
GLP> not(X?, Y?).
-> suspended (waiting for X)
\end{verbatim}

The goal suspends because a reader against a constant requires the paired writer to provide a value first (Appendix~\ref{appendix:atomic-unification}, Goal Reader vs.\ Term). This demonstrates \GLP's data-driven execution: computation proceeds when sufficient input is available.

Contrast with unbound writers:

\begin{verbatim}
GLP> not(X, Y).
not(1, 0) :- true
X = 1
Y = 0
-> succeeds
\end{verbatim}

Writers can receive values directly, so the first clause matches immediately.

\section{Logic Gates}
\label{sec:constants-gates}

Digital circuits provide a natural example of dataflow computation. We define basic gates as facts:

\begin{verbatim}
and(1,1,1).
and(1,0,0).
and(0,1,0).
and(0,0,0).

or(1,1,1).
or(1,0,1).
or(0,1,1).
or(0,0,0).

not(1,0).
not(0,1).

xor(1,1,0).
xor(1,0,1).
xor(0,1,1).
xor(0,0,0).
\end{verbatim}

Each gate suspends until its inputs are bound:

\begin{verbatim}
GLP> and(1,1,X).
and(1,1,X) :- true
X = 1
-> succeeds

GLP> and(1,0,X).
and(1,0,X) :- true
X = 0
-> succeeds
\end{verbatim}

Compound gates compose simpler ones, introducing a fundamental principle of GLP programming.

\begin{formal}{Output Parameter Convention}
In GLP, output parameters in the clause head are \emph{readers}, not writers. The caller provides a writer (or reader) as the output argument; the clause head receives it as a reader. The clause body contains the paired writer, which produces the output value.

This follows directly from SRSW. Consider a goal \verb|nand(1,1,X)| calling head \verb|nand(A,B,Z?)|:
\begin{itemize}
\item The caller's \verb|X| (a writer) matches with the head's \verb|Z?| (a reader)
\item The body must contain writer \verb|Z| to produce the output
\item Each variable occurs exactly once as writer, once as reader
\end{itemize}

If the head used \verb|Z| (writer) instead of \verb|Z?| (reader), there would be two writers for \verb|Z|---one in the head, one in the body---violating SRSW.
\end{formal}

\begin{verbatim}
nand(A,B,Z?) :- and(A?,B?,W), not(W?,Z).
\end{verbatim}

\begin{verbatim}
GLP> nand(1,1,X).
nand(1,1,X) :- and(1,1,X1), not(X1?,X2)
and(1,1,X1) :- true
not(1,X2) :- true
X = 0
-> succeeds
\end{verbatim}

This trace illustrates several term matching cases and body activation. The goal \verb|nand(1,1,X)| matches head \verb|nand(A,B,Z?)|:
\begin{itemize}
\item Arguments 1 and 2: goal constants \verb|1|, \verb|1| against head writers \verb|A|, \verb|B|. This is the constant-vs-variable case (Appendix~\ref{appendix:atomic-unification}): the head writers receive the constants, yielding $\hat\sigma = \{A \leftarrow 1, B \leftarrow 1\}$.
\item Argument 3: goal writer \verb|X| against head reader \verb|Z?|. This succeeds with $\{X \leftarrow Z?\}$ (Appendix~\ref{appendix:atomic-unification}, Goal Writer vs.\ Term). The goal writer is assigned the head reader, connecting the two communication channels.
\end{itemize}

After head term matching succeeds, the body is activated. The Schedule operation applies both the writers assignment $\hat\sigma$ and its readers counterpart $\hat\sigma?$ to the renamed clause body. The body goals \verb|and(A?,B?,W)| and \verb|not(W?,Z)| become \verb|and(1,1,W)| and \verb|not(W?,Z)|---the readers \verb|A?| and \verb|B?| receive values \verb|1| and \verb|1| via the induced reader assignment.

The body goals execute concurrently. The \verb|and| goal succeeds immediately, binding \verb|W| to \verb|1|. This induced reader assignment propagates to \verb|W?| in the \verb|not| goal, which then matches \verb|not(1,0)| and binds \verb|Z| to \verb|0|. Since \verb|X| was assigned \verb|Z?|, the value flows through: \verb|X = 0|.

\begin{formal}{Input and Output Parameters: Derivation from Writer Unification}
\label{formal:input-output-derivation}

The parameter conventions in \verb|nand| follow necessarily from term matching
(Definition~\ref{definition:term-matching}). Understanding this derivation prevents
common errors.

\mypara{Output Parameters}
Consider the third argument of \verb|nand(A,B,Z?) :- and(A?,B?,W), not(W?,Z).|

When the goal \verb|nand(1,1,X)| matches with the head, the third argument position
has goal writer \verb|X| against head reader \verb|Z?|. From the term matching catalog
(Appendix~\ref{appendix:atomic-unification}, Goal Writer vs.\ Term), this succeeds
with assignment $\{Z \leftarrow X?\}$.

What does this mean? The head's fresh writer \verb|Z| is assigned the goal's reader
\verb|X?|. This connects two communication channels: when \verb|Z| in the body is
bound (via \verb|not(W?,Z)|), that value flows through \verb|X?| to whoever holds
the goal's writer \verb|X|.

\textbf{Principle:} To produce a value (output), use a reader in the head.
The goal's writer against the head's reader gives the clause write access to the
caller's channel.

\mypara{Input Parameters}
The first two arguments demonstrate input parameters. When goal constant \verb|1|
meets head writer \verb|A|, this succeeds with $\{A \leftarrow 1\}$. Now \verb|A?|
in the body equals \verb|1|.

More generally, when a goal reader \verb|X?| meets head writer \verb|V|, the
assignment is $\{V \leftarrow X?\}$. The head writer is assigned the goal reader,
giving the clause read access to an incoming channel.

\textbf{Principle:} To receive a value (input), use a writer in the head.
The goal's reader against the head's writer gives the clause read access to the
caller's channel.

\mypara{Why This Matters}
These are not arbitrary conventions. They follow from the asymmetry of writer
term matching: only writers can be assigned, and goal writers can receive values
while goal readers must wait. A common error is reversing the convention---using
a writer where a reader is needed, or vice versa---which leads to either SRSW
violations or incorrect dataflow.
\end{formal}

\begin{verbatim}
GLP> nand(0,1,X).
nand(0,1,X) :- and(0,1,X1), not(X1?,X2)
and(0,1,X1) :- true
not(0,X2) :- true
X = 1
-> succeeds
\end{verbatim}

A half-adder takes two input bits and produces a sum and carry. Since \verb|A?| and \verb|B?| each appear twice in the body (in both \verb|xor| and \verb|and|), we need \verb|ground| guards:

\begin{verbatim}
half_adder(A,B,Sum?,Carry?) :-
    ground(A?), ground(B?) |
    xor(A?,B?,Sum), and(A?,B?,Carry).
\end{verbatim}

The \verb|ground| guards are necessary because \verb|A?| and \verb|B?| each appear twice in the body. Without guards, this would violate the single-reader requirement (see Formal Box~\ref{formal:guards-multiple-reads} for the complete derivation).

\begin{verbatim}
GLP> half_adder(1,1,S,C).
half_adder(1,1,S,C) :- xor(1,1,X1), and(1,1,X2)
xor(1,1,X1) :- true
and(1,1,X2) :- true
S = 0
C = 1
-> succeeds

GLP> half_adder(1,0,S,C).
half_adder(1,0,S,C) :- xor(1,0,X1), and(1,0,X2)
xor(1,0,X1) :- true
and(1,0,X2) :- true
S = 1
C = 0
-> succeeds
\end{verbatim}

A full-adder adds three bits: two inputs and a carry-in. Each reader appears only once in the body, so no guards are needed:

\begin{verbatim}
full_adder(A,B,Cin,Sum?,Cout?) :-
    half_adder(A?,B?,S1,C1),
    half_adder(S1?,Cin?,Sum,C2),
    or(C1?,C2?,Cout).
\end{verbatim}

The trace shows dataflow: the second half-adder and \verb|or| suspend until the first half-adder produces results:

\begin{verbatim}
GLP> full_adder(1,1,1,S,C).
full_adder(1,1,1,S,C) :- half_adder(1,1,X1,X2),
    half_adder(X1?,1,X3,X4), or(X2?,X4?,X5)
half_adder(1,1,X1,X2) :- xor(1,1,X6), and(1,1,X7)
half_adder(X1?,1,X3,X4) -> suspended
or(X2?,X4?,X5) -> suspended
\end{verbatim}

The second \verb|half_adder| suspends because its first argument \verb|X1?| is a reader matched against the head constant \verb|A|. A goal reader against a constant suspends (Appendix~\ref{appendix:atomic-unification}, Goal Reader vs.\ Term). Similarly, \verb|or| suspends. When the first \verb|half_adder| completes and binds \verb|X1| to \verb|0|, the readers counterpart delivers this value to \verb|X1?|, reactivating the suspended goal (Appendix~\ref{appendix:suspension}). The reactivated goal restarts clause matching from the first clause.

\begin{verbatim}
xor(1,1,X6) :- true
and(1,1,X7) :- true
half_adder(0,1,X3,X4) :- xor(0,1,X8), and(0,1,X9)
or(1,X4?,X5) -> suspended
xor(0,1,X8) :- true
and(0,1,X9) :- true
or(1,0,X5) :- true
S = 1
C = 1
-> succeeds
\end{verbatim}

An n-bit ripple-carry adder chains full-adders, with each stage's carry-out feeding the next stage's carry-in:

\begin{verbatim}
adder([],[],Cin,[Cin?]).
adder([A|As],[B|Bs],Cin,[S?|Ss?]) :-
    full_adder(A?,B?,Cin?,S,Cout),
    adder(As?,Bs?,Cout?,Ss).
\end{verbatim}

Adding 101 + 110 (5 + 6, LSB first):

\begin{verbatim}
GLP> adder([1,0,1],[1,1,0],0,R).
adder([1,0,1],[1,1,0],0,R) :- full_adder(1,1,0,X1,X2),
    adder([0,1],[1,0],X2?,X3)
full_adder(1,1,0,X1,X2) :- half_adder(1,1,X4,X5),
    half_adder(X4?,0,X6,X7), or(X5?,X7?,X8)
adder([0,1],[1,0],X2?,X3) -> suspended
half_adder(1,1,X4,X5) :- xor(1,1,X9), and(1,1,X10)
half_adder(X4?,0,X6,X7) -> suspended
or(X5?,X7?,X8) -> suspended
xor(1,1,X9) :- true
and(1,1,X10) :- true
half_adder(0,0,X6,X7) :- xor(0,0,X11), and(0,0,X12)
or(1,X7?,X8) -> suspended
xor(0,0,X11) :- true
and(0,0,X12) :- true
or(1,0,X8) :- true
adder([0,1],[1,0],1,X3) :- full_adder(0,1,1,X13,X14),
    adder([1],[0],X14?,X15)
...
R = [0,0,0,1]
-> succeeds
\end{verbatim}

The result \verb|[0,0,0,1]| is 1011 in binary (LSB first), which is 11 in decimal: $5 + 6 = 11$.

The trace shows the ripple-carry behavior: each \verb|adder| stage suspends waiting for the carry from the previous stage, then reactivates when the carry arrives.

\subsection{Stream-Based Gates}

The simple fact-based gates presented in this chapter process single values. Chapter~\ref{ch:streams} introduces \emph{stream-based gates} that process sequences of bit values concurrently, enabling simulation of clocked digital circuits where signals evolve over time.
