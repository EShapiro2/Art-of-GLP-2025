%% Chapter 4a: Programming with Constants
%% This chapter covers fundamental patterns with constant values

\chapter{Programming with Constants}
\label{ch:constants}

The simplest \GLP programs transform constant values. These programs illustrate fundamental patterns of reader/writer variable usage and clause selection.

\section{Unary Predicates}
\label{sec:constants-unary}

A unary predicate with one reader parameter defines a property:

\begin{verbatim}
zero(0).
one(1).
positive(1).
\end{verbatim}

These succeed when called with matching constants:

\begin{verbatim}
GLP> zero(0).
zero(0) :- true
-> succeeds

GLP> zero(1).
-> fails (no matching clause)

GLP> positive(1).
positive(1) :- true
-> succeeds
\end{verbatim}

These traces illustrate the two constant-vs-constant cases from writer unification (Appendix~\ref{appendix:atomic-unification}). When the goal constant matches the head constant, unification succeeds with the empty assignment. When they differ, no unifier exists and the clause fails. The runtime tries clauses in order; if none succeed, the goal fails.

A unary predicate with one writer parameter generates a value:

\begin{verbatim}
default_value(42).
initial_state(ready).
\end{verbatim}

\begin{verbatim}
GLP> default_value(X).
default_value(X) :- true
X = 42
-> succeeds
\end{verbatim}

Here the goal argument \verb|X| is a writer and the head argument is the constant \verb|42|. Writer unification succeeds with assignment $\{X \leftarrow 42\}$ (Appendix~\ref{appendix:atomic-unification}, Goal Writer vs.\ Term). The writer receives the constant value directly.

\section{Parameter Passing Patterns}

Binary predicates combine input and output parameters. The most common pattern: reader for input, writer for output.

\begin{verbatim}
successor(0, 1).
successor(1, 2).
successor(2, 3).
\end{verbatim}

\begin{verbatim}
GLP> successor(0, X).
successor(0, X) :- true
X = 1
-> succeeds

GLP> successor(2, X).
successor(2, X) :- true
X = 3
-> succeeds

GLP> successor(5, X).
-> fails (no matching clause)
\end{verbatim}

Multiple outputs use multiple writers:

\begin{verbatim}
decompose(10, 1, 0).
decompose(23, 2, 3).
\end{verbatim}

\begin{verbatim}
GLP> decompose(23, Tens, Units).
decompose(23, Tens, Units) :- true
Tens = 2
Units = 3
-> succeeds
\end{verbatim}

\section{Clause Selection by Mode}

Readers in clause heads enable pattern matching---clause selection based on input values.

\begin{verbatim}
color_code(red, 1).
color_code(green, 2).
color_code(blue, 3).
\end{verbatim}

The first argument (reader) selects the clause; the second (writer) delivers the result:

\begin{verbatim}
GLP> color_code(red, X).
color_code(red, X) :- true
X = 1
-> succeeds

GLP> color_code(blue, X).
color_code(blue, X) :- true
X = 3
-> succeeds
\end{verbatim}

Multiple readers enable multi-way dispatch:

\begin{verbatim}
combine(red, blue, purple).
combine(red, yellow, orange).
combine(blue, yellow, green).
\end{verbatim}

\begin{verbatim}
GLP> combine(red, blue, X).
combine(red, blue, X) :- true
X = purple
-> succeeds

GLP> combine(blue, yellow, X).
combine(blue, yellow, X) :- true
X = green
-> succeeds
\end{verbatim}

\section{Binary Predicates}
\label{sec:constants-binary}

Some predicates work in multiple modes. Consider the \verb|not| gate:

\begin{verbatim}
not(1, 0).
not(0, 1).
\end{verbatim}

With both parameters as readers, either can drive clause selection:

\begin{verbatim}
GLP> not(1, X).
not(1, X) :- true
X = 0
-> succeeds

GLP> not(X, 1).
not(X, 1) :- true
X = 0
-> succeeds
\end{verbatim}

However, with both as unbound readers:

\begin{verbatim}
GLP> not(X?, Y?).
-> suspended (waiting for X)
\end{verbatim}

The goal suspends because a reader against a constant requires the paired writer to provide a value first (Appendix~\ref{appendix:atomic-unification}, Goal Reader vs.\ Term). This demonstrates \GLP's data-driven execution: computation proceeds when sufficient input is available.

Contrast with unbound writers:

\begin{verbatim}
GLP> not(X, Y).
not(1, 0) :- true
X = 1
Y = 0
-> succeeds
\end{verbatim}

Writers can receive values directly, so the first clause matches immediately.

\section{Logic Gates}
\label{sec:constants-gates}

Digital circuits provide a natural example of dataflow computation. We define basic gates as facts:

\begin{verbatim}
and(1,1,1).
and(1,0,0).
and(0,1,0).
and(0,0,0).

or(1,1,1).
or(1,0,1).
or(0,1,1).
or(0,0,0).

not(1,0).
not(0,1).

xor(1,1,0).
xor(1,0,1).
xor(0,1,1).
xor(0,0,0).
\end{verbatim}

Each gate suspends until its inputs are bound:

\begin{verbatim}
GLP> and(1,1,X).
and(1,1,X) :- true
X = 1
-> succeeds

GLP> and(1,0,X).
and(1,0,X) :- true
X = 0
-> succeeds
\end{verbatim}

Compound gates compose simpler ones, introducing a fundamental principle of GLP programming.

\begin{formal}{Output Parameter Convention}
In GLP, output parameters in the clause head are \emph{readers}, not writers. The caller provides a writer (or reader) as the output argument; the clause head receives it as a reader. The clause body contains the paired writer, which produces the output value.

This follows directly from SRSW. Consider a goal \verb|nand(1,1,X)| calling head \verb|nand(A,B,Z?)|:
\begin{itemize}
\item The caller's \verb|X| (a writer) unifies with the head's \verb|Z?| (a reader)
\item The body must contain writer \verb|Z| to produce the output
\item Each variable occurs exactly once as writer, once as reader
\end{itemize}

If the head used \verb|Z| (writer) instead of \verb|Z?| (reader), there would be two writers for \verb|Z|---one in the head, one in the body---violating SRSW.
\end{formal}

\begin{verbatim}
nand(A,B,Z?) :- and(A?,B?,W), not(W?,Z).
\end{verbatim}

\begin{verbatim}
GLP> nand(1,1,X).
nand(1,1,X) :- and(1,1,X1), not(X1?,X2)
and(1,1,X1) :- true
not(1,X2) :- true
X = 0
-> succeeds
\end{verbatim}

This trace illustrates several unification cases and body activation. The goal \verb|nand(1,1,X)| unifies with head \verb|nand(A,B,Z?)|:
\begin{itemize}
\item Arguments 1 and 2: goal constants \verb|1|, \verb|1| against head writers \verb|A|, \verb|B|. This is the constant-vs-variable case (Appendix~\ref{appendix:atomic-unification}): the head writers receive the constants, yielding $\hat\sigma = \{A \leftarrow 1, B \leftarrow 1\}$.
\item Argument 3: goal writer \verb|X| against head reader \verb|Z?|. This succeeds with $\{X \leftarrow Z?\}$ (Appendix~\ref{appendix:atomic-unification}, Goal Writer vs.\ Term). The goal writer is assigned the head reader, connecting the two communication channels.
\end{itemize}

After head unification succeeds, the body is activated. The Schedule operation (Definition~\ref{definition:df-unification}) applies both the writer assignment $\hat\sigma$ and its induced reader assignment $\hat\sigma?$ to the renamed clause body. The body goals \verb|and(A?,B?,W)| and \verb|not(W?,Z)| become \verb|and(1,1,W)| and \verb|not(W?,Z)|---the readers \verb|A?| and \verb|B?| receive values \verb|1| and \verb|1| via the induced reader assignment.

The body goals execute concurrently. The \verb|and| goal succeeds immediately, binding \verb|W| to \verb|1|. This induced reader assignment propagates to \verb|W?| in the \verb|not| goal, which then matches \verb|not(1,0)| and binds \verb|Z| to \verb|0|. Since \verb|X| was assigned \verb|Z?|, the value flows through: \verb|X = 0|.

\begin{verbatim}
GLP> nand(0,1,X).
nand(0,1,X) :- and(0,1,X1), not(X1?,X2)
and(0,1,X1) :- true
not(0,X2) :- true
X = 1
-> succeeds
\end{verbatim}

A half-adder takes two input bits and produces a sum and carry. Since \verb|A?| and \verb|B?| each appear twice in the body (in both \verb|xor| and \verb|and|), we need \verb|ground| guards:

\begin{verbatim}
half_adder(A,B,Sum?,Carry?) :-
    ground(A?), ground(B?) |
    xor(A?,B?,Sum), and(A?,B?,Carry).
\end{verbatim}

The \verb|ground| guards are necessary because \verb|A?| and \verb|B?| each appear twice in the body. Without guards, this would violate the single-reader requirement. The \verb|ground(X?)| guard succeeds when \verb|X?| is bound to a term containing no variables; it suspends if \verb|X?| is unbound (Appendix~\ref{appendix:guard-unification}). When the guard succeeds, having multiple occurrences of a ground reader is safe---instantiating the paired writer to a ground term cannot introduce new writers that would violate single-writer.

\begin{verbatim}
GLP> half_adder(1,1,S,C).
half_adder(1,1,S,C) :- xor(1,1,X1), and(1,1,X2)
xor(1,1,X1) :- true
and(1,1,X2) :- true
S = 0
C = 1
-> succeeds

GLP> half_adder(1,0,S,C).
half_adder(1,0,S,C) :- xor(1,0,X1), and(1,0,X2)
xor(1,0,X1) :- true
and(1,0,X2) :- true
S = 1
C = 0
-> succeeds
\end{verbatim}

A full-adder adds three bits: two inputs and a carry-in. Each reader appears only once in the body, so no guards are needed:

\begin{verbatim}
full_adder(A,B,Cin,Sum?,Cout?) :-
    half_adder(A?,B?,S1,C1),
    half_adder(S1?,Cin?,Sum,C2),
    or(C1?,C2?,Cout).
\end{verbatim}

The trace shows dataflow: the second half-adder and \verb|or| suspend until the first half-adder produces results:

\begin{verbatim}
GLP> full_adder(1,1,1,S,C).
full_adder(1,1,1,S,C) :- half_adder(1,1,X1,X2),
    half_adder(X1?,1,X3,X4), or(X2?,X4?,X5)
half_adder(1,1,X1,X2) :- xor(1,1,X6), and(1,1,X7)
half_adder(X1?,1,X3,X4) -> suspended
or(X2?,X4?,X5) -> suspended
\end{verbatim}

The second \verb|half_adder| suspends because its first argument \verb|X1?| is a reader matched against the head constant \verb|A|. A goal reader against a constant suspends on $\{X1?\}$ (Appendix~\ref{appendix:atomic-unification}, Goal Reader vs.\ Term). Similarly, \verb|or| suspends on $\{X2?, X4?\}$. When the first \verb|half_adder| completes and binds \verb|X1| to \verb|0|, the induced reader assignment delivers this value to \verb|X1?|, reactivating the suspended goal (Appendix~\ref{appendix:suspension}). The reactivated goal restarts clause matching from the first clause.

\begin{verbatim}
xor(1,1,X6) :- true
and(1,1,X7) :- true
half_adder(0,1,X3,X4) :- xor(0,1,X8), and(0,1,X9)
or(1,X4?,X5) -> suspended
xor(0,1,X8) :- true
and(0,1,X9) :- true
or(1,0,X5) :- true
S = 1
C = 1
-> succeeds
\end{verbatim}

An n-bit ripple-carry adder chains full-adders, with each stage's carry-out feeding the next stage's carry-in:

\begin{verbatim}
adder([],[],Cin,[Cin?]).
adder([A|As],[B|Bs],Cin,[S?|Ss?]) :-
    full_adder(A?,B?,Cin?,S,Cout),
    adder(As?,Bs?,Cout?,Ss).
\end{verbatim}

Adding 101 + 110 (5 + 6, LSB first):

\begin{verbatim}
GLP> adder([1,0,1],[1,1,0],0,R).
adder([1,0,1],[1,1,0],0,R) :- full_adder(1,1,0,X1,X2),
    adder([0,1],[1,0],X2?,X3)
full_adder(1,1,0,X1,X2) :- half_adder(1,1,X4,X5),
    half_adder(X4?,0,X6,X7), or(X5?,X7?,X8)
adder([0,1],[1,0],X2?,X3) -> suspended
half_adder(1,1,X4,X5) :- xor(1,1,X9), and(1,1,X10)
half_adder(X4?,0,X6,X7) -> suspended
or(X5?,X7?,X8) -> suspended
xor(1,1,X9) :- true
and(1,1,X10) :- true
half_adder(0,0,X6,X7) :- xor(0,0,X11), and(0,0,X12)
or(1,X7?,X8) -> suspended
xor(0,0,X11) :- true
and(0,0,X12) :- true
or(1,0,X8) :- true
adder([0,1],[1,0],1,X3) :- full_adder(0,1,1,X13,X14),
    adder([1],[0],X14?,X15)
...
R = [0,0,0,1]
-> succeeds
\end{verbatim}

The result \verb|[0,0,0,1]| is 1011 in binary (LSB first), which is 11 in decimal: $5 + 6 = 11$.

The trace shows the ripple-carry behavior: each \verb|adder| stage suspends waiting for the carry from the previous stage, then reactivates when the carry arrives.
