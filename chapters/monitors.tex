% chapters/monitors.tex - Monitors and Stateful Servers

\chapter{Monitors and Stateful Servers}
\label{ch:monitors}

This chapter shows how reader/writer pairs naturally give rise to bidirectional channels and stateful servers.

\section{Bidirectional Channels}

A single reader/writer pair provides one-way communication. Two pairs provide bidirectional communication:

\begin{verbatim}
channel(In?, Out) :- ...
\end{verbatim}

\section{Request-Response Patterns}

[To be developed: client-server communication]

\section{Stateful Servers (Monitors)}

A \emph{monitor} is a process that maintains local state and serves requests to inspect or modify that state. The term comes from Hoare's original concept~\cite{hoare1974monitors}. In \GLP, monitors receive requests via a merged input stream and respond using incomplete messages.

\subsection{A Simple Accumulator}

The simplest monitor maintains a numeric accumulator:

\begin{verbatim}
monitor(Reqs) :- monitor(Reqs?, 0).

monitor([add(N)|Reqs], Sum) :-
    Sum1 := Sum? + N?, monitor(Reqs?, Sum1?).
monitor([subtract(N)|Reqs], Sum) :-
    Sum1 := Sum? - N?, monitor(Reqs?, Sum1?).
monitor([value(V)|Reqs], Sum) :-
    ground(Sum?) | V = Sum?, monitor(Reqs?, Sum?).
monitor([], _).
\end{verbatim}

The monitor handles three request types:
\begin{itemize}
\item \verb|add(N)| --- add \verb|N| to the accumulator
\item \verb|subtract(N)| --- subtract \verb|N| from the accumulator
\item \verb|value(V)| --- bind \verb|V| to the current sum (incomplete message)
\end{itemize}

The \verb|ground(Sum?)| guard in the \verb|value| clause permits replication of \verb|Sum?| to both the response variable and the recursive call.

\subsection{Incomplete Messages}

The \verb|value(V)| request demonstrates \emph{incomplete messages}---messages containing unbound variables that the receiver fills in. The client sends \verb|value(V?)| retaining reader \verb|V?|, and the monitor binds writer \verb|V| to the current sum. This provides bidirectional communication without explicit reply channels.

\subsection{Multiple Clients}

Multiple clients connect to a monitor through a merge network:

\begin{verbatim}
test_monitor(V1?, V2?) :-
    client1(V1, Xs),
    client2(V2, Ys),
    merge(Xs?, Ys?, Zs),
    monitor(Zs?).
\end{verbatim}

Each client produces a stream of requests. The merge combines them into a single stream consumed by the monitor. Client responses arrive via their respective incomplete message variables.

\subsection{Timing and Interleaving}

Consider two clients with different timing:

\begin{verbatim}
% Client 1: immediate requests
client1(V, [add(5), add(3), value(V?)|Xs?]) :- client1_done(Xs).
client1_done([]).

% Client 2: delayed requests (waits 100ms)
client2(V, Ys?) :-
    wait(100) |
    Ys = [add(10), subtract(2), value(V?)|Ys1?],
    client2_done(Ys1).
client2_done([]).
\end{verbatim}

The \verb|wait(100)| guard suspends client2 for 100 milliseconds, allowing client1 to complete first:

\begin{verbatim}
GLP> test_monitor(V1, V2).
client1(X1, X2) :- client1_done(X6)
client2(X3, X4) → suspended
monitor_loop([add(5)|...], 0) :- ...
monitor_loop([add(3)|...], 5) :- ...
monitor_loop([value(X1?)|...], 8) :- =/2(X1, 8), ...
client2(X3, X4) :- ...        % resumes after 100ms
monitor_loop([add(10)|...], 8) :- ...
monitor_loop([subtract(2)|...], 18) :- ...
monitor_loop([value(X3?)|...], 16) :- =/2(X3, 16), ...
V1 = 8
V2 = 16
→ succeeds
\end{verbatim}

Client1 queries at sum=8 (after 5+3). Client2 queries at sum=16 (after 5+3+10-2). The timing determines what state each client observes.

\subsection{Dynamic Client Addition}

A fixed merge tree limits the number of clients. For dynamically-changing client sets, existing clients can onboard new clients using the dynamic merge pattern from Chapter~\ref{ch:streams}:

\begin{verbatim}
merge([merge(Ws)|Xs], Ys, Zs?) :-
    merger(Ws?, Xs?, Xs1), merge(Xs1?, Ys?, Zs).
\end{verbatim}

A client sends \verb|merge(NewClientStream)| to splice in a new participant.

\section{State Machines}
\label{sec:state-machines}

State machines are naturally expressed as recursive predicates where state is encoded in the message pattern.

\subsection{A Simple Protocol}

Consider a request-response protocol with states \verb|idle|, \verb|waiting|, and \verb|done|:

\begin{verbatim}
protocol(idle, [request(X)|Msgs], Out?) :-
    Out = [processing(X?)|Out1?],
    protocol(waiting, Msgs?, Out1).
protocol(waiting, [response(R)|Msgs], Out?) :-
    Out = [result(R?)|Out1?],
    protocol(idle, Msgs?, Out1).
protocol(idle, [quit|_], [done]).
protocol(_, [], []).
\end{verbatim}

Each clause handles a specific (state, message) pair, producing output and transitioning to a new state.

\section{Plays: Simulating Multi-Agent Systems}
\label{sec:plays}

A \emph{play} is a technique for simulating multi-agent interaction in single-agent \GLP. Each ``actor'' is a predicate that produces or consumes stream elements, and actors coordinate by passing stream tails.

\subsection{Two-Actor Play: Bob and Alice}

The simplest play involves two actors cooperatively constructing a stream:

\begin{verbatim}
%% Bob writes two a's, hands tail to Alice
bob([a,a|Tail?], Result?) :- alice(Tail, Result).

%% Alice writes three b's, hands back to Bob
alice([b,b,b|Tail?], Result?) :- bob_finish(Tail, Result).

%% Bob writes two more a's and closes
bob_finish([a,a], done).
\end{verbatim}

Running \verb|bob(Stream, Done)| produces \verb|Stream = [a,a,b,b,b,a,a]| and \verb|Done = done|.

\subsection{Four-Actor Play with Timing}

Four actors interact with a shared monitor, each with different timing:

\begin{verbatim}
% Alice: immediate, adds and queries
alice(V, [add(10), add(5), value(V?)|Xs?]) :- alice_done(Xs).
alice_done([]).

% Bob: delayed 50ms, subtracts and queries
bob(V, Ys?) :-
    wait(50) |
    Ys = [subtract(3), value(V?)|Ys1?],
    bob_done(Ys1).
bob_done([]).

% Carol: delayed 100ms, adds and queries
carol(V, Zs?) :-
    wait(100) |
    Zs = [add(20), value(V?)|Zs1?],
    carol_done(Zs1).
carol_done([]).

% Diana: delayed 150ms, just queries
diana(V, Ws?) :-
    wait(150) |
    Ws = [value(V?)|Ws1?],
    diana_done(Ws1).
diana_done([]).

% Test harness
play_accum(VA?, VB?, VC?, VD?) :-
    alice(VA, As), bob(VB, Bs), carol(VC, Cs), diana(VD, Ds),
    merge(As?, Bs?, AB), merge(Cs?, Ds?, CD), merge(AB?, CD?, All),
    monitor(All?).
\end{verbatim}

Running \verb|play_accum(VA, VB, VC, VD)| yields:
\begin{itemize}
\item VA = 15 (Alice queries after 10+5)
\item VB = 12 (Bob queries after 15-3)
\item VC = 32 (Carol queries after 12+20)
\item VD = 32 (Diana queries, no change)
\end{itemize}

The staggered \verb|wait| guards ensure deterministic ordering despite concurrent execution.

\subsection{Plays with Bidirectional Communication}

Actors can communicate bidirectionally using incomplete messages:

\begin{verbatim}
%% Actor A requests a value from Actor B
actor_a([request(V?)|Tail?], Final?) :-
    actor_b(V, Tail, Final).

%% Actor B provides the value and continues
actor_b(42, [response|Tail?], Final?) :-
    actor_a_finish(Tail, Final).

actor_a_finish([done], complete).
\end{verbatim}

The \verb|request(V?)| message carries an unbound variable that Actor B fills in with \verb|42|.

\section{Observing Monitors}
\label{sec:observing-monitors}

Observing a monitor's request stream requires handling \emph{incomplete messages}. Input operations like \verb|add(N)| have ground arguments, but output operations like \verb|value(V)| contain variables that the monitor will bind. A type-aware observer must handle both modes.

\subsection{The Duplicate Predicate}

The key insight is a \verb|duplicate| predicate that waits for a value to become ground, then binds two outputs:

\begin{verbatim}
duplicate(X, X?, X?) :- ground(X?) | true.
\end{verbatim}

This suspends until \verb|X| is bound (by the monitor), then propagates the value to both the forwarded stream and the log.

\subsection{Type-Aware Monitor Observer}

\begin{verbatim}
observe_accum([add(N)|In], [add(N?)|Out?], [add(N?)|Log?]) :-
    ground(N?) | observe_accum(In?, Out, Log).
observe_accum([subtract(N)|In], [subtract(N?)|Out?], [subtract(N?)|Log?]) :-
    ground(N?) | observe_accum(In?, Out, Log).
observe_accum([value(V1?)|In], [value(V)|Out?], [value(V2?)|Log?]) :-
    duplicate(V?, V1, V2),
    observe_accum(In?, Out, Log).
observe_accum([], [], []).
\end{verbatim}

The first two clauses handle input-mode messages: \verb|N| is already ground, so the observer copies it to both output streams immediately.

The third clause handles output-mode messages: \verb|V| starts unbound. The observer:
\begin{enumerate}
\item Forwards \verb|value(V)| to the monitor (which will bind \verb|V|)
\item Calls \verb|duplicate(V?, V1, V2)| which suspends until \verb|V| is ground
\item Once bound, propagates to both \verb|V1| (client's copy) and \verb|V2| (log)
\end{enumerate}

\subsection{Observed Four-Actor Play}

Combining the observer with the four-actor play:

\begin{verbatim}
play_accum(VA?, VB?, VC?, VD?, Log?) :-
    alice(VA, As), bob(VB, Bs), carol(VC, Cs), diana(VD, Ds),
    merge(As?, Bs?, AB), merge(Cs?, Ds?, CD), merge(AB?, CD?, All),
    observe_accum(All?, Reqs, Log),
    monitor(Reqs?).
\end{verbatim}

Running \verb|play_accum(VA, VB, VC, VD, Log)| yields:
\begin{itemize}
\item VA = 15, VB = 12, VC = 32, VD = 32
\item Log = [add(10), add(5), value(15), subtract(3), value(12), add(20), value(32), value(32)]
\end{itemize}

The log captures both input operations and their ground arguments, and output operations with the values the monitor bound to them

\section{Exercises}

\begin{enumerate}
\item[$\star$] Implement a simple counter server.
\item[$\star\star$] Implement a key-value store server.
\item[$\star\star\star$] Implement a replicated state machine.
\end{enumerate}
