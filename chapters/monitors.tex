% chapters/monitors.tex - Monitors and Stateful Servers

\chapter{Monitors and Stateful Servers}
\label{ch:monitors}

This chapter shows how reader/writer pairs naturally give rise to bidirectional channels and stateful servers.

\section{Monitors}
\label{sec:monitors}

A \emph{monitor} is a process that maintains local state and serves requests to inspect or modify that state. The term comes from Hoare's original concept~\cite{hoare1974monitors}. Clients connect to a monitor via a merge network and communicate using incomplete messages.

\subsection{Counter}

The simplest monitor maintains a counter responding to \verb|clear|, \verb|add|, and \verb|read(X)|:

\begin{verbatim}
counter(In) :- counter_loop(In?, 0).

counter_loop([clear|In], _) :- counter_loop(In?, 0).
counter_loop([add|In], C) :- C1 := C? + 1, counter_loop(In?, C1?).
counter_loop([read(V)|In], C) :- ground(C?) | V = C?, counter_loop(In?, C?).
counter_loop([], _).
\end{verbatim}

The \verb|read(V)| request is an \emph{incomplete message}: the client sends \verb|read(V)| retaining reader \verb|V?|, and the monitor binds writer \verb|V| to the current count. The \verb|ground(C?)| guard permits replication of \verb|C?| to both the response and the recursive call.

\subsection{Shared Queue}

A more sophisticated monitor implements a shared queue using a difference-list. The queue serves \verb|enqueue(X)| and \verb|dequeue(X)| requests, unifying arguments of corresponding requests:

\begin{verbatim}
queue(In) :- queue_loop(In?, Q, Q).

queue_loop([dequeue(X)|In], H, T) :-
    H = [X|H1?],
    queue_loop(In?, H1, T?).
queue_loop([enqueue(X)|In], H, T) :-
    T = [X|T1?],
    queue_loop(In?, H?, T1).
queue_loop([], _, _).
\end{verbatim}

The difference-list \verb|H|--\verb|T| represents the queue contents: elements from \verb|H| up to \verb|T|. Initially both are the same unbound variable (empty queue). Enqueue extends the tail; dequeue extracts from the head.

The key insight: when the queue is empty and \verb|dequeue(X)| arrives, \verb|X| unifies with the head variable. When \verb|enqueue(V)| later arrives, \verb|V| fills the tail---which is the same variable. Thus \verb|X| receives \verb|V| through implicit synchronization, without explicit response communication.

\subsection{Multiple Clients}

Multiple clients connect to a monitor through a merge network:

\begin{verbatim}
test_counter(V1?, V2?) :-
    client1(V1, Xs),
    client2(V2, Ys),
    merge(Xs?, Ys?, Zs),
    counter(Zs?).
\end{verbatim}

Each client produces a stream of requests. The merge combines them into a single stream consumed by the monitor. Client responses arrive via incomplete message variables.

\subsection{Timing and Interleaving}

Clients with different timing demonstrate how message ordering affects observed state:

\begin{verbatim}
client1(V, [add, add, add, read(V?)|Xs?]) :- client1_done(Xs).
client1_done([]).

client2(V, Ys?) :-
    wait(100) |
    Ys = [add, add, read(V?)|Ys1?],
    client2_done(Ys1).
client2_done([]).
\end{verbatim}

The \verb|wait(100)| guard suspends client2 for 100 milliseconds. Client1 queries at count 3 (after its three adds). Client2 queries at count 5 (after all five adds). The timing determines what state each client observes.

\section{Observing Monitors}
\label{sec:observing-monitors}

Observing a monitor's request stream requires handling \emph{incomplete messages}. Input operations like \verb|add(N)| have ground arguments, but output operations like \verb|value(V)| contain variables that the monitor will bind. A type-aware observer must handle both modes.

\subsection{The Duplicate Predicate}

The key insight is a \verb|duplicate| predicate that waits for a value to become ground, then binds two outputs:

\begin{verbatim}
duplicate(X, X?, X?) :- ground(X?) | true.
\end{verbatim}

This suspends until \verb|X| is bound (by the monitor), then propagates the value to both the forwarded stream and the log.

\subsection{Type-Aware Monitor Observer}

\begin{verbatim}
observe_accum([add(N)|In], [add(N?)|Out?], [add(N?)|Log?]) :-
    ground(N?) | observe_accum(In?, Out, Log).
observe_accum([subtract(N)|In], [subtract(N?)|Out?], [subtract(N?)|Log?]) :-
    ground(N?) | observe_accum(In?, Out, Log).
observe_accum([value(V1?)|In], [value(V)|Out?], [value(V2?)|Log?]) :-
    duplicate(V?, V1, V2),
    observe_accum(In?, Out, Log).
observe_accum([], [], []).
\end{verbatim}

The first two clauses handle input-mode messages: \verb|N| is already ground, so the observer copies it to both output streams immediately.

The third clause handles output-mode messages: \verb|V| starts unbound. The observer:
\begin{enumerate}
\item Forwards \verb|value(V)| to the monitor (which will bind \verb|V|)
\item Calls \verb|duplicate(V?, V1, V2)| which suspends until \verb|V| is ground
\item Once bound, propagates to both \verb|V1| (client's copy) and \verb|V2| (log)
\end{enumerate}

\subsection{Four-Actor Play with Observation}

Four actors interact with a shared monitor through an observer:

\begin{verbatim}
% Alice: immediate, adds and queries
alice(V, [add(10), add(5), value(V?)|Xs?]) :- alice_done(Xs).
alice_done([]).

% Bob: delayed 50ms, subtracts and queries
bob(V, Ys?) :-
    wait(50) |
    Ys = [subtract(3), value(V?)|Ys1?],
    bob_done(Ys1).
bob_done([]).

% Carol: delayed 100ms, adds and queries
carol(V, Zs?) :-
    wait(100) |
    Zs = [add(20), value(V?)|Zs1?],
    carol_done(Zs1).
carol_done([]).

% Diana: delayed 150ms, just queries
diana(V, Ws?) :-
    wait(150) |
    Ws = [value(V?)|Ws1?],
    diana_done(Ws1).
diana_done([]).

% Test harness with observer
play_accum(VA?, VB?, VC?, VD?, Log?) :-
    alice(VA, As), bob(VB, Bs), carol(VC, Cs), diana(VD, Ds),
    merge(As?, Bs?, AB), merge(Cs?, Ds?, CD), merge(AB?, CD?, All),
    observe_accum(All?, Reqs, Log),
    monitor(Reqs?).
\end{verbatim}

Running \verb|play_accum(VA, VB, VC, VD, Log)| yields:
\begin{itemize}
\item VA = 15, VB = 12, VC = 32, VD = 32
\item Log = [add(10), add(5), value(15), subtract(3), value(12), add(20), value(32), value(32)]
\end{itemize}

The staggered \verb|wait| guards ensure deterministic ordering. The log captures both input operations with their ground arguments, and output operations with the values the monitor bound to them.

\section{Exercises}

\begin{enumerate}
\item Extend the counter to support \verb|subtract| in addition to \verb|add|.
\item Implement a bounded buffer monitor that blocks producers when full and consumers when empty.
\item Implement a priority queue monitor with two input streams: one for high-priority, one for low-priority requests.
\item Implement a readers-writers monitor that allows multiple concurrent readers but exclusive writers.
\end{enumerate}
