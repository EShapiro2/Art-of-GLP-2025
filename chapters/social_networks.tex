% chapters/social_networks.tex - Social Networks

\chapter{Social Networks}
\label{ch:social-networks}

This chapter presents grassroots social networking applications built upon the social graph foundation (Chapter~\ref{ch:social-graph}). We develop direct messaging between friends, feed distribution with followers, group messaging, and child-safe social networking.

Throughout this chapter, we assume agents are already connected via the social graph protocol---they have established bidirectional friend channels through cold-call or friend-mediated introduction. The applications here use these existing channels to build higher-level communication structures.

%% ============================================
%% Section 1: Direct Messaging
%% ============================================

\section{Direct Messaging}
\label{sec:direct-messaging}

Friends connected via the social graph share a \emph{control channel} for protocol messages. For ongoing conversations, they establish a separate \emph{direct messaging (DM) channel}---dedicated to private communication, independent of protocol traffic.

\subsection{Channel Primitives}

A DM channel is a bidirectional channel created with \verb|new_channel|:

\begin{verbatim}
new_channel(ch(Xs?, Ys), ch(Ys?, Xs)).
\end{verbatim}

This creates two channel endpoints with cross-connected streams. If Alice holds \verb|ch(Xs?, Ys)| and Bob holds \verb|ch(Ys?, Xs)|, then Alice writes to \verb|Ys| and reads from \verb|Xs|, while Bob writes to \verb|Xs| and reads from \verb|Ys|.

Sending and receiving on a channel:

\begin{verbatim}
dm_send(Msg, ch(In, [Msg?|Out?]), ch(In?, Out)).

dm_receive(Msg?, ch([Msg|In], Out?), ch(In?, Out)).
\end{verbatim}

The \verb|dm_send| predicate appends a message to the output stream, returning the updated channel. The \verb|dm_receive| predicate extracts a message from the input stream.

\subsection{Response Binding}

When establishing a channel, one party creates both endpoints and sends one to the other through a response variable. Since the response variable extracted from an incoming message becomes a reader, we use explicit unification:

\begin{verbatim}
bind_resp(Resp, Ch) :- Resp = Ch?.
\end{verbatim}

This binds the reader \verb|Resp| to the channel \verb|Ch|.

\subsection{The DM Protocol}

Alice initiates by sending a request containing a fresh response variable through her friend channel. Bob receives the request, creates the channel pair, binds one endpoint to the response variable, and keeps the other:

\begin{verbatim}
alice(FriendOut, FriendIn?, AliceResult?) :-
    FriendOut = [dm_request(Resp)|_],
    alice_continue(Resp?, FriendIn, AliceResult).

alice_continue(DMCh, _, result(sent, Reply?)) :-
    known(DMCh?) |
    dm_send(hello_bob, DMCh?, DMCh1),
    dm_receive(Reply, DMCh1?, _).
\end{verbatim}

Alice sends \verb|dm_request(Resp)| on the friend channel, then waits for \verb|Resp| to become bound. The \verb|known(DMCh?)| guard suspends until Bob responds. Once the DM channel arrives, Alice sends a greeting and waits for a reply.

\begin{verbatim}
bob([dm_request(Resp)|_], _, BobResult?) :-
    new_channel(BobDM, AliceDM),
    bind_resp(Resp?, AliceDM?),
    bob_continue(BobDM?, BobResult).

bob_continue(DMCh, result(Msg?, replied)) :-
    dm_receive(Msg, DMCh?, DMCh1),
    dm_send(hello_alice, DMCh1?, _).
\end{verbatim}

Bob pattern-matches the request in his clause head, creates a channel pair, binds Alice's endpoint to her response variable, then continues with his own endpoint. He receives Alice's message and sends a reply.

\subsection{The Play}

The complete play connects Alice and Bob through a shared friend channel:

\begin{verbatim}
verify(result(sent, Reply), result(Msg, replied)) :-
    report(Msg?, Reply?).

report(hello_bob, hello_alice).

play_dm :-
    alice(FriendOut, FriendIn?, AliceResult),
    bob(FriendOut?, FriendIn, BobResult),
    verify(AliceResult?, BobResult?).
\end{verbatim}

The friend channel connects Alice's output (\verb|FriendOut|) to Bob's input (\verb|FriendOut?|), and Bob's output (\verb|FriendIn|) to Alice's input (\verb|FriendIn?|). The \verb|verify| predicate confirms successful message exchange.

\subsection{Execution Trace}

\begin{verbatim}
?- play_dm.
alice(FriendOut, FriendIn?, AliceResult) :-
    alice_continue(Resp?, FriendIn, AliceResult)
bob([dm_request(Resp)|_], FriendIn, BobResult) :-
    new_channel(BobDM, AliceDM),
    bind_resp(Resp?, AliceDM?),
    bob_continue(BobDM?, BobResult)
new_channel(BobDM, AliceDM) :- true
bind_resp(Resp?, ch(X1?, X2)) :- true
bob_continue(ch(X2?, X1), BobResult) :-
    dm_receive(Msg, ch(X2?, X1), DMCh1),
    dm_send(hello_alice, DMCh1?, _)
alice_continue(ch(X1?, X2), FriendIn, AliceResult) :-
    dm_send(hello_bob, ch(X1?, X2), AliceCh1),
    dm_receive(Reply, AliceCh1?, _)
dm_send(hello_bob, ch(X1?, X2), AliceCh1) :- true
dm_receive(Msg, ch([hello_bob|X3?], X1), DMCh1) :- true
dm_send(hello_alice, ch(X3?, X4), _) :- true
dm_receive(Reply, ch([hello_alice|X5?], X3), _) :- true
report(hello_bob, hello_alice) :- true
-> succeeds
\end{verbatim}

The trace shows the complete protocol:
\begin{enumerate}
\item Alice sends \verb|dm_request(Resp)| on the friend channel
\item Bob receives the request, creates a channel pair with \verb|new_channel|
\item Bob binds Alice's endpoint to her response variable via \verb|bind_resp|
\item Alice's \verb|known| guard succeeds; she sends \verb|hello_bob|
\item Bob receives \verb|hello_bob| and replies with \verb|hello_alice|
\item Alice receives the reply
\item \verb|report(hello_bob, hello_alice)| confirms the exchange
\end{enumerate}

%% ============================================
%% Section 2: Feeds and Followers
%% ============================================

\section{Feeds and Followers}
\label{sec:feeds-followers}

A \emph{feed} is a stream of posts produced by an author and distributed to \emph{followers}. This section develops the feed server---processing subscriptions and broadcasting posts to all subscribers.

\subsection{Feed Structure}

A feed is represented as \verb|feed(Posts)| where \verb|Posts| is a list of posts, newest first:

\begin{verbatim}
make_feed(feed([])).

extend_feed(Post, feed(Xs), feed([Post?|Xs?])).
\end{verbatim}

The \verb|make_feed| predicate creates an empty feed. The \verb|extend_feed| predicate prepends a new post to an existing feed.

\subsection{Broadcasting with Ground Guard}

The \verb|ground| guard enables distributing a single post to multiple followers. Without this guard, sending a post to multiple output streams would violate SRSW---each follower's stream would need its own writer occurrence of the post.

\begin{verbatim}
broadcast(_, [], []).
broadcast(Post, [(Name, Feed)|Fs], [(Name?, Feed1?)|Fs1?]) :-
    ground(Post?) |
    extend_feed(Post?, Feed?, Feed1),
    broadcast(Post?, Fs?, Fs1).
\end{verbatim}

The \verb|ground(Post?)| guard suspends until the post is fully instantiated, then permits reading \verb|Post?| multiple times---once per follower. Each follower's feed is extended with the post.

\subsection{Follower Management}

Followers are stored as an association list mapping names to feeds:

\begin{verbatim}
get_feed(Name, [(Name?, Feed)|_], Feed?).
get_feed(Name?, [_|Fs], Feed?) :- get_feed(Name, Fs?, Feed).
\end{verbatim}

The \verb|get_feed| predicate retrieves a follower's feed by name.

\subsection{Feed Server}

The feed server processes a command stream, maintaining the follower list:

\begin{verbatim}
serve_feed([post(Content)|Cmds], Fs, Fs2?) :-
    ground(Content?) |
    broadcast(Content?, Fs?, Fs1),
    serve_feed(Cmds?, Fs1?, Fs2).
serve_feed([subscribe(Name)|Cmds], Fs, Fs2?) :-
    make_feed(Feed),
    serve_feed(Cmds?, [(Name?, Feed?)|Fs?], Fs2).
serve_feed([], Fs, Fs?).
\end{verbatim}

The server handles two commands:
\begin{itemize}
\item \verb|subscribe(Name)|: Creates a new feed for the subscriber and adds them to the follower list
\item \verb|post(Content)|: Broadcasts content to all current followers
\end{itemize}

The \verb|ground(Content?)| guard ensures posts are fully formed before distribution.

\subsection{The Play}

The play demonstrates Alice running a feed with Bob and Carol as subscribers:

\begin{verbatim}
alice(Commands?, Followers, FinalFollowers?) :-
    serve_feed(Commands, Followers?, FinalFollowers).

bob_receive(feed([Post1, Post2|_]), result(Post1?, Post2?)).

carol_receive(feed([Post1, Post2|_]), result(Post1?, Post2?)).

verify(result(P1, P2), result(P3, P4)) :-
    check(P1?, P2?, P3?, P4?).

check(second_post, hello_world, second_post, hello_world).

play_feed :-
    alice([subscribe(bob), subscribe(carol),
           post(hello_world), post(second_post)], [], Followers),
    play_continue(Followers?).

play_continue(Followers) :-
    ground(Followers?) |
    get_feed(bob, Followers?, BobFeed),
    get_feed(carol, Followers?, CarolFeed),
    bob_receive(BobFeed?, BobResult),
    carol_receive(CarolFeed?, CarolResult),
    verify(BobResult?, CarolResult?).
\end{verbatim}

The command stream subscribes Bob, then Carol, then posts two messages. The \verb|play_continue| predicate uses \verb|ground(Followers?)| to wait until all commands are processed before extracting feeds. Both Bob and Carol receive both posts.

\subsection{Execution Trace}

\begin{verbatim}
?- play_feed.
serve_feed([subscribe(bob), subscribe(carol),
            post(hello_world), post(second_post)], [], Fs) :-
    make_feed(Feed), serve_feed(...)
make_feed(feed([])) :- true
serve_feed([subscribe(carol), post(...), ...], [(bob, feed([]))|[]], Fs) :-
    make_feed(Feed), serve_feed(...)
make_feed(feed([])) :- true
serve_feed([post(hello_world), post(second_post)],
           [(carol, feed([]))|[(bob, feed([]))|[]]], Fs) :-
    broadcast(hello_world, ...), serve_feed(...)
broadcast(hello_world, ...) :- extend_feed(...), broadcast(...)
extend_feed(hello_world, feed([]), feed([hello_world])) :- true
...
broadcast(second_post, ...) :- extend_feed(...), broadcast(...)
extend_feed(second_post, feed([hello_world]),
            feed([second_post, hello_world])) :- true
...
play_continue([(carol, feed([second_post, hello_world]))|
              [(bob, feed([second_post, hello_world]))|[]]]) :- ...
get_feed(bob, ..., feed([second_post, hello_world])) :- true
get_feed(carol, ..., feed([second_post, hello_world])) :- true
bob_receive(feed([second_post, hello_world]),
            result(second_post, hello_world)) :- true
carol_receive(feed([second_post, hello_world]),
              result(second_post, hello_world)) :- true
check(second_post, hello_world, second_post, hello_world) :- true
-> succeeds
\end{verbatim}

The trace shows:
\begin{enumerate}
\item Bob subscribes, receiving an empty feed
\item Carol subscribes, receiving an empty feed
\item \verb|hello_world| is broadcast to both feeds
\item \verb|second_post| is broadcast to both feeds
\item Both receive \verb|feed([second_post, hello_world])|---newest first
\item Verification confirms identical results
\end{enumerate}

%% ============================================
%% Section 3: Groups
%% ============================================

\section{Groups}
\label{sec:groups}

A \emph{group} enables multiple members to communicate. We present two designs: manager-based groups where a central manager serializes all messages, and groups via interlaced streams where members post independently without a bottleneck.

\subsection{Manager-Based Groups}
\label{sec:manager-groups}

In manager-based groups, all messages flow through a manager who serializes and distributes them. This ensures all members see messages in the same order.

\subsubsection{The Manager}

The manager processes commands, maintaining a member list and message feed:

\begin{verbatim}
manager(Commands?, Feed?, Members?) :-
    manage(Commands, [], [], Feed, Members).

manage([invite(Name)|Cmds], Members, Feed, Feed1?, Members1?) :-
    manage(Cmds?, [(Name?, [])|Members?], Feed?, Feed1, Members1).

manage([post(From, Content)|Cmds], Members, Feed, Feed1?, Members1?) :-
    ground(From?), ground(Content?) |
    prepend_all(msg(From?, Content?), Members?, Members2),
    manage(Cmds?, Members2?, [msg(From?, Content?)|Feed?], Feed1, Members1).

manage([], Members, Feed, Feed?, Members?).
\end{verbatim}

The manager handles two commands:
\begin{itemize}
\item \verb|invite(Name)|: Adds a member with an empty message stream
\item \verb|post(From, Content)|: Broadcasts to all members, records in feed
\end{itemize}

The \verb|ground| guards ensure messages are complete before distribution.

\subsubsection{Broadcasting}

The \verb|prepend_all| predicate distributes a message to all member streams:

\begin{verbatim}
prepend_all(_, [], []).
prepend_all(Msg, [(Name, Stream)|Ms], [(Name?, [Msg?|Stream?])|Ms1?]) :-
    ground(Msg?) |
    prepend_all(Msg?, Ms?, Ms1).
\end{verbatim}

Each member's stream receives the message prepended to their existing messages.

\subsubsection{The Play}

\begin{verbatim}
get_member_stream(Name, [(Name?, Stream)|_], Stream?).
get_member_stream(Name?, [_|Ms], Stream?) :-
    get_member_stream(Name, Ms?, Stream).

play_group_manager :-
    manager([invite(bob), invite(carol),
             post(bob, hello_from_bob),
             post(carol, hello_from_carol)], Feed, Members),
    play_continue(Feed?, Members?).

play_continue(Feed, Members) :-
    ground(Feed?), ground(Members?) |
    get_member_stream(bob, Members?, BobStream),
    get_member_stream(carol, Members?, CarolStream),
    verify_group(Feed?, BobStream?, CarolStream?).

verify_group(Feed, BobRcvd, CarolRcvd) :-
    check_feed(Feed?),
    check_streams(BobRcvd?, CarolRcvd?).

check_feed([msg(carol, hello_from_carol), msg(bob, hello_from_bob)]).

check_streams([msg(carol, hello_from_carol), msg(bob, hello_from_bob)],
              [msg(carol, hello_from_carol), msg(bob, hello_from_bob)]).
\end{verbatim}

The play invites Bob and Carol, then posts messages from each. The \verb|play_continue| predicate waits for all commands to complete before verification.

\subsubsection{Execution Trace}

\begin{verbatim}
?- play_group_manager.
manage([invite(bob), ...], [], [], Feed, Members) :-
    manage([invite(carol), ...], [(bob, [])|[]], [], ...)
manage([invite(carol), ...], [(bob, [])], [], ...) :-
    manage([post(...), ...], [(carol, [])|[(bob, [])]], [], ...)
manage([post(bob, hello_from_bob), ...], [...], [], ...) :-
    prepend_all(msg(bob, hello_from_bob), [...], Members2), ...
prepend_all(msg(bob, hello_from_bob), [(carol, [])|(bob, [])], ...) :- ...
...
check_feed([msg(carol, hello_from_carol), msg(bob, hello_from_bob)]) :- true
check_streams([msg(carol, ...), msg(bob, ...)],
              [msg(carol, ...), msg(bob, ...)]) :- true
-> succeeds
\end{verbatim}

Both Bob and Carol receive \verb|[msg(carol, hello_from_carol), msg(bob, hello_from_bob)]|---identical message sequences. The manager serializes all posts, ensuring total ordering.

\subsubsection{Limitations}

The manager is a bottleneck: all messages must flow through a single point. For high-throughput groups or when the manager becomes unavailable, this design limits scalability and availability.

\subsection{Groups via Interlaced Streams}
\label{sec:interlaced-groups}

In interlaced stream groups, each member maintains their own message stream. Members observe each other's streams and reference the current \emph{tips}---the most recent unextended blocks. This creates a partial ordering without requiring a central sequencer.

\subsubsection{Interlacing}

Each member produces blocks containing their message and references to observed tips:

\begin{verbatim}
interlace([Payload|Payloads], [block(Payload?, Tips?)|Stream?], Others) :-
    collect_tips(Others?, Tips, Others1),
    interlace(Payloads?, Stream, Others1?).
interlace([], [], _).
\end{verbatim}

For each payload, \verb|interlace| collects tips from other members' streams, constructs a block, and continues with the remaining payloads.

\subsubsection{Tip Collection}

\begin{verbatim}
collect_tips([[Block|Bs]|Others], [Block?|Tips?], [Bs?|Others1?]) :-
    unknown(Bs?) |
    collect_tips(Others?, Tips, Others1).
collect_tips([[_|Bs]|Others], Tips?, [Bs?|Others1?]) :-
    otherwise |
    collect_tips(Others?, Tips, Others1).
collect_tips([], [], []).
\end{verbatim}

The \verb|unknown(Bs?)| guard detects unbound stream tails---positions not yet extended. Such blocks are current tips and get included in the reference list. Already-extended blocks are skipped.

\subsubsection{Member Process}

\begin{verbatim}
member(Name, Messages?, MyStream?, OtherStreams?) :-
    tag_messages(Name?, Messages, Tagged),
    interlace(Tagged?, MyStream, OtherStreams).

tag_messages(Name, [Msg|Msgs], [msg(Name?, Msg?)|Tagged?]) :-
    tag_messages(Name?, Msgs?, Tagged).
tag_messages(_, [], []).
\end{verbatim}

Each member tags their messages with their name and interlaces with other members' streams.

\subsubsection{The Play}

\begin{verbatim}
play_group_interlaced :-
    member(alice, [hello, world], AliceStream, [BobStream?, CarolStream?]),
    member(bob, [hi, there], BobStream, [AliceStream?, CarolStream?]),
    member(carol, [hey, all], CarolStream, [AliceStream?, BobStream?]),
    verify_interlaced(AliceStream?, BobStream?, CarolStream?).

verify_interlaced(AliceStream, BobStream, CarolStream) :-
    check_has_blocks(AliceStream?),
    check_has_blocks(BobStream?),
    check_has_blocks(CarolStream?),
    report_success.

check_has_blocks([block(_, _)|_]).

report_success.
\end{verbatim}

Alice, Bob, and Carol each produce two messages. Each member observes the other two members' streams and includes tips in their blocks.

\subsubsection{Execution Trace}

\begin{verbatim}
?- play_group_interlaced.
member(alice, [hello, world], AliceStream, [BobStream?, CarolStream?]) :- ...
member(bob, [hi, there], BobStream, [AliceStream?, CarolStream?]) :- ...
member(carol, [hey, all], CarolStream, [AliceStream?, BobStream?]) :- ...
...
AliceStream = [block(msg(alice, hello), []),
               block(msg(alice, world), [])]
BobStream = [block(msg(bob, hi), [block(msg(alice, hello), [])]),
             block(msg(bob, there), [block(msg(alice, world), [])])]
CarolStream = [block(msg(carol, hey), [block(msg(bob, hi), [...])]),
               block(msg(carol, hey), [...])]
-> succeeds
\end{verbatim}

Alice produces first (no tips available). Bob's blocks reference Alice's tips. Carol's blocks reference Bob's (and transitively Alice's). The tip references create a partial ordering reflecting causal dependencies.

\subsubsection{Properties}

\begin{description}
\item[No Bottleneck] Members produce blocks independently; no single point of failure.
\item[Partial Ordering] Concurrent posts remain unordered relative to each other. Causal order is captured by tip references.
\item[Scalability] Adding members does not increase load on any single member proportionally.
\item[Consistency] All members eventually observe all blocks, though potentially in different orders.
\end{description}

\subsubsection{Comparison}

\begin{center}
\begin{tabular}{lcc}
\textbf{Property} & \textbf{Manager-Based} & \textbf{Interlaced} \\
\hline
Message ordering & Total & Partial \\
Bottleneck & Manager & None \\
Fault tolerance & Manager failure fatal & Resilient \\
Complexity & Simple & Higher \\
\end{tabular}
\end{center}

Manager-based groups suit small, synchronous communication. Interlaced stream groups suit large-scale, asynchronous scenarios where availability and scalability matter more than total ordering.

%% ============================================
%% Section 4: Child-Safe Social Networking
%% ============================================

\section{Child-Safe Social Networking}
\label{sec:child-safe}

Child-Safe Social Networking (CSSN) empowers parents to control their children's online connections. Children can befriend only with mutual parental approval. This section presents the core protocol.

\subsection{Architecture}

CSSN operates on two tiers:
\begin{itemize}
\item \textbf{Parent tier}: Parents form a social network among themselves using the standard social graph protocol.
\item \textbf{Child tier}: Children's apps are subordinate to their parents' apps. A child can connect only to children whose parents have approved the connection.
\end{itemize}

The key invariant: two children can befriend only if their parents are friends and both parents approve.

\subsection{Approval Protocol}

When Child-Smith wants to befriend Child-Jones:

\begin{enumerate}
\item Child-Smith requests befriending through their parent app
\item Parent-Smith sends an approval request to Parent-Jones (through their friend channel)
\item Parent-Jones decides whether to approve
\item If approved, the response flows back to Parent-Smith
\item Both parents establish the child channel
\end{enumerate}

The approval request carries an embedded response variable, enabling the approving parent to communicate their decision directly.

\subsection{Implementation}

\subsubsection{Response Binding}

\begin{verbatim}
bind_resp(Resp?, Resp).
\end{verbatim}

The \verb|bind_resp| helper binds a reader (extracted from a received message) to a value. This enables the receiving parent to respond through the embedded variable.

\subsubsection{Requesting Parent}

\begin{verbatim}
parent_smith([approval_request(smith, child_smith, Resp)|_], Result?) :-
    smith_wait(Resp?, Result).

smith_wait(Resp, Result?) :-
    known(Resp?) |
    smith_done(Resp?, Result).

smith_done(approved, result(approved, channel_ready)).
\end{verbatim}

Parent-Smith sends an \verb|approval_request| containing their identity, the child's identity, and a fresh response variable \verb|Resp|. The \verb|known(Resp?)| guard suspends until Parent-Jones binds the response. On approval, the result indicates the channel is ready.

\subsubsection{Approving Parent}

\begin{verbatim}
parent_jones([approval_request(FromParent, Child, Resp)|_], Decision?) :-
    bind_resp(Resp?, approved),
    jones_done(FromParent?, Child?, Decision).

jones_done(FromParent, Child, approved(FromParent?, Child?)).
\end{verbatim}

Parent-Jones receives the request, extracts the embedded response variable, and binds it to \verb|approved|. In a complete system, this would involve consulting the user; here we auto-approve for demonstration.

\subsection{The Play}

\begin{verbatim}
play_child_safe :-
    parent_smith(StoJ, SmithResult),
    parent_jones(StoJ?, JonesDecision),
    verify_child_safe(SmithResult?, JonesDecision?).

verify_child_safe(result(approved, channel_ready),
                  approved(smith, child_smith)) :-
    report_success.

report_success.
\end{verbatim}

The play connects Parent-Smith's output to Parent-Jones's input. Parent-Smith sends the approval request; Parent-Jones approves by binding the embedded response variable; Parent-Smith's \verb|known| guard succeeds; verification confirms success.

\subsection{Execution Trace}

\begin{verbatim}
?- play_child_safe.
parent_smith([approval_request(smith, child_smith, Resp)|_], Result) :-
    smith_wait(Resp?, Result)
parent_jones([approval_request(smith, child_smith, Resp)|_], Decision) :-
    bind_resp(Resp?, approved), jones_done(smith, child_smith, Decision)
smith_wait(Resp?, Result) -> suspended
bind_resp(Resp?, approved) :- true
jones_done(smith, child_smith, Decision) :- true
smith_wait(approved, Result) :- smith_done(approved, Result)
smith_done(approved, result(approved, channel_ready)) :- true
verify_child_safe(result(approved, channel_ready),
                  approved(smith, child_smith)) :- report_success
report_success :- true
-> succeeds
\end{verbatim}

The trace shows:
\begin{enumerate}
\item Parent-Smith sends the request with embedded \verb|Resp|
\item \verb|smith_wait| suspends on \verb|known(Resp?)|
\item Parent-Jones binds \verb|Resp| to \verb|approved| via \verb|bind_resp|
\item \verb|smith_wait| resumes, producing the success result
\item Verification confirms both sides agree
\end{enumerate}

\subsection{Security Properties}

\begin{description}
\item[Parental Control] Children cannot connect without parental approval---the parent app mediates all connection requests.
\item[Mutual Consent] Both parents must approve; a single parent cannot force a connection.
\item[No Third Party] Communication occurs directly between parent apps over their friend channel; no platform intermediary.
\item[Verifiable Identity] Parents know each other through the social graph; they can verify children's identities through trusted means.
\end{description}

\subsection{Extensions}

A complete CSSN implementation would include:
\begin{itemize}
\item User consultation before approval (not auto-approve)
\item Rejection handling with reason messages
\item Child channel establishment after mutual approval
\item Parental monitoring capabilities
\item Age-appropriate content filtering
\end{itemize}

The core protocol demonstrated here---embedded response variables for cross-agent communication with parental gatekeeping---forms the foundation for these extensions.

%% ============================================
%% Section 5: Exercises
%% ============================================

\section{Exercises}
\label{sec:social-networks-exercises}

[TO BE DEVELOPED]
