% chapters/social_networks.tex - Social Networks

\chapter{Social Networks}
\label{ch:social-networks}

This chapter presents grassroots social networking constructs, including security mechanisms, stream replication for feed distribution, and follower management.

%% ============================================
%% Section 1: Security Mechanisms
%% ============================================

\section{Security Mechanisms}
\label{sec:security-mechanisms}

\GLP provides guard predicates for inspecting attestations on received messages, enabling agents to verify the provenance and authenticity of data.

\subsection{Attestation Guards}
\label{sec:attestation-guards}

\begin{verbatim}
process_message(Msg, Result?) :-
    attestation(Msg, att(Agent, Module)),
    trusted_module(Module?) |
    handle_verified(Msg?, Agent?, Result).

process_message(Msg, rejected) :-
    attestation(Msg, att(_, Module)),
    \+ trusted_module(Module?) |
    true.
\end{verbatim}

The \verb|attestation(X, Info)| guard succeeds if term \verb|X| carries an attestation, binding \verb|Info| to \verb|att(Agent, Module)| containing the attesting agent's public key and module identifier. For locally-produced terms, \verb|Agent| binds to the distinguished constant \verb|self|.

The \verb|module(M)| guard binds \verb|M| to the identifier of the currently executing module. Agents use this to determine their own module identity when evaluating compatibility:

\begin{verbatim}
negotiate_protocol(Other, Result?) :-
    module(MyModule),
    attestation(Other, att(_, OtherModule)),
    compatible(MyModule?, OtherModule?) |
    Result = accept.
\end{verbatim}

These guards enable security decisions to be made at the language level, within committed-choice clause selection, rather than requiring external verification mechanisms.

\subsection{Stream Security Properties}
\label{sec:stream-security}

Authenticated \GLP streams achieve blockchain-like security through language-level guarantees:

\begin{enumerate}
\item \textbf{Immutability}: Once stream element \verb|[X|Xs]| is created with \verb|X| bound to value $T$, single-assignment semantics prevents any subsequent assignment to \verb|X|.

\item \textbf{Unforkability}: The SRSW invariant ensures each writer \verb|Xs| has exactly one occurrence. Attempting two continuations \verb|Xs=[Y|Ys]| and \verb|Xs=[Z|Zs]| would require two occurrences of writer \verb|Xs|, violating SRSW.

\item \textbf{Non-repudiation}: Stream extensions carry attestations $(Xs\!:=\![Y|Ys])_{M,p,q}$. The signature by agent $p$ provides cryptographic proof of authorship.

\item \textbf{Acyclicity}: The occurs check prevents a writer from being bound to a term containing its paired reader, ensuring strict temporal ordering.
\end{enumerate}

These properties emerge from \GLP's core semantics rather than requiring additional cryptographic protocols.

\paragraph{Cooperative Extension.} Only the holder of a stream's tail writer can extend it:

\begin{verbatim}
extend_stream([H?|T], H, T).
\end{verbatim}

The caller provides the head value \verb|H| and receives the new tail writer \verb|T| for subsequent extension. This enables cooperative stream production through explicit handover (Section~\ref{sec:cooperative-producers}).

%% ============================================
%% Section 2: Feed Distribution
%% ============================================

\section{Feed Distribution}
\label{sec:feed}

[TO BE DEVELOPED]

\subsection{Non-Ground Replication}
\label{sec:nonground-replication}

Distributing incrementally-constructed streams to multiple recipients requires replication. The replicator handles streams that may contain uninstantiated readers, suspending until values become available:

\begin{verbatim}
replicate2(X, X?, X?) :- ground(X) | true.
replicate2(Xs, [Y1?|Ys1?], [Y2?|Ys2?]) :-
    Xs? = [X|Xs1] |
    replicate2(X?, Y1, Y2),
    replicate2(Xs1?, Ys1, Ys2).
\end{verbatim}

The first clause handles ground terms: when \verb|X| is fully instantiated, it is copied directly to both outputs. The second clause handles list structures: it matches the input against \verb|[X|Xs1]|, recursively replicates the head \verb|X| to both output heads, and recurses on the tails.

The guard \verb|Xs? = [X|Xs1]| suspends until the input stream's head is available. This allows replication of streams as they are incrementally produced, with each element replicated as soon as it appears.

\paragraph{Generalization.} The binary replicator extends naturally to $n$ outputs:

\begin{verbatim}
replicate3(X, X?, X?, X?) :- ground(X) | true.
replicate3(Xs, [Y1?|Ys1?], [Y2?|Ys2?], [Y3?|Ys3?]) :-
    Xs? = [X|Xs1] |
    replicate3(X?, Y1, Y2, Y3),
    replicate3(Xs1?, Ys1, Ys2, Ys3).
\end{verbatim}

This pattern is essential for feed distribution where a single producer's stream must reach multiple followers.
