% chapters/social_networks.tex - Social Networks

\chapter{Social Networks}
\label{ch:social-networks}

This chapter presents grassroots social networking applications built upon the social graph foundation (Chapter~\ref{ch:social-graph}). We develop direct messaging between friends, feed distribution with followers, group messaging, and child-safe social networking.

Throughout this chapter, we assume agents are already connected via the social graph protocol---they have established bidirectional friend channels through cold-call or friend-mediated introduction. The applications here use these existing channels to build higher-level communication structures.

%% ============================================
%% Section 1: Direct Messaging
%% ============================================

\section{Direct Messaging}
\label{sec:direct-messaging}

Friends connected via the social graph share a \emph{control channel} for protocol messages. For ongoing conversations, they establish a separate \emph{direct messaging (DM) channel}---dedicated to private communication, independent of protocol traffic.

\subsection{Channel Primitives}

A DM channel is a bidirectional channel created with \verb|new_channel|:

\begin{verbatim}
new_channel(ch(Xs?, Ys), ch(Ys?, Xs)).
\end{verbatim}

This creates two channel endpoints with cross-connected streams. If Alice holds \verb|ch(Xs?, Ys)| and Bob holds \verb|ch(Ys?, Xs)|, then Alice writes to \verb|Ys| and reads from \verb|Xs|, while Bob writes to \verb|Xs| and reads from \verb|Ys|.

Sending and receiving on a channel:

\begin{verbatim}
dm_send(Msg, ch(In, [Msg?|Out?]), ch(In?, Out)).

dm_receive(Msg?, ch([Msg|In], Out?), ch(In?, Out)).
\end{verbatim}

The \verb|dm_send| predicate appends a message to the output stream, returning the updated channel. The \verb|dm_receive| predicate extracts a message from the input stream.

\subsection{Response Binding}

When establishing a channel, one party creates both endpoints and sends one to the other through a response variable. Since the response variable extracted from an incoming message becomes a reader, we use explicit unification:

\begin{verbatim}
bind_resp(Resp, Ch) :- Resp = Ch?.
\end{verbatim}

This binds the reader \verb|Resp| to the channel \verb|Ch|.

\subsection{The DM Protocol}

Alice initiates by sending a request containing a fresh response variable through her friend channel. Bob receives the request, creates the channel pair, binds one endpoint to the response variable, and keeps the other:

\begin{verbatim}
alice(FriendOut, FriendIn?, AliceResult?) :-
    FriendOut = [dm_request(Resp)|_],
    alice_continue(Resp?, FriendIn, AliceResult).

alice_continue(DMCh, _, result(sent, Reply?)) :-
    known(DMCh?) |
    dm_send(hello_bob, DMCh?, DMCh1),
    dm_receive(Reply, DMCh1?, _).
\end{verbatim}

Alice sends \verb|dm_request(Resp)| on the friend channel, then waits for \verb|Resp| to become bound. The \verb|known(DMCh?)| guard suspends until Bob responds. Once the DM channel arrives, Alice sends a greeting and waits for a reply.

\begin{verbatim}
bob([dm_request(Resp)|_], _, BobResult?) :-
    new_channel(BobDM, AliceDM),
    bind_resp(Resp?, AliceDM?),
    bob_continue(BobDM?, BobResult).

bob_continue(DMCh, result(Msg?, replied)) :-
    dm_receive(Msg, DMCh?, DMCh1),
    dm_send(hello_alice, DMCh1?, _).
\end{verbatim}

Bob pattern-matches the request in his clause head, creates a channel pair, binds Alice's endpoint to her response variable, then continues with his own endpoint. He receives Alice's message and sends a reply.

\subsection{The Play}

The complete play connects Alice and Bob through a shared friend channel:

\begin{verbatim}
verify(result(sent, Reply), result(Msg, replied)) :-
    report(Msg?, Reply?).

report(hello_bob, hello_alice).

play_dm :-
    alice(FriendOut, FriendIn?, AliceResult),
    bob(FriendOut?, FriendIn, BobResult),
    verify(AliceResult?, BobResult?).
\end{verbatim}

The friend channel connects Alice's output (\verb|FriendOut|) to Bob's input (\verb|FriendOut?|), and Bob's output (\verb|FriendIn|) to Alice's input (\verb|FriendIn?|). The \verb|verify| predicate confirms successful message exchange.

\subsection{Execution Trace}

\begin{verbatim}
?- play_dm.
alice(FriendOut, FriendIn?, AliceResult) :-
    alice_continue(Resp?, FriendIn, AliceResult)
bob([dm_request(Resp)|_], FriendIn, BobResult) :-
    new_channel(BobDM, AliceDM),
    bind_resp(Resp?, AliceDM?),
    bob_continue(BobDM?, BobResult)
new_channel(BobDM, AliceDM) :- true
bind_resp(Resp?, ch(X1?, X2)) :- true
bob_continue(ch(X2?, X1), BobResult) :-
    dm_receive(Msg, ch(X2?, X1), DMCh1),
    dm_send(hello_alice, DMCh1?, _)
alice_continue(ch(X1?, X2), FriendIn, AliceResult) :-
    dm_send(hello_bob, ch(X1?, X2), AliceCh1),
    dm_receive(Reply, AliceCh1?, _)
dm_send(hello_bob, ch(X1?, X2), AliceCh1) :- true
dm_receive(Msg, ch([hello_bob|X3?], X1), DMCh1) :- true
dm_send(hello_alice, ch(X3?, X4), _) :- true
dm_receive(Reply, ch([hello_alice|X5?], X3), _) :- true
report(hello_bob, hello_alice) :- true
-> succeeds
\end{verbatim}

The trace shows the complete protocol:
\begin{enumerate}
\item Alice sends \verb|dm_request(Resp)| on the friend channel
\item Bob receives the request, creates a channel pair with \verb|new_channel|
\item Bob binds Alice's endpoint to her response variable via \verb|bind_resp|
\item Alice's \verb|known| guard succeeds; she sends \verb|hello_bob|
\item Bob receives \verb|hello_bob| and replies with \verb|hello_alice|
\item Alice receives the reply
\item \verb|report(hello_bob, hello_alice)| confirms the exchange
\end{enumerate}

%% ============================================
%% Section 2: Feeds and Followers
%% ============================================

\section{Feeds and Followers}
\label{sec:feeds-followers}

A \emph{feed} is a stream of posts produced by an author and distributed to \emph{followers}. This section develops the feed server---processing subscriptions and broadcasting posts to all subscribers.

\subsection{Feed Structure}

A feed is represented as \verb|feed(Posts)| where \verb|Posts| is a list of posts, newest first:

\begin{verbatim}
make_feed(feed([])).

extend_feed(Post, feed(Xs), feed([Post?|Xs?])).
\end{verbatim}

The \verb|make_feed| predicate creates an empty feed. The \verb|extend_feed| predicate prepends a new post to an existing feed.

\subsection{Broadcasting with Ground Guard}

The \verb|ground| guard enables distributing a single post to multiple followers. Without this guard, sending a post to multiple output streams would violate SRSW---each follower's stream would need its own writer occurrence of the post.

\begin{verbatim}
broadcast(_, [], []).
broadcast(Post, [(Name, Feed)|Fs], [(Name?, Feed1?)|Fs1?]) :-
    ground(Post?) |
    extend_feed(Post?, Feed?, Feed1),
    broadcast(Post?, Fs?, Fs1).
\end{verbatim}

The \verb|ground(Post?)| guard suspends until the post is fully instantiated, then permits reading \verb|Post?| multiple times---once per follower. Each follower's feed is extended with the post.

\subsection{Follower Management}

Followers are stored as an association list mapping names to feeds:

\begin{verbatim}
get_feed(Name, [(Name?, Feed)|_], Feed?).
get_feed(Name?, [_|Fs], Feed?) :- get_feed(Name, Fs?, Feed).
\end{verbatim}

The \verb|get_feed| predicate retrieves a follower's feed by name.

\subsection{Feed Server}

The feed server processes a command stream, maintaining the follower list:

\begin{verbatim}
serve_feed([post(Content)|Cmds], Fs, Fs2?) :-
    ground(Content?) |
    broadcast(Content?, Fs?, Fs1),
    serve_feed(Cmds?, Fs1?, Fs2).
serve_feed([subscribe(Name)|Cmds], Fs, Fs2?) :-
    make_feed(Feed),
    serve_feed(Cmds?, [(Name?, Feed?)|Fs?], Fs2).
serve_feed([], Fs, Fs?).
\end{verbatim}

The server handles two commands:
\begin{itemize}
\item \verb|subscribe(Name)|: Creates a new feed for the subscriber and adds them to the follower list
\item \verb|post(Content)|: Broadcasts content to all current followers
\end{itemize}

The \verb|ground(Content?)| guard ensures posts are fully formed before distribution.

\subsection{The Play}

The play demonstrates Alice running a feed with Bob and Carol as subscribers:

\begin{verbatim}
alice(Commands?, Followers, FinalFollowers?) :-
    serve_feed(Commands, Followers?, FinalFollowers).

bob_receive(feed([Post1, Post2|_]), result(Post1?, Post2?)).

carol_receive(feed([Post1, Post2|_]), result(Post1?, Post2?)).

verify(result(P1, P2), result(P3, P4)) :-
    check(P1?, P2?, P3?, P4?).

check(second_post, hello_world, second_post, hello_world).

play_feed :-
    alice([subscribe(bob), subscribe(carol),
           post(hello_world), post(second_post)], [], Followers),
    play_continue(Followers?).

play_continue(Followers) :-
    ground(Followers?) |
    get_feed(bob, Followers?, BobFeed),
    get_feed(carol, Followers?, CarolFeed),
    bob_receive(BobFeed?, BobResult),
    carol_receive(CarolFeed?, CarolResult),
    verify(BobResult?, CarolResult?).
\end{verbatim}

The command stream subscribes Bob, then Carol, then posts two messages. The \verb|play_continue| predicate uses \verb|ground(Followers?)| to wait until all commands are processed before extracting feeds. Both Bob and Carol receive both posts.

\subsection{Execution Trace}

\begin{verbatim}
?- play_feed.
serve_feed([subscribe(bob), subscribe(carol),
            post(hello_world), post(second_post)], [], Fs) :-
    make_feed(Feed), serve_feed(...)
make_feed(feed([])) :- true
serve_feed([subscribe(carol), post(...), ...], [(bob, feed([]))|[]], Fs) :-
    make_feed(Feed), serve_feed(...)
make_feed(feed([])) :- true
serve_feed([post(hello_world), post(second_post)],
           [(carol, feed([]))|[(bob, feed([]))|[]]], Fs) :-
    broadcast(hello_world, ...), serve_feed(...)
broadcast(hello_world, ...) :- extend_feed(...), broadcast(...)
extend_feed(hello_world, feed([]), feed([hello_world])) :- true
...
broadcast(second_post, ...) :- extend_feed(...), broadcast(...)
extend_feed(second_post, feed([hello_world]),
            feed([second_post, hello_world])) :- true
...
play_continue([(carol, feed([second_post, hello_world]))|
              [(bob, feed([second_post, hello_world]))|[]]]) :- ...
get_feed(bob, ..., feed([second_post, hello_world])) :- true
get_feed(carol, ..., feed([second_post, hello_world])) :- true
bob_receive(feed([second_post, hello_world]),
            result(second_post, hello_world)) :- true
carol_receive(feed([second_post, hello_world]),
              result(second_post, hello_world)) :- true
check(second_post, hello_world, second_post, hello_world) :- true
-> succeeds
\end{verbatim}

The trace shows:
\begin{enumerate}
\item Bob subscribes, receiving an empty feed
\item Carol subscribes, receiving an empty feed
\item \verb|hello_world| is broadcast to both feeds
\item \verb|second_post| is broadcast to both feeds
\item Both receive \verb|feed([second_post, hello_world])|---newest first
\item Verification confirms identical results
\end{enumerate}

%% ============================================
%% Section 3: Groups
%% ============================================

\section{Groups}
\label{sec:groups}

[TO BE DEVELOPED]

%% ============================================
%% Section 4: Child-Safe Social Networking
%% ============================================

\section{Child-Safe Social Networking}
\label{sec:child-safe}

[TO BE DEVELOPED]

%% ============================================
%% Section 5: Exercises
%% ============================================

\section{Exercises}
\label{sec:social-networks-exercises}

[TO BE DEVELOPED]
