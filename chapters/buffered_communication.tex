% chapters/buffered_communication.tex - Buffered Communication

\chapter{Buffered Communication}
\label{ch:buffered-communication}

This chapter explores advanced stream programming patterns including bounded buffers for flow control, network switches for message routing, and channels as a generalization of streams.

\section{The Back-Pressure Problem}
\label{sec:backpressure-problem}

In producer-consumer systems, a fast producer can overwhelm a slow consumer. Without flow control, messages accumulate unboundedly, exhausting memory. \emph{Back-pressure} is the mechanism by which consumers signal producers to slow down.

In \GLP, the standard stream communication pattern:
\begin{verbatim}
producer([msg1|S?], ...) :- producer(S, ...).
consumer([M|S], ...) :- process(M?), consumer(S?, ...).
\end{verbatim}

offers no back-pressure---the producer can emit messages as fast as it runs, regardless of consumer speed. The solution is \emph{bounded buffers}.

\section{Bounded Buffers}
\label{sec:bounded-buffer}

A bounded buffer limits how far ahead a producer can get. When the buffer is full, the producer suspends until the consumer makes room.

\subsection{Difference-List Bounded Buffer}
\label{sec:buffer-difference-list}

We represent the buffer as a difference list \verb|Head--Tail|, where \verb|Head| is the read end and \verb|Tail| is the write end:

\begin{verbatim}
%% Send suspends when buffer is full
send(Msg, [Msg|NBuf?], NBuf).

%% Receive creates a new slot, allowing more sends
receive(Msg, [Msg|NBuf]--[_|NTail?], NBuf--NTail).

%% Close the buffer
close([end_of_stream|_]).
closed(end_of_stream).
\end{verbatim}

The \verb|--| operator is simply a binary functor with no special meaning---we use it to pair the read and write ends of the buffer. When the goal \verb|receive(I, Buf?, NBuf)| unifies with the head \verb|receive(Msg, [Msg|NBuf]--[_|NTail?], NBuf--NTail)|, the second argument demonstrates compound term unification (Appendix~\ref{appendix:compound-unification}): the goal's \verb|Buf?| must match the structure \verb|[...]--[...]|. If \verb|Buf?| is unbound (its paired writer not yet assigned), unification suspends. When \verb|Buf| receives a difference-list value, the goal reactivates and unification proceeds by matching the \verb|--| functor and recursively unifying its arguments.

The key insight: \verb|receive| not only extracts a message but also extends the tail with a new slot \verb|[_|NTail?]|. This ``credits'' the producer to send one more message.

\subsection{Opening a Buffer}

The \verb|open/2| predicate creates a buffer with a specified number of slots:

\begin{verbatim}
open(0, X--X).
open(N, [_|Y]--Z) :- N > 0 | N1 := N? - 1, open(N1?, Y--Z).
\end{verbatim}

For \verb|open(3, Buf)|, we get a buffer with 3 empty slots: \verb|[_,_,_|T]--T|. The producer can \verb|send| up to 3 messages before suspending.

The base case \verb|open(0, X--X)| creates an empty buffer where both ends share the same variable. This illustrates difference list threading (Appendix~\ref{appendix:dl-unification}): the ``list'' is \verb|X| and the ``hole'' is also \verb|X|, representing an empty sequence. The recursive clause builds the buffer by prepending slots; each slot is an anonymous variable \verb|_| that will later hold a message. The threading ensures that when the read end advances past a message, the write end can fill the newly-created slot.

\subsection{Producer-Consumer Example}

A buffered stream of squares:

\begin{verbatim}
sq_num_buffered(N, Ss, Size) :-
    open(Size?, Buf--Tail),
    integers(1, N?, Buf?),
    square(Buf?--Tail, Ss).

integers(I, N, Buf) :-
    I =< N |
    J := I? + 1,
    send(I?, Buf?, NBuf),
    integers(J?, N?, NBuf?).
integers(I, N, Buf) :-
    I > N |
    close(Buf?).

square(Buf, Ss) :-
    receive(I, Buf?, NBuf),
    square2(I?, NBuf?, Ss).

square2(I, _, []) :- closed(I?) | true.
square2(I, Buf, [I2|Ss?]) :-
    number(I?) |
    I2 := I? * I?,
    square(Buf?, Ss).
\end{verbatim}

The buffer limits memory usage: at most \verb|Size| integers are buffered between producer and consumer.

\subsection{Flow Control Semantics}
\label{sec:buffer-flow-control}

The bounded buffer achieves flow control through suspension:

\begin{enumerate}
\item \textbf{Buffer not full:} \verb|send| succeeds immediately, filling a slot
\item \textbf{Buffer full:} \verb|send| attempts to unify with a full buffer and suspends
\item \textbf{Consumer receives:} \verb|receive| extends the tail, unblocking the suspended \verb|send|
\end{enumerate}

This creates a feedback loop: the consumer's consumption rate controls the producer's production rate.

\section{Network Switches}
\label{sec:network-switch}

A network switch routes messages between multiple ports based on destination. This demonstrates concurrent clause selection with multiple communication channels.

\subsection{2×2 Switch}

A switch with two input and two output ports:

\begin{verbatim}
switch2x2(In1, In2, Out1, Out2) :-
    receive(M, In1?, Ins1), send(M?, Out1?, Outs1) |
    switch2x2(Ins1?, In2?, Outs1?, Out2?).
switch2x2(In1, In2, Out1, Out2) :-
    receive(M, In2?, Ins2), send(M?, Out1?, Outs1) |
    switch2x2(In1?, Ins2?, Outs1?, Out2?).
switch2x2(In1, In2, Out1, Out2) :-
    receive(M, In1?, Ins1), send(M?, Out2?, Outs2) |
    switch2x2(Ins1?, In2?, Out1?, Outs2?).
switch2x2(In1, In2, Out1, Out2) :-
    receive(M, In2?, Ins2), send(M?, Out2?, Outs2) |
    switch2x2(In1?, Ins2?, Out1?, Outs2?).
\end{verbatim}

Each clause handles one routing decision:
\begin{itemize}
\item Input 1 → Output 1
\item Input 2 → Output 1
\item Input 1 → Output 2
\item Input 2 → Output 2
\end{itemize}

The guards \verb|receive(...), send(...)| in the clause heads ensure the clause commits only when both a message is available on an input and space is available on an output. If both outputs are full, all clauses suspend---back-pressure propagates from outputs to inputs.

\subsection{3-Way Network Switch}

A switch routing messages between three agents based on explicit destination:

\begin{verbatim}
%% Message format: msg(Destination, Content)

%% P to Q forwarding
network((P,ChP),(Q,ChQ),(R,ChR)) :-
    ground(Q), receive(ChP?,msg(Q,X),ChP1), send(ChQ?,X?,ChQ1) |
    network((P,ChP1?),(Q,ChQ1?),(R,ChR?)).

%% P to R forwarding
network((P,ChP),(Q,ChQ),(R,ChR)) :-
    ground(R), receive(ChP?,msg(R,X),ChP1), send(ChR?,X?,ChR1) |
    network((P,ChP1?),(Q,ChQ?),(R,ChR1?)).

%% Q to P forwarding
network((P,ChP),(Q,ChQ),(R,ChR)) :-
    ground(P), receive(ChQ?,msg(P,X),ChQ1), send(ChP?,X?,ChP1) |
    network((P,ChP1?),(Q,ChQ1?),(R,ChR?)).

%% ... (similar clauses for Q→R, R→P, R→Q)
\end{verbatim}

The \verb|ground(Dest)| guard ensures the destination is known before routing. Messages wrap content with destination: \verb|msg(q, hello)| sends \verb|hello| to agent \verb|q|.

\section{Termination and End-of-Stream}
\label{sec:termination}

Proper termination handling ensures resources are released and downstream processes know when input is exhausted.

\subsection{End-of-Stream Markers}

The standard pattern uses a sentinel value:

\begin{verbatim}
%% Producer closes with end marker
producer([], 0).
producer([end_of_stream], N) :- N =< 0 | true.
producer([Item|Rest?], N) :- N > 0 |
    N1 := N? - 1, producer(Rest, N1?).

%% Consumer checks for end marker
consumer([]).
consumer([end_of_stream]).
consumer([Item|Rest]) :-
    Item =\= end_of_stream |
    process(Item?), consumer(Rest?).
\end{verbatim}

\subsection{Bounded Buffer Termination}

For bounded buffers, we close the buffer and check for the sentinel:

\begin{verbatim}
close([end_of_stream|_]).
closed(end_of_stream).

%% Consumer checks for closure
process_buffer(Buf, Result?) :-
    receive(Item, Buf?, NBuf),
    process_item(Item?, NBuf?, Result).

process_item(Item, _, done) :- closed(Item?) | true.
process_item(Item, Buf, Result?) :-
    number(Item?) |
    handle(Item?),
    process_buffer(Buf?, Result).
\end{verbatim}

\section{Error Handling in Streams}
\label{sec:error-handling}

Errors can propagate through streams as special messages:

\begin{verbatim}
%% Error wrapper
error(Reason)

%% Producer that may fail
producer([error(Reason)|_]) :- failure_condition |
    Reason = resource_unavailable.
producer([Item|Rest?]) :- success_condition |
    producer(Rest).

%% Consumer with error handling
consumer([]).
consumer([error(R)|_]) :- handle_error(R?).
consumer([Item|Rest]) :-
    Item =\= error(_) |
    process(Item?), consumer(Rest?).
\end{verbatim}

The error message propagates downstream, allowing each consumer to handle or propagate it.

\section{Exercises}
\label{sec:advanced-exercises}

\begin{enumerate}
\item \textbf{Bounded Buffer Size.} Experiment with different buffer sizes. What happens with size 0? Size 1? How does buffer size affect memory usage vs. parallelism?

\item \textbf{Priority Switch.} Modify the 2×2 switch to give priority to Input 1 over Input 2 when both have messages.

\item \textbf{Load Balancer.} Implement a load balancer that distributes messages from one input to multiple outputs, round-robin.

\item \textbf{Channel Merge.} Implement \verb|channel_merge(C1, C2, C3)| that merges two channels into one, preserving the partial order.

\item \textbf{Timeout.} Design a pattern for timeout handling in bounded buffers---if no message arrives within a time limit, produce a timeout error.
\end{enumerate}
