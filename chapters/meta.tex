% chapters/meta.tex - Metaprogramming

\chapter{Metaprogramming}
\label{ch:meta}

This chapter presents metaprogramming in \GLP: programs that manipulate, interpret, and transform other programs. In logic programming, programs are data: clauses are terms, goals are terms. This fundamental property enables powerful metaprogramming techniques.

\begin{quote}
\textbf{Note:} This chapter is deferred pending module support. The metainterpreter examples require a module system for proper program encoding and clause access.
\end{quote}

%% ============================================
%% Section 1: Plain Meta-Interpreter
%% ============================================

\section{Plain Meta-Interpreter}
\label{sec:plain-meta}

\subsection{Programs as Data}
\label{sec:programs-as-data}

A \GLP clause like:
\begin{verbatim}
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Xs?, Ys?, Zs).
\end{verbatim}

can be represented as a term using a \verb|reduce/2| encoding:
\begin{verbatim}
reduce(merge([X|Xs], Ys, [X?|Zs?]), merge(Xs?, Ys?, Zs)).
\end{verbatim}

This representation allows programs to examine, modify, and execute other programs.

\subsection{The Vanilla Meta-Interpreter}
\label{sec:vanilla-meta}

The simplest meta-interpreter for logic programming:

\begin{verbatim}
solve(true).
solve((A, B)) :- solve(A), solve(B).
solve(A) :- clause(A, B), solve(B).
\end{verbatim}

\subsection{The GLP Plain Meta-Interpreter}
\label{sec:glp-plain-meta}

The \GLP version uses \verb|reduce/2| encoding and adds concurrency:

\begin{verbatim}
run(true).                              % halt
run((A,B)) :- run(A?), run(B?).         % fork
run(A) :- tuple(A?) | reduce(A?, B), run(B?).  % reduce
\end{verbatim}

The \verb|tuple(A?)| guard (Appendix~\ref{appendix:guard-unification}) tests whether \verb|A?| is bound to a compound term---that is, whether we can determine which predicate is being called. Unlike \verb|ground|, which requires all subterms to be bound, \verb|tuple| succeeds as soon as the outer structure is determined. For example, \verb|tuple(merge([X|Xs], Ys, Zs))| succeeds even if \verb|X|, \verb|Xs|, \verb|Ys|, and \verb|Zs| are unbound, because the functor \verb|merge/3| is known. The guard suspends if \verb|A?| is unbound, since clause selection cannot proceed until we know which predicate to reduce. As a type guard, \verb|tuple| also permits multiple occurrences of \verb|A?| in the body (per Formal Box~\ref{formal:guards-multiple-reads}).

\paragraph{The Fork Rule.} When running a conjunction \verb|(A,B)|, we spawn two concurrent processes: \verb|run(A?)| and \verb|run(B?)|.

\paragraph{Program Encoding.} The object program is encoded as \verb|reduce/2| facts:

\begin{verbatim}
%% merge encoded for meta-interpreter
reduce(merge([X|Xs],Ys,[X?|Zs?]), merge(Xs?,Ys?,Zs)).
reduce(merge(Xs,[Y|Ys],[Y?|Zs?]), merge(Xs?,Ys?,Zs)).
reduce(merge([],[],[]), true).
\end{verbatim}

\subsection{Fail-Safe Meta-Interpreter}
\label{sec:failsafe-meta}

The plain meta-interpreter aborts on failure. The \emph{fail-safe} meta-interpreter reports failures instead:

\begin{verbatim}
run(true, []).                              % halt
run((A,B), Zs?) :-                          % fork
    run(A?, Xs), run(B?, Ys),
    merge(Xs?, Ys?, Zs).
run(fail(A), [fail(A?)]).                   % report failure
run(A, Xs?) :- tuple(A?) | reduce(A?,B), run(B?,Xs).  % reduce
\end{verbatim}

The program encoding must include a catch-all clause:
\begin{verbatim}
reduce(A, failed(A)) :- otherwise | true.
\end{verbatim}

\subsection{Certainty Factors}

A metainterpreter that computes certainty factors for derived results. Each clause in the object program has an associated certainty; the result certainty is computed by combining clause certainties.

\begin{verbatim}
reduce(Program, true, 1).
reduce(Program, (A, B), C) :-
    reduce(Program?, A?, C_of_a),
    reduce(Program?, B?, C_of_b),
    min(C_of_a?, C_of_b?, C).
reduce(Program, Goal, C) :-
    clause(Goal?, Program?, Body, Cr),
    reduce(Program?, Body?, C_of_body),
    C := Cr? * C_of_body?.

min(X, Y, X) :- X =< Y | true.
min(X, Y, Y) :- Y < X | true.
\end{verbatim}

The three clauses implement distinct certainty combination rules:

\begin{itemize}
\item \textbf{Halt}: The base case \verb|true| has certainty 1 (complete confidence).
\item \textbf{Fork}: For conjunctions, certainty is the minimum of the two branch certainties. The concurrent execution of both branches yields the more uncertain result.
\item \textbf{Reduce}: When reducing a goal using a clause, the result certainty is the product of the clause's intrinsic certainty \verb|Cr| and the body's computed certainty.
\end{itemize}

The \verb|clause/4| predicate extends the standard \verb|clause/3| with a fourth argument returning the clause's certainty factor. This enables expert system applications where rules have associated confidence levels.

\subsection{Termination Detection}
\label{sec:termination-detection}

The \emph{short-circuit} technique detects when all processes have terminated:

\begin{verbatim}
reduce(P, true, Chain--Chain?).              % halt - close circuit
reduce(P, (A, B), Left--Right) :-            % fork - split chain
    reduce(P?, A?, Left?--Middle),
    reduce(P?, B?, Middle?--Right).
reduce(P, Goal, Left--Right) :-              % reduce - pass chain
    Goal =\= true, Goal =\= (_, _),
    clause(Goal?, P?, Body) |
    reduce(P?, Body?, Left?--Right).
\end{verbatim}

Each \verb|true| (termination) closes part of the circuit. When all parallel paths terminate, the circuit closes completely.

\subsection{Program Transformation}
\label{sec:program-transformation}

\paragraph{Adding Instrumentation.}
\begin{verbatim}
run_counted(true, 0).
run_counted((A,B), N?) :-
    run_counted(A?, NA), run_counted(B?, NB),
    N := NA? + NB?.
run_counted(A, N?) :- tuple(A?) |
    reduce(A?,B), run_counted(B?, NB), N := NB? + 1.
\end{verbatim}

\paragraph{Partial Evaluation.} A meta-interpreter can partially evaluate a program:
\begin{verbatim}
pe(true, true).
pe((A,B), (PA?, PB?)) :- pe(A?, PA), pe(B?, PB).
pe(A, PA?) :- tuple(A?), reduce(A?,B) | pe(B?, PA).
pe(A, A?) :- otherwise | true.  % leave unresolved
\end{verbatim}

The \verb|otherwise| guard succeeds when no other clause matches---here, when \verb|A?| is not a compound term (either unbound or atomic). This allows the partial evaluator to preserve goals that cannot yet be reduced, leaving them for later instantiation.

%% ============================================
%% Section 2: Enhanced Meta-Interpreters
%% ============================================

\section{Enhanced Meta-Interpreters}
\label{sec:enhanced-meta}

\subsection{Tracing Meta-Interpreter}
\label{sec:tracing-meta}

A \emph{tracing} meta-interpreter records the execution history:

\begin{verbatim}
run(true, true).                               % halt
run((A,B), (TA?,TB?)) :- run(A?,TA), run(B?,TB).   % fork
run(A, ((I?:Time?):-TB?)) :- tuple(A?) |
    time(Time), reduce(A?,B,I), run(B?, TB).
\end{verbatim}

The trace records which clause was used at each step with timestamps, enabling performance profiling and debugging race conditions.

\subsection{Control Meta-Interpreter}
\label{sec:control-meta}

The \emph{control} meta-interpreter supports runtime control: suspend, resume, and abort:

\begin{verbatim}
run(true, _).                                       % halt
run((A,B), Cs) :-                                   % fork
    distribute(Cs?,Cs1,Cs2),
    run(A?,Cs1?), run(B?,Cs2?).
run(A, [suspend|Cs]) :- suspended_run(A,Cs?).       % suspend
run(A, Cs) :- tuple(A?) |                            % reduce
    distribute(Cs?,Cs1,Cs2),
    reduce(A?,B,Cs1?), run(B?,Cs2?).

suspended_run(A, [resume|Cs]) :- run(A,Cs?).        % resume
suspended_run(A, [abort|_]).                        % abort
\end{verbatim}

The control stream \verb|Cs| carries commands: \verb|suspend|, \verb|resume|, \verb|abort|.

\subsection{Snapshot Collection}
\label{sec:snapshot-meta}

The \emph{snapshot} meta-interpreter collects the current resolvent when aborted:

\begin{verbatim}
suspended_run(A, [resume|Cs], L, R?) :- run(A,Cs?,L?,R).
suspended_run(A, [abort|_], L, [A?|L?]).
\end{verbatim}

When aborted, each \verb|suspended_run| adds its goal \verb|A| to the resolvent list. This enables checkpointing: save the state of a computation for later inspection.

\subsection{Debugger Meta-Interpreter}
\label{sec:debugger-meta}

Combining tracing and control yields an interactive debugger:

\begin{verbatim}
debug(true, _, _, true).
debug((A,B), Cs, Budget, (TA?,TB?)) :-
    distribute(Cs?, Cs1, Cs2),
    split_budget(Budget?, B1, B2),
    debug(A?, Cs1?, B1?, TA),
    debug(B?, Cs2?, B2?, TB).
debug(A, [step|Cs], Budget, ((I?:A?):-TB?)) :-
    Budget? > 0, tuple(A?) |
    B1 := Budget? - 1,
    reduce(A?,B,I),
    debug(B?, Cs?, B1?, TB).
\end{verbatim}

The \verb|[step|Cs]| command advances one reduction. The budget limits total reductions.

\subsection{Abstract Interpretation}
\label{sec:abstract-interpretation}

Meta-interpreters can perform abstract interpretation---executing programs over abstract domains:

\begin{verbatim}
%% Abstract domain: pos, neg, zero, unknown
abstract_add(pos, pos, pos).
abstract_add(pos, neg, unknown).
abstract_add(zero, X, X?).
%% ... etc

abstract_run(true, _).
abstract_run((A,B), Env) :-
    abstract_run(A?, Env?),
    abstract_run(B?, Env?).
\end{verbatim}

This enables static analysis: determine properties of programs without running them on concrete inputs.

%% ============================================
%% Section 3: Debugging
%% ============================================

\section{Debugging}
\label{sec:debugging}

\subsection{Algorithmic Debugging}

Algorithmic debugging locates bugs by asking questions about the correctness of intermediate results. The debugger traverses the computation tree, asking the user whether each result is correct:

\begin{verbatim}
algo_debug(true, _, correct).
algo_debug((A,B), Oracle, Result?) :-
    algo_debug(A?, Oracle?, RA),
    algo_debug(B?, Oracle?, RB),
    combine_results(RA?, RB?, Result).
algo_debug(Goal, Oracle, Result?) :- known(Goal) |
    reduce(Goal?, Body),
    algo_debug(Body?, Oracle?, BodyResult),
    ask_oracle(Oracle?, Goal?, BodyResult?, Result).

ask_oracle(Oracle, Goal, correct, correct) :-
    query(Oracle?, is_correct(Goal?), yes) | true.
ask_oracle(Oracle, Goal, correct, buggy(Goal?)) :-
    query(Oracle?, is_correct(Goal?), no) | true.
ask_oracle(_, Goal, buggy(X), buggy(X?)).
\end{verbatim}

When the body is correct but the goal is wrong, the bug is in the clause used to reduce that goal.

\subsection{Trace-Based Debugging}

Trace-based debugging records the execution history and provides replay capabilities. The trace can be analyzed post-mortem or used for deterministic replay:

\begin{verbatim}
trace_debug(Goal, Trace?) :-
    run_traced(Goal?, [], Trace).

run_traced(true, Acc, Acc?).
run_traced((A,B), Acc, Trace?) :-
    run_traced(A?, Acc?, Acc1),
    run_traced(B?, Acc1?, Trace).
run_traced(Goal, Acc, Trace?) :- known(Goal) |
    reduce(Goal?, Body, ClauseId),
    time(T),
    run_traced(Body?, [step(T?,Goal?,ClauseId?)|Acc?], Trace).

%% Replay from trace
replay([], true).
replay([step(_,Goal,ClauseId)|Steps?], (Goal?,Rest?)) :-
    reduce_by_id(Goal?, ClauseId?, Body),
    replay(Steps?, Rest).
\end{verbatim}

The trace records timestamps, enabling analysis of timing-dependent bugs in concurrent executions.

\subsection{Declarative Debugging}

Declarative debugging focuses on \emph{what} is wrong rather than \emph{how} the computation proceeded. It collects failed goals and their contexts:

\begin{verbatim}
decl_debug(Goal, Diagnosis?) :-
    run_checked(Goal?, [], Diagnosis).

run_checked(true, Ctx, ok).
run_checked((A,B), Ctx, Diag?) :-
    run_checked(A?, Ctx?, DA),
    run_checked(B?, Ctx?, DB),
    merge_diag(DA?, DB?, Diag).
run_checked(Goal, Ctx, Diag?) :- known(Goal) |
    try_reduce(Goal?, Result),
    handle_result(Result?, Goal?, Ctx?, Diag).

try_reduce(Goal, success(Body?)) :- reduce(Goal?, Body) | true.
try_reduce(Goal, failure) :- otherwise | true.

handle_result(success(Body), Goal, Ctx, Diag?) :-
    run_checked(Body?, [Goal?|Ctx?], Diag).
handle_result(failure, Goal, Ctx, failed(Goal?, Ctx?)).
\end{verbatim}

The diagnosis reports which goal failed and the calling context, helping locate the source of the failure.

%% ============================================
%% Exercises
%% ============================================

\section{Exercises}
\label{sec:meta-exercises}

\subsection{Plain Meta-Interpreter}

\begin{enumerate}
\item \textbf{Step Counter.} Modify the plain meta-interpreter to count the number of reduction steps taken.

\item \textbf{Depth Limiter.} Add a depth limit to prevent infinite recursion.

\item \textbf{Choice Point Collector.} Modify the fail-safe meta-interpreter to collect choice points---goals where multiple \verb|reduce| clauses match.

\item \textbf{Call Graph.} Write a meta-interpreter that builds a call graph showing which predicates call which others.

\item \textbf{Time-Bounded Execution.} Combine termination detection with a timeout mechanism.
\end{enumerate}

\subsection{Enhanced Meta-Interpreters}

\begin{enumerate}
\item \textbf{Replay.} Given a trace from the tracing meta-interpreter, write a replaying meta-interpreter that executes the same computation deterministically.

\item \textbf{Breakpoints.} Add breakpoint support to the debugger: suspend when a specific predicate is called.

\item \textbf{Watch Variables.} Extend the debugger to notify when a specific variable is bound.

\item \textbf{Undo.} Design a mechanism to ``undo'' reductions. What challenges arise with concurrent execution?

\item \textbf{Coverage Analysis.} Write a meta-interpreter that tracks which \verb|reduce| clauses are used.
\end{enumerate}

\subsection{Debugging}

\begin{enumerate}
\item \textbf{Termination Detection.} Using the short-circuit technique from Section~\ref{sec:termination-detection}, write a meta-interpreter that signals when all concurrent processes have terminated. The circuit should close only when every branch reaches \verb|true|.

\item \textbf{Snapshot Collection.} Extend the snapshot meta-interpreter to collect the full resolvent (all pending goals) when execution is aborted. The result should be a list of goals that were in progress at the time of abort.

\item \textbf{Timestamped Execution Tree.} Write a meta-interpreter that builds a timestamped execution tree. Each node should record: the goal, the clause used, the timestamp, and its children. This enables visualization of concurrent execution.
\end{enumerate}
