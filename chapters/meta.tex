% chapters/meta.tex - Metaprogramming

\chapter{Metaprogramming}
\label{ch:meta}

This chapter presents metaprogramming in \GLP: programs that manipulate, interpret, and transform other programs. In logic programming, programs are data: clauses are terms, goals are terms. This fundamental property enables powerful metaprogramming techniques.

We present meta-interpreters in a progression, each adding capabilities:
\begin{enumerate}
\item \textbf{Trust mode}: Basic execution, assumes programs are correct.
\item \textbf{Fail-safe mode}: Reports failures via short-circuit rather than aborting.
\item \textbf{Control mode}: Adds control stream for suspend/resume/abort, with state dump.
\item \textbf{Equator extension}: Adds emergency brake for process-to-controller signaling.
\end{enumerate}

%% ============================================
%% Section 1: Trust Mode Meta-Interpreter
%% ============================================

\section{Trust Mode Meta-Interpreter}
\label{sec:trust-meta}

\subsection{Programs as Data}
\label{sec:programs-as-data}

A \GLP clause like:
\begin{verbatim}
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Xs?, Ys?, Zs).
\end{verbatim}

can be represented as a term using a \verb|reduce/2| encoding:
\begin{verbatim}
reduce(merge([X|Xs], Ys, [X?|Zs?]), merge(Xs?, Ys?, Zs)).
\end{verbatim}

This representation allows programs to examine, modify, and execute other programs.

\subsection{Program Encoding}
\label{sec:program-encoding}

The object program is encoded as \verb|reduce/2| facts within a module:

\begin{verbatim}
%% merge.glp - merge encoded for meta-interpreter
reduce(merge([X|Xs], Ys, [X?|Zs?]), merge(Xs?, Ys?, Zs)).
reduce(merge(Xs, [Y|Ys], [Y?|Zs?]), merge(Xs?, Ys?, Zs)).
reduce(merge([], [], []), true).
\end{verbatim}

The meta-interpreter accesses these clauses via remote procedure call: \verb|M # reduce(Goal, Body)|.

\subsection{The Plain Meta-Interpreter}
\label{sec:plain-meta}

The simplest \GLP meta-interpreter:

\begin{verbatim}
run(M, true).                                    % halt
run(M, (A,B)) :- run(M?, A?), run(M?, B?).       % fork
run(M, M1 # G) :- run(M1?, G?).                  % cross-module
run(M, A) :- tuple(A?) | M # reduce(A?, B), run(M?, B?).  % reduce
\end{verbatim}

The first argument \verb|M| is the module containing the \verb|reduce/2| encoding of the object program.

\paragraph{Halt.} When the goal is \verb|true|, execution terminates successfully.

\paragraph{Fork.} When running a conjunction \verb|(A,B)|, we spawn two concurrent processes.

\paragraph{Cross-module.} When the goal is a remote call \verb|M1 # G|, we switch to module \verb|M1|.

\paragraph{Reduce.} The \verb|tuple(A?)| guard tests whether \verb|A?| is bound to a compound term. Unlike \verb|ground|, which requires all subterms to be bound, \verb|tuple| succeeds as soon as the outer structure is known. The guard suspends if \verb|A?| is unbound, since clause selection cannot proceed until we know which predicate to reduce.

\paragraph{Usage.}
\begin{verbatim}
?- run(merge, merge([1,2], [3,4], Zs)).
Zs = [1, 3, 2, 4]  % or other fair interleaving
\end{verbatim}

%% ============================================
%% Section 2: Fail-safe Meta-Interpreter
%% ============================================

\section{Fail-safe Meta-Interpreter}
\label{sec:failsafe-meta}

The plain meta-interpreter aborts when a goal has no matching clause. The \emph{fail-safe} meta-interpreter reports failures instead, using the short-circuit technique.

\subsection{Short-Circuit Technique}
\label{sec:short-circuit}

The short-circuit threads a pair of variables \verb|L--R| (left endpoint, right endpoint) through the computation. Each process receives a segment of the chain:

\begin{itemize}
\item \textbf{Halt}: Close the circuit by unifying \verb|L| with \verb|R|.
\item \textbf{Fork}: Split the chain---first branch gets \verb|L--M|, second gets \verb|M--R|.
\item \textbf{Report}: Prepend to the chain: \verb|L| becomes \verb|[Item|L?]|.
\end{itemize}

When all processes terminate, the circuit closes and the accumulated reports flow to the result.

\paragraph{Termination detection.} The short-circuit provides termination detection as a side effect. When called with \verb|run(M, Goal, done, Result)|, the circuit closes only when all processes reach \verb|true|. At that point, \verb|Result?| unifies with \verb|done| (or the accumulated failure list ending in \verb|done|). A controller can detect termination by testing \verb|known(Result?)|---it succeeds precisely when all processes have terminated.

\subsection{The Fail-safe Meta-Interpreter}
\label{sec:failsafe-impl}

\begin{verbatim}
run(M, true, L, L?).                             % halt - close circuit
run(M, (A,B), L, R?) :-                          % fork - split chain
    run(M?, A?, L?, Mid),
    run(M?, B?, Mid?, R).
run(M, M1 # G, L, R?) :- run(M1?, G?, L?, R).    % cross-module
run(M, failed(A), L, [failed(A?)|L?]).           % report failure
run(M, A, L, R?) :-                              % reduce
    tuple(A?) |
    M # reduce(A?, B),
    run(M?, B?, L?, R).
\end{verbatim}

\paragraph{Program encoding.} The object program must include a catch-all clause:
\begin{verbatim}
reduce(A, failed(A?)) :- otherwise | true.
\end{verbatim}

When no clause matches goal \verb|A|, the \verb|otherwise| guard succeeds and \verb|A| is wrapped as \verb|failed(A)|. The meta-interpreter then reports it via the short-circuit.

\paragraph{Usage.}
\begin{verbatim}
?- run(merge, merge([1,2], [3], Zs), done, Failures).
Zs = [1, 3, 2]
Failures = done  % no failures

?- run(buggy, some_goal(X), done, Failures).
Failures = [failed(undefined_pred(...))|done]
\end{verbatim}

%% ============================================
%% Section 3: Control Meta-Interpreter
%% ============================================

\section{Control Meta-Interpreter}
\label{sec:control-meta}

The \emph{control} meta-interpreter adds a control stream for runtime control: suspend, resume, and abort. It also uses short-circuit to collect a state dump on abort.

\subsection{Control Stream}
\label{sec:control-stream}

The controller sends commands via a ground stream:
\begin{itemize}
\item \verb|suspend|: Pause all processes.
\item \verb|resume|: Continue paused processes.
\item \verb|abort|: Terminate and collect state dump.
\end{itemize}

Because the control stream is ground, the \verb|ground(Cs?)| guard allows it to be shared among all forked processes.

\subsection{The Control Meta-Interpreter}
\label{sec:control-impl}

\begin{verbatim}
run(M, true, _, L, L?).                          % halt
run(M, (A,B), Cs, L, R?) :-                      % fork
    ground(Cs?) |
    run(M?, A?, Cs?, L?, Mid),
    run(M?, B?, Cs?, Mid?, R).
run(M, M1 # G, Cs, L, R?) :-                     % cross-module
    run(M1?, G?, Cs?, L?, R).
run(M, A, [suspend|Cs], L, R?) :-                % suspend
    suspended_run(M?, A?, Cs?, L?, R).
run(M, A, Cs, L, R?) :-                          % reduce
    tuple(A?) |
    M # reduce(A?, B),
    run(M?, B?, Cs?, L?, R).

suspended_run(M, A, [resume|Cs], L, R?) :-       % resume
    run(M?, A?, Cs?, L?, R).
suspended_run(_, A, [abort|_], L, [A?|L?]).      % abort + dump
\end{verbatim}

\paragraph{Suspend.} When the control stream head is \verb|suspend|, the process transitions to \verb|suspended_run|, waiting for further commands.

\paragraph{Resume.} The \verb|resume| command returns to normal execution.

\paragraph{Abort.} The \verb|abort| command terminates the process and adds its current goal to the dump via short-circuit.

\paragraph{Usage.}
\begin{verbatim}
%% Controller sends commands, receives dump
controller(Commands, Dump?) :-
    Commands = [suspend, resume, suspend, abort|_],
    % Dump? will contain goals that were active at abort
    ...
\end{verbatim}

%% ============================================
%% Section 4: Equators: Emergency Brake
%% ============================================

\section{Equators: Emergency Brake}
\label{sec:equators}

A meta-interpreter spawns many processes. How can any process signal that computation should stop? The \emph{equator} provides this capability---like an emergency brake on a train, where any passenger can signal the driver, but only the driver decides what to do next.

\subsection{The Problem}

The SRSW requirement ensures each writer has exactly one occurrence. But for emergency signaling, we need many processes to share access to a single trigger. The equator solves this by wrapping a writer in a structure that can be safely distributed.

\subsection{Structure}

An equator is a term \verb|'_equator'(E, C)| where \verb|E| is a writer and \verb|C| is a constant. The structure can be created explicitly or via a unit clause:

\begin{verbatim}
create_equator(C, '_equator'(E, C?), E?).
\end{verbatim}

For the call \verb|create_equator(stop, Eq, Handle)|:
\begin{itemize}
\item \verb|Eq| binds to \verb|'_equator'(E, stop)| with fresh writer \verb|E|
\item \verb|Handle| binds to \verb|E?|---the sole reader, kept by the controller
\end{itemize}

Alternatively, construct explicitly in the body:
\begin{verbatim}
... :- controller(E?, Commands), run(m, goal, '_equator'(E, stop), Commands?).
\end{verbatim}

\subsection{Guard and Kernel}

The \verb|equator(X?)| guard succeeds when \verb|X| has the form \verb|'_equator'(_, C)| where \verb|C| is a constant. Like \verb|ground|, this guard relaxes SRSW: \verb|X?| may occur multiple times in the clause body.

The kernel \verb|'_equator'(X)| triggers the brake: if \verb|X = '_equator'(E, C)| and \verb|E| is a writer, it binds \verb|E = C|. Otherwise it is a no-op.

\subsection{Many-to-One Communication}

The equator enables many-to-one communication: any of the many processes holding the equator structure can bind the writer, signaling the single controller that holds the reader. The controller then decides what action to take---perhaps issuing stop commands through the distributed command stream, or collecting state snapshots before shutdown.

%% ============================================
%% Section 5: Control with Equator
%% ============================================

\section{Control with Equator}
\label{sec:control-equator}

Combining control streams with equators yields a meta-interpreter where:
\begin{itemize}
\item The controller sends commands to processes (control stream).
\item Any process can signal the controller (equator).
\end{itemize}

\subsection{The Control+Equator Meta-Interpreter}
\label{sec:control-equator-impl}

\begin{verbatim}
run(M, true, _, _, L, L?).                       % halt
run(M, (A,B), Cs, Eq, L, R?) :-                  % fork
    equator(Eq?) |
    run(M?, A?, Cs?, Eq?, L?, Mid),
    run(M?, B?, Cs?, Eq?, Mid?, R).
run(M, M1 # G, Cs, Eq, L, R?) :-                 % cross-module
    run(M1?, G?, Cs?, Eq?, L?, R).
run(M, A, [suspend|Cs], Eq, L, R?) :-            % suspend
    suspended_run(M?, A?, Cs?, Eq?, L?, R).
run(M, A, Cs, Eq, L, R?) :-                      % reduce
    tuple(A?) |
    M # reduce(A?, B),
    run(M?, B?, Cs?, Eq?, L?, R).

suspended_run(M, A, [resume|Cs], Eq, L, R?) :-   % resume
    run(M?, A?, Cs?, Eq?, L?, R).
suspended_run(_, A, [abort|_], _, L, [A?|L?]).   % abort + dump
suspended_run(_, _, [brake|_], Eq, L, L?) :-     % pull brake
    equate(Eq?).
\end{verbatim}

\paragraph{The brake command.} When a process receives \verb|[brake|_]| on its control stream, it calls \verb|equate(Eq?)| to trigger the equator. This binds the internal writer, which the controller detects.

\paragraph{Controller setup.}
\begin{verbatim}
main :-
    create_equator(stop, Eq, Handle),
    controller(Handle?, Commands),
    run(mymodule, goal, Commands?, Eq?, done, Dump).

controller(Handle, Commands) :-
    known(Handle?) |                             % brake was pulled
    Commands = [abort|_].                        % respond by aborting
controller(Handle, Commands) :-
    unknown(Handle?) |
    % ... normal command generation ...
\end{verbatim}

When any process pulls the brake, \verb|Handle?| becomes bound to \verb|stop|. The controller detects this via \verb|known(Handle?)| and can respond appropriately---here, by issuing an abort command.

\subsection{Use Cases}

\begin{itemize}
\item \textbf{Error detection}: A process encounters an unrecoverable error and pulls the brake.
\item \textbf{Resource exhaustion}: A process detects memory or time limits exceeded.
\item \textbf{Goal achieved}: In search problems, a process finds a solution and signals others to stop.
\item \textbf{Watchdog}: A monitoring process pulls the brake on timeout.
\end{itemize}

%% ============================================
%% Section 6: Tracing Meta-Interpreter
%% ============================================

\section{Tracing Meta-Interpreter}
\label{sec:tracing-meta}

The meta-interpreters presented so far manage execution but do not record it. The \emph{tracing} meta-interpreter builds an execution tree that captures each reduction: what goal was reduced, which clause was used, and the resulting subtree.

\subsection{Execution Tree Structure}

The trace tree has three forms:
\begin{itemize}
\item \verb|true| --- computation halted
\item \verb|fork(T1, T2)| --- conjunction split into two branches
\item \verb|reduction(Goal, ClauseId, SubTree)| --- goal reduced using clause \verb|ClauseId|
\end{itemize}

The tree records both \emph{what} happened (the goal snapshots) and \emph{how} it happened (the clause indices), enabling both inspection and replay.

\subsection{Goal Snapshots}

A naive implementation that stores the goal directly fails: as execution proceeds, variables in the goal become bound, and the stored reference mutates along with them. We need to \emph{snapshot} the goal at reduction time.

The \verb|observe/3| predicate from Chapter~\ref{ch:recursive} creates two copies of a term: one for execution, one for observation. When the observer encounters an unbound subterm, it suspends until bound, then copies the value to both outputs.

\subsection{The Tracing Meta-Interpreter}

\begin{verbatim}
run(M, true, true).                              % halt
run(M, (A,B), fork(TA?, TB?)) :-                 % fork
    run(M?, A?, TA),
    run(M?, B?, TB).
run(M, A, reduction(A_obs?, I?, TB?)) :-         % reduce
    tuple(A?) |
    observe(A?, A_exec, A_obs),
    reduce(A_exec?, B, I),
    run(M?, B?, TB).
\end{verbatim}

The reduce clause:
\begin{enumerate}
\item Waits for the goal to be a compound term (\verb|tuple(A?)|)
\item Snapshots the goal: \verb|A_exec| drives execution, \verb|A_obs| is frozen for the trace
\item Looks up the clause via \verb|reduce/3|, which returns the body and clause index
\item Recursively runs the body, building the subtree
\end{enumerate}

\subsection{Indexed Program Encoding}

The object program must provide clause indices in \verb|reduce/3|:

\begin{verbatim}
reduce(merge([X|Xs], Ys, [X?|Zs?]), merge(Xs?, Ys?, Zs), 1).
reduce(merge(Xs, [Y|Ys], [Y?|Zs?]), merge(Xs?, Ys?, Zs), 2).
reduce(merge([], [], []), true, 3).
\end{verbatim}

Each clause has a unique index. These indices enable deterministic replay: given a trace, a replaying interpreter can select the exact same clauses in the exact same order.

\subsection{Example Trace}

Running \verb|merge([1,2], [3,4], Zs)| produces:

\begin{verbatim}
Zs = [1, 2, 3, 4]
Tree = reduction(merge([1,2], [3,4], [1,2,3,4]), 1,
         reduction(merge([2], [3,4], [2,3,4]), 1,
           reduction(merge([], [3,4], [3,4]), 2,
             reduction(merge([], [4], [4]), 2,
               reduction(merge([], [], []), 3, true)))))
\end{verbatim}

The trace shows:
\begin{itemize}
\item Clause 1 selected twice (first list non-empty)
\item Clause 2 selected twice (first list empty, second non-empty)
\item Clause 3 selected once (both lists empty)
\end{itemize}

The output variable in each snapshot shows the result at that point---structural sharing with the final result.

\subsection{Adding Timestamps}

For debugging concurrent programs, timestamps reveal execution order:

\begin{verbatim}
run(M, A, reduction(A_obs?, I?, Time?, TB?)) :-
    tuple(A?) |
    observe(A?, A_exec, A_obs),
    now(Time),
    reduce(A_exec?, B, I),
    run(M?, B?, TB).
\end{verbatim}

The \verb|now/1| system predicate binds \verb|Time| to the current timestamp in milliseconds. With timestamps, you can reconstruct the temporal order of reductions across concurrent branches.

\subsection{Replay}

Given a trace, replay executes the same computation deterministically:

\begin{verbatim}
replay(M, true, true).
replay(M, fork(T1, T2), (A?, B?)) :-
    replay(M?, T1?, A),
    replay(M?, T2?, B).
replay(M, reduction(_, I, SubTree), Goal?) :-
    reduce_by_index(I?, Goal, Body),
    replay(M?, SubTree?, Body?).
\end{verbatim}

The replayer ignores the stored goals and uses only the clause indices. This guarantees identical execution regardless of scheduling nondeterminism.

%% ============================================
%% Exercises
%% ============================================

\section{Exercises}
\label{sec:meta-exercises}

\subsection{Trust Mode}

\begin{enumerate}
\item \textbf{Step Counter.} Extend the trust mode meta-interpreter to count the number of reduction steps. The signature is \verb|run(M, Goal, Count)|.

\item \textbf{Depth Limiter.} Add a depth limit to prevent infinite recursion. When the limit is reached, fail gracefully.

\item \textbf{Call Graph.} Write a meta-interpreter that builds a call graph showing which predicates call which others.
\end{enumerate}

\subsection{Failsafe Mode}

\begin{enumerate}
\item \textbf{Failure Context.} Extend the failsafe meta-interpreter to record not just the failed goal, but also its calling context (the goal that spawned it).

\item \textbf{Timeout.} Combine failsafe mode with a timeout: if execution exceeds a time limit, report all currently active goals as ``timed out.''
\end{enumerate}

\subsection{Control Mode}

\begin{enumerate}
\item \textbf{Step Command.} Add a \verb|step| command that advances exactly one reduction, then suspends.

\item \textbf{Breakpoints.} Add breakpoint support: \verb|break(Pred/Arity)| causes suspension when a goal matching that predicate is about to reduce.

\item \textbf{Watch Variables.} Extend the controller to notify when a specific variable becomes bound.
\end{enumerate}

\subsection{Equators}

\begin{enumerate}
\item \textbf{Resource Monitor.} Write a meta-interpreter where each process has a resource budget. When any process exhausts its budget, it pulls the emergency brake.

\item \textbf{First Solution.} In a search problem, the first process to find a solution pulls the brake. The controller collects the solution and aborts remaining search branches.
\end{enumerate}

\subsection{Tracing}

\begin{enumerate}
\item \textbf{Selective Tracing.} Extend the tracing meta-interpreter to only record reductions for specified predicates, ignoring others.

\item \textbf{Trace Diff.} Given two traces of the same program with different inputs, write a predicate that finds where they diverge.

\item \textbf{Abstract Interpretation.} Write a meta-interpreter that executes programs over an abstract domain. For example, use the sign domain \verb|{neg, zero, pos, unknown}| and define abstract arithmetic:
\begin{verbatim}
abstract_add(pos, pos, pos).
abstract_add(pos, neg, unknown).
abstract_add(zero, X, X?).
\end{verbatim}
This enables static analysis: determine properties of programs without running them on concrete inputs.
\end{enumerate}
