% chapters/meta.tex - Metaprogramming

\chapter{Metaprogramming}
\label{ch:meta}

This chapter presents metaprogramming in \GLP: programs that manipulate, interpret, and transform other programs. In logic programming, programs are data: clauses are terms, goals are terms. This fundamental property enables powerful metaprogramming techniques.

We present meta-interpreters in a progression, each adding capabilities:
\begin{enumerate}
\item \textbf{Trust mode}: Basic execution, assumes programs are correct.
\item \textbf{Fail-safe mode}: Reports failures via short-circuit rather than aborting.
\item \textbf{Control mode}: Adds control stream for suspend/resume/abort, with state dump.
\item \textbf{Equator extension}: Adds emergency brake for process-to-controller signaling.
\end{enumerate}

%% ============================================
%% Section 1: Trust Mode Meta-Interpreter
%% ============================================

\section{Trust Mode Meta-Interpreter}
\label{sec:trust-meta}

\subsection{Programs as Data}
\label{sec:programs-as-data}

A \GLP clause like:
\begin{verbatim}
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Xs?, Ys?, Zs).
\end{verbatim}

can be represented as a term using a \verb|reduce/2| encoding:
\begin{verbatim}
reduce(merge([X|Xs], Ys, [X?|Zs?]), merge(Xs?, Ys?, Zs)).
\end{verbatim}

This representation allows programs to examine, modify, and execute other programs.

\subsection{Program Encoding}
\label{sec:program-encoding}

The object program is encoded as \verb|reduce/2| facts within a module:

\begin{verbatim}
%% merge.glp - merge encoded for meta-interpreter
reduce(merge([X|Xs], Ys, [X?|Zs?]), merge(Xs?, Ys?, Zs)).
reduce(merge(Xs, [Y|Ys], [Y?|Zs?]), merge(Xs?, Ys?, Zs)).
reduce(merge([], [], []), true).
\end{verbatim}

The meta-interpreter accesses these clauses via remote procedure call: \verb|M # reduce(Goal, Body)|.

\subsection{The Plain Meta-Interpreter}
\label{sec:plain-meta}

The simplest \GLP meta-interpreter:

\begin{verbatim}
run(M, true).                                    % halt
run(M, (A,B)) :- run(M?, A?), run(M?, B?).       % fork
run(M, M1 # G) :- run(M1?, G?).                  % cross-module
run(M, A) :- tuple(A?) | M # reduce(A?, B), run(M?, B?).  % reduce
\end{verbatim}

The first argument \verb|M| is the module containing the \verb|reduce/2| encoding of the object program.

\paragraph{Halt.} When the goal is \verb|true|, execution terminates successfully.

\paragraph{Fork.} When running a conjunction \verb|(A,B)|, we spawn two concurrent processes.

\paragraph{Cross-module.} When the goal is a remote call \verb|M1 # G|, we switch to module \verb|M1|.

\paragraph{Reduce.} The \verb|tuple(A?)| guard tests whether \verb|A?| is bound to a compound term. Unlike \verb|ground|, which requires all subterms to be bound, \verb|tuple| succeeds as soon as the outer structure is known. The guard suspends if \verb|A?| is unbound, since clause selection cannot proceed until we know which predicate to reduce.

\paragraph{Usage.}
\begin{verbatim}
?- run(merge, merge([1,2], [3,4], Zs)).
Zs = [1, 3, 2, 4]  % or other fair interleaving
\end{verbatim}

%% ============================================
%% Section 2: Fail-safe Meta-Interpreter
%% ============================================

\section{Fail-safe Meta-Interpreter}
\label{sec:failsafe-meta}

The plain meta-interpreter aborts when a goal has no matching clause. The \emph{fail-safe} meta-interpreter reports failures instead, using the short-circuit technique.

\subsection{Short-Circuit Technique}
\label{sec:short-circuit}

The short-circuit threads a pair of variables \verb|L--R| (left endpoint, right endpoint) through the computation. Each process receives a segment of the chain:

\begin{itemize}
\item \textbf{Halt}: Close the circuit by unifying \verb|L| with \verb|R|.
\item \textbf{Fork}: Split the chain---first branch gets \verb|L--M|, second gets \verb|M--R|.
\item \textbf{Report}: Prepend to the chain: \verb|L| becomes \verb|[Item|L?]|.
\end{itemize}

When all processes terminate, the circuit closes and the accumulated reports flow to the result.

\subsection{The Fail-safe Meta-Interpreter}
\label{sec:failsafe-impl}

\begin{verbatim}
run(M, true, L, L?).                             % halt - close circuit
run(M, (A,B), L, R?) :-                          % fork - split chain
    run(M?, A?, L?, Mid),
    run(M?, B?, Mid?, R).
run(M, M1 # G, L, R?) :- run(M1?, G?, L?, R).    % cross-module
run(M, failed(A), L, [failed(A?)|L?]).           % report failure
run(M, A, L, R?) :-                              % reduce
    tuple(A?) |
    M # reduce(A?, B),
    run(M?, B?, L?, R).
\end{verbatim}

\paragraph{Program encoding.} The object program must include a catch-all clause:
\begin{verbatim}
reduce(A, failed(A?)) :- otherwise | true.
\end{verbatim}

When no clause matches goal \verb|A|, the \verb|otherwise| guard succeeds and \verb|A| is wrapped as \verb|failed(A)|. The meta-interpreter then reports it via the short-circuit.

\paragraph{Usage.}
\begin{verbatim}
?- run(merge, merge([1,2], [3], Zs), done, Failures).
Zs = [1, 3, 2]
Failures = done  % no failures

?- run(buggy, some_goal(X), done, Failures).
Failures = [failed(undefined_pred(...))|done]
\end{verbatim}

%% ============================================
%% Section 3: Control Meta-Interpreter
%% ============================================

\section{Control Meta-Interpreter}
\label{sec:control-meta}

The \emph{control} meta-interpreter adds a control stream for runtime control: suspend, resume, and abort. It also uses short-circuit to collect a state dump on abort.

\subsection{Control Stream}
\label{sec:control-stream}

The controller sends commands via a ground stream:
\begin{itemize}
\item \verb|suspend|: Pause all processes.
\item \verb|resume|: Continue paused processes.
\item \verb|abort|: Terminate and collect state dump.
\end{itemize}

Because the control stream is ground, the \verb|ground(Cs?)| guard allows it to be shared among all forked processes.

\subsection{The Control Meta-Interpreter}
\label{sec:control-impl}

\begin{verbatim}
run(M, true, _, L, L?).                          % halt
run(M, (A,B), Cs, L, R?) :-                      % fork
    ground(Cs?) |
    run(M?, A?, Cs?, L?, Mid),
    run(M?, B?, Cs?, Mid?, R).
run(M, M1 # G, Cs, L, R?) :-                     % cross-module
    run(M1?, G?, Cs?, L?, R).
run(M, A, [suspend|Cs], L, R?) :-                % suspend
    suspended_run(M?, A?, Cs?, L?, R).
run(M, A, Cs, L, R?) :-                          % reduce
    tuple(A?) |
    M # reduce(A?, B),
    run(M?, B?, Cs?, L?, R).

suspended_run(M, A, [resume|Cs], L, R?) :-       % resume
    run(M?, A?, Cs?, L?, R).
suspended_run(_, A, [abort|_], L, [A?|L?]).      % abort + dump
\end{verbatim}

\paragraph{Suspend.} When the control stream head is \verb|suspend|, the process transitions to \verb|suspended_run|, waiting for further commands.

\paragraph{Resume.} The \verb|resume| command returns to normal execution.

\paragraph{Abort.} The \verb|abort| command terminates the process and adds its current goal to the dump via short-circuit.

\paragraph{Usage.}
\begin{verbatim}
%% Controller sends commands, receives dump
controller(Commands, Dump?) :-
    Commands = [suspend, resume, suspend, abort|_],
    % Dump? will contain goals that were active at abort
    ...
\end{verbatim}

%% ============================================
%% Section 4: Equators: Emergency Brake
%% ============================================

\section{Equators: Emergency Brake}
\label{sec:equators}

A meta-interpreter spawns many processes. How can any process signal that computation should stop? The \emph{equator} provides this capability---like an emergency brake on a train, where any passenger can signal the driver, but only the driver decides what to do next.

\subsection{The Problem}

The SRSW requirement ensures each writer has exactly one occurrence. But for emergency signaling, we need many processes to share access to a single trigger. The equator solves this by wrapping a writer in a structure that can be safely distributed.

\subsection{Structure}

An equator is a term \verb|'_equator'(E, C)| where \verb|E| is a writer and \verb|C| is a constant. The structure can be created explicitly or via a unit clause:

\begin{verbatim}
create_equator(C, '_equator'(E, C?), E?).
\end{verbatim}

For the call \verb|create_equator(stop, Eq, Handle)|:
\begin{itemize}
\item \verb|Eq| binds to \verb|'_equator'(E, stop)| with fresh writer \verb|E|
\item \verb|Handle| binds to \verb|E?|---the sole reader, kept by the controller
\end{itemize}

Alternatively, construct explicitly in the body:
\begin{verbatim}
... :- controller(E?, Commands), run(m, goal, '_equator'(E, stop), Commands?).
\end{verbatim}

\subsection{Guard and Kernel}

The \verb|equator(X?)| guard succeeds when \verb|X| has the form \verb|'_equator'(_, C)| where \verb|C| is a constant. Like \verb|ground|, this guard relaxes SRSW: \verb|X?| may occur multiple times in the clause body.

The kernel \verb|'_equator'(X)| triggers the brake: if \verb|X = '_equator'(E, C)| and \verb|E| is a writer, it binds \verb|E = C|. Otherwise it is a no-op.

\subsection{Many-to-One Communication}

The equator enables many-to-one communication: any of the many processes holding the equator structure can bind the writer, signaling the single controller that holds the reader. The controller then decides what action to take---perhaps issuing stop commands through the distributed command stream, or collecting state snapshots before shutdown.

%% ============================================
%% Section 5: Control with Equator
%% ============================================

\section{Control with Equator}
\label{sec:control-equator}

Combining control streams with equators yields a meta-interpreter where:
\begin{itemize}
\item The controller sends commands to processes (control stream).
\item Any process can signal the controller (equator).
\end{itemize}

\subsection{The Control+Equator Meta-Interpreter}
\label{sec:control-equator-impl}

\begin{verbatim}
run(M, true, _, _, L, L?).                       % halt
run(M, (A,B), Cs, Eq, L, R?) :-                  % fork
    equator(Eq?) |
    run(M?, A?, Cs?, Eq?, L?, Mid),
    run(M?, B?, Cs?, Eq?, Mid?, R).
run(M, M1 # G, Cs, Eq, L, R?) :-                 % cross-module
    run(M1?, G?, Cs?, Eq?, L?, R).
run(M, A, [suspend|Cs], Eq, L, R?) :-            % suspend
    suspended_run(M?, A?, Cs?, Eq?, L?, R).
run(M, A, Cs, Eq, L, R?) :-                      % reduce
    tuple(A?) |
    M # reduce(A?, B),
    run(M?, B?, Cs?, Eq?, L?, R).

suspended_run(M, A, [resume|Cs], Eq, L, R?) :-   % resume
    run(M?, A?, Cs?, Eq?, L?, R).
suspended_run(_, A, [abort|_], _, L, [A?|L?]).   % abort + dump
suspended_run(_, _, [brake|_], Eq, L, L?) :-     % pull brake
    equate(Eq?).
\end{verbatim}

\paragraph{The brake command.} When a process receives \verb|[brake|_]| on its control stream, it calls \verb|equate(Eq?)| to trigger the equator. This binds the internal writer, which the controller detects.

\paragraph{Controller setup.}
\begin{verbatim}
main :-
    create_equator(stop, Eq, Handle),
    controller(Handle?, Commands),
    run(mymodule, goal, Commands?, Eq?, done, Dump).

controller(Handle, Commands) :-
    known(Handle?) |                             % brake was pulled
    Commands = [abort|_].                        % respond by aborting
controller(Handle, Commands) :-
    unknown(Handle?) |
    % ... normal command generation ...
\end{verbatim}

When any process pulls the brake, \verb|Handle?| becomes bound to \verb|stop|. The controller detects this via \verb|known(Handle?)| and can respond appropriately---here, by issuing an abort command.

\subsection{Use Cases}

\begin{itemize}
\item \textbf{Error detection}: A process encounters an unrecoverable error and pulls the brake.
\item \textbf{Resource exhaustion}: A process detects memory or time limits exceeded.
\item \textbf{Goal achieved}: In search problems, a process finds a solution and signals others to stop.
\item \textbf{Watchdog}: A monitoring process pulls the brake on timeout.
\end{itemize}

%% ============================================
%% Section 6: Debugging
%% ============================================

\section{Debugging}
\label{sec:debugging}

\subsection{Algorithmic Debugging}

Algorithmic debugging locates bugs by asking questions about the correctness of intermediate results. The debugger traverses the computation tree, asking the user whether each result is correct:

\begin{verbatim}
algo_debug(true, _, correct).
algo_debug((A,B), Oracle, Result?) :-
    algo_debug(A?, Oracle?, RA),
    algo_debug(B?, Oracle?, RB),
    combine_results(RA?, RB?, Result).
algo_debug(Goal, Oracle, Result?) :- known(Goal) |
    reduce(Goal?, Body),
    algo_debug(Body?, Oracle?, BodyResult),
    ask_oracle(Oracle?, Goal?, BodyResult?, Result).

ask_oracle(Oracle, Goal, correct, correct) :-
    query(Oracle?, is_correct(Goal?), yes) | true.
ask_oracle(Oracle, Goal, correct, buggy(Goal?)) :-
    query(Oracle?, is_correct(Goal?), no) | true.
ask_oracle(_, Goal, buggy(X), buggy(X?)).
\end{verbatim}

When the body is correct but the goal is wrong, the bug is in the clause used to reduce that goal.

\subsection{Trace-Based Debugging}

Trace-based debugging records the execution history and provides replay capabilities. The trace can be analyzed post-mortem or used for deterministic replay:

\begin{verbatim}
trace_debug(Goal, Trace?) :-
    run_traced(Goal?, [], Trace).

run_traced(true, Acc, Acc?).
run_traced((A,B), Acc, Trace?) :-
    run_traced(A?, Acc?, Acc1),
    run_traced(B?, Acc1?, Trace).
run_traced(Goal, Acc, Trace?) :- known(Goal) |
    reduce(Goal?, Body, ClauseId),
    time(T),
    run_traced(Body?, [step(T?,Goal?,ClauseId?)|Acc?], Trace).

%% Replay from trace
replay([], true).
replay([step(_,Goal,ClauseId)|Steps?], (Goal?,Rest?)) :-
    reduce_by_id(Goal?, ClauseId?, Body),
    replay(Steps?, Rest).
\end{verbatim}

The trace records timestamps, enabling analysis of timing-dependent bugs in concurrent executions.

\subsection{Declarative Debugging}

Declarative debugging focuses on \emph{what} is wrong rather than \emph{how} the computation proceeded. It collects failed goals and their contexts:

\begin{verbatim}
decl_debug(Goal, Diagnosis?) :-
    run_checked(Goal?, [], Diagnosis).

run_checked(true, Ctx, ok).
run_checked((A,B), Ctx, Diag?) :-
    run_checked(A?, Ctx?, DA),
    run_checked(B?, Ctx?, DB),
    merge_diag(DA?, DB?, Diag).
run_checked(Goal, Ctx, Diag?) :- known(Goal) |
    try_reduce(Goal?, Result),
    handle_result(Result?, Goal?, Ctx?, Diag).

try_reduce(Goal, success(Body?)) :- reduce(Goal?, Body) | true.
try_reduce(Goal, failure) :- otherwise | true.

handle_result(success(Body), Goal, Ctx, Diag?) :-
    run_checked(Body?, [Goal?|Ctx?], Diag).
handle_result(failure, Goal, Ctx, failed(Goal?, Ctx?)).
\end{verbatim}

The diagnosis reports which goal failed and the calling context, helping locate the source of the failure.

%% ============================================
%% Exercises
%% ============================================

\section{Exercises}
\label{sec:meta-exercises}

\subsection{Plain Meta-Interpreter}

\begin{enumerate}
\item \textbf{Step Counter.} Modify the plain meta-interpreter to count the number of reduction steps taken.

\item \textbf{Depth Limiter.} Add a depth limit to prevent infinite recursion.

\item \textbf{Choice Point Collector.} Modify the fail-safe meta-interpreter to collect choice points---goals where multiple \verb|reduce| clauses match.

\item \textbf{Call Graph.} Write a meta-interpreter that builds a call graph showing which predicates call which others.

\item \textbf{Time-Bounded Execution.} Combine termination detection with a timeout mechanism.
\end{enumerate}

\subsection{Enhanced Meta-Interpreters}

\begin{enumerate}
\item \textbf{Replay.} Given a trace from the tracing meta-interpreter, write a replaying meta-interpreter that executes the same computation deterministically.

\item \textbf{Breakpoints.} Add breakpoint support to the debugger: suspend when a specific predicate is called.

\item \textbf{Watch Variables.} Extend the debugger to notify when a specific variable is bound.

\item \textbf{Undo.} Design a mechanism to ``undo'' reductions. What challenges arise with concurrent execution?

\item \textbf{Coverage Analysis.} Write a meta-interpreter that tracks which \verb|reduce| clauses are used.
\end{enumerate}

\subsection{Debugging}

\begin{enumerate}
\item \textbf{Termination Detection.} Using the short-circuit technique from Section~\ref{sec:termination-detection}, write a meta-interpreter that signals when all concurrent processes have terminated. The circuit should close only when every branch reaches \verb|true|.

\item \textbf{Snapshot Collection.} Extend the snapshot meta-interpreter to collect the full resolvent (all pending goals) when execution is aborted. The result should be a list of goals that were in progress at the time of abort.

\item \textbf{Timestamped Execution Tree.} Write a meta-interpreter that builds a timestamped execution tree. Each node should record: the goal, the clause used, the timestamp, and its children. This enables visualization of concurrent execution.
\end{enumerate}
