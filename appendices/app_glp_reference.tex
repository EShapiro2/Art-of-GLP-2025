\chapter{GLP Reference Manual}
\label{app:glp-reference}

This appendix provides a complete reference for GLP syntax, guards, system predicates, and built-in operations.

\section{Lexical Syntax}

\mypara{Variables}
A \emph{writer} is an alphanumeric string beginning with an uppercase letter: \verb|X|, \verb|X1|, \verb|Xs|, \verb|MyVar|. A \emph{reader} is a writer followed by \verb|?|: \verb|X?|, \verb|Xs?|. The underscore \verb|_| is an anonymous variable (don't-care), matching any value without binding.

\mypara{Strings}
A \emph{string} begins with a lowercase letter: \verb|a|, \verb|foo|, \verb|myAtom|. Quoted strings are also strings: \verb|'Hello World'|, \verb|','|.

\mypara{Numbers}
Integers: \verb|0|, \verb|42|, \verb|-17|. Floats: \verb|3.14|, \verb|-0.001|, \verb|2.5e10|.

\mypara{Compound Terms}
A \emph{structure} has a functor (string) and arguments: \verb|point(X,Y)|, \verb|node(Left,Value,Right)|. The functor's \emph{arity} is its argument count.

\mypara{Lists}
The empty list is \verb|[]|. A non-empty list is \verb|[Head|Tail]| where \verb|Head| is the first element and \verb|Tail| is the rest. Syntactic sugar: \verb|[1,2,3]| means \verb|[1|[2|[3|[]]]]|. Mixed notation: \verb|[1,2|Xs]| means \verb|[1|[2|Xs]]|.

\section{Clause Syntax}

A \emph{clause} has the form:
\begin{verbatim}
Head :- Guard | Body.
\end{verbatim}
where \verb|Guard| and \verb|Body| are optional. A \emph{unit clause} (fact) is just \verb|Head.|

The guard separator is \verb$|$. The body is a comma-separated conjunction of goals.

\mypara{SRSW Requirement}
Each variable in a clause must occur exactly twice: once as a writer, once as a reader. Exception: anonymous variables \verb|_| occur once.

\mypara{Programming Style: Fold Unifications into the Head}
Avoid explicit unification \verb|X = Pattern| in guards. Instead, fold the pattern directly into the clause head. This ensures correct SRSW analysis and produces cleaner code.

\begin{verbatim}
% Avoid:
process(Xs, Out?) :- Xs = [H,T|Rest] | handle(H?, T?, Rest?, Out).

% Prefer:
process([H,T|Rest], Out?) :- handle(H?, T?, Rest?, Out).
\end{verbatim}

\section{Guard Predicates}

Guards appear between the head and \verb$|$, testing conditions without side effects. A clause is applicable only if its guard succeeds.

\subsection{Built-in Guards}

\begin{description}
\item[\texttt{ground(X)}] Succeeds if \verb|X| contains no unbound variables. With this guard, the clause body may contain multiple occurrences of \verb|X?| without violating SRSW, enabling safe replication of ground terms.

\item[\texttt{known(X)}] Succeeds if \verb|X| is not an unbound variable (though it may contain unbound variables in subterms).

\item[\texttt{integer(X)}] Succeeds if \verb|X| is bound to an integer.

\item[\texttt{number(X)}] Succeeds if \verb|X| is bound to a number (integer or float).

\item[\texttt{constant(X)}] Succeeds if \verb|X| is bound to a constant (string or number).

\item[\texttt{compound(X)}] Succeeds if \verb|X| is bound to a compound term.

\item[\texttt{is\_list(X)}] Succeeds if \verb|X| is bound to a proper list.

\item[\texttt{unknown(X)}] Succeeds if \verb|X| is bound to an unbound variable. \textbf{Warning: This guard is non-monotonic}---its result can change from true to false as computation proceeds. Use only when testing whether a stream has been extended, as in the interlaced streams pattern. Example:
\begin{verbatim}
% Test if stream tail Bs is still unextended
collect_tips([[Block|Bs]|Others], [Block?|Tips?], ...) :-
    unknown(Bs?) |  % Bs unbound means Block is the current tip
    ...
\end{verbatim}

\item[\texttt{otherwise}] Succeeds if all previous clauses for this predicate failed (not suspended). Enables default case handling.

\item[\texttt{X =?= Y}] Ground equality test. Succeeds if \verb|X| and \verb|Y| are both ground and structurally equal. Suspends if either contains unbound readers. Fails if both ground but different, or if either contains unbound writers.

\item[\texttt{X =:= Y}] Succeeds if \verb|X| and \verb|Y| evaluate to equal numbers.

\item[\texttt{X =\textbackslash= Y}] Arithmetic inequality. Succeeds if \verb|X| and \verb|Y| evaluate to different numbers.

\item[\texttt{X < Y}] Succeeds if \verb|X| evaluates to less than \verb|Y|.

\item[\texttt{X > Y}] Succeeds if \verb|X| evaluates to greater than \verb|Y|.

\item[\texttt{X =< Y}] Succeeds if \verb|X| evaluates to less than or equal to \verb|Y|.

\item[\texttt{X >= Y}] Succeeds if \verb|X| evaluates to greater than or equal to \verb|Y|.

\item[\texttt{wait(Duration)}] Suspends for \verb|Duration| milliseconds, then succeeds. Uses standard GLP suspension mechanism: creates a fresh reader/writer pair, starts a timer, suspends on the reader. When the timer fires, it binds the writer, reactivating the goal via the normal ROQ mechanism.

\item[\texttt{wait\_until(Timestamp)}] Succeeds if the current time (milliseconds since epoch) is greater than or equal to \verb|Timestamp|. \textbf{Note:} This is a test, not a blocking wait. If the time has not yet passed, it \emph{fails} (not suspends), allowing the next clause to be tried.
\end{description}

\subsection{Guard Negation}

Any negatable guard \verb|G| can be negated using the syntax \verb|~G|. The negated guard succeeds when \verb|G| fails, fails when \verb|G| succeeds, and suspends when \verb|G| suspends.

\mypara{Negatable guards}
Type guards: \verb|ground|, \verb|known|, \verb|unknown|, \verb|integer|, \verb|number|, \verb|constant|, \verb|compound|, \verb|tuple|, \verb|list|, \verb|is_list|, \verb|writer|, \verb|reader|. Equality guard: \verb|=?=|.

\mypara{Non-negatable guards}
Arithmetic comparisons (\verb|<|, \verb|>|, \verb|=<|, \verb|>=|, \verb|=:=|, \verb|=\=|) cannot be negated. Control guards (\verb|otherwise|) and time guards (\verb|wait|, \verb|wait_until|) also cannot be negated.

\mypara{Restrictions}
Only built-in guards can be negated. Defined guards (unit clauses) cannot be negated. Double negation \verb|~~G| is syntactically forbidden.

\mypara{Examples}
\begin{verbatim}
% Handle non-integers
process(X, Y) :- ~integer(X?) | handle_non_int(X?, Y).
process(X, Y) :- integer(X?) | handle_int(X?, Y).

% Structural inequality via negated equality
lookup(Key, [(K,V)|_], V?) :- Key? =?= K? | true.
lookup(Key, [(K,_)|Rest], V?) :- ~(Key? =?= K?) | lookup(Key?, Rest?, V).
\end{verbatim}

\section{System Predicates}

System predicates execute atomically with goal reduction, providing access to runtime services.

\begin{description}
\item[\texttt{X? := Expr}] Evaluate arithmetic expression \verb|Expr| and bind result to \verb|X|. The expression must be ground. See Section~\ref{sec:arithmetic} for operators.

\item[\texttt{current\_time(T)}] Bind \verb|T| to the current system timestamp (milliseconds since epoch).

\item[\texttt{get\_time(T)}] Synonym for \verb|current_time(T)|. Binds \verb|T| to current timestamp.

\item[\texttt{variable\_name(X, Name)}] Bind \verb|Name| to a unique string identifier for variable \verb|X|.

\item[\texttt{functor(Term, F, N)}] Unify \verb|F| with the functor and \verb|N| with the arity of \verb|Term|.

\item[\texttt{arg(N, Term, Arg)}] Unify \verb|Arg| with the \verb|N|th argument of \verb|Term| (1-indexed).

\item[\texttt{copy\_term(Term, Copy)}] Create \verb|Copy| as a renamed copy of \verb|Term| with fresh variables.

\item[\texttt{abort(Message)}] Terminate execution with error message.
\end{description}

\section{Arithmetic}
\label{sec:arithmetic}

Arithmetic expressions are evaluated using the \verb|:=| operator:
\begin{verbatim}
Result? := Expression
\end{verbatim}

The expression must be ground at evaluation time. The definition:
\begin{verbatim}
X? := E :- ground(E?) | evaluate(E?, X).
\end{verbatim}

\subsection{Arithmetic Operators}

\begin{center}
\begin{tabular}{lll}
\textbf{Operator} & \textbf{Description} & \textbf{Example} \\
\hline
\verb|X + Y| & Addition & \verb|R := 3 + 4| \\
\verb|X - Y| & Subtraction & \verb|R := 7 - 2| \\
\verb|X * Y| & Multiplication & \verb|R := 3 * 4| \\
\verb|X / Y| & Division (float result) & \verb|R := 7 / 2| \\
\verb|X // Y| & Integer division & \verb|R := 7 // 2| \\
\verb|X mod Y| & Modulo & \verb|R := 7 mod 3| \\
\verb|-X| & Unary negation & \verb|R := -5| \\
\verb|abs(X)| & Absolute value & \verb|R := abs(-5)| \\
\verb|sqrt(X)| & Square root & \verb|R := sqrt(16)| \\
\verb|sin(X)| & Sine (radians) & \verb|R := sin(3.14)| \\
\verb|cos(X)| & Cosine (radians) & \verb|R := cos(0)| \\
\verb|tan(X)| & Tangent (radians) & \verb|R := tan(0.5)| \\
\verb|exp(X)| & Exponential ($e^X$) & \verb|R := exp(1)| \\
\verb|ln(X)| & Natural logarithm & \verb|R := ln(2.718)| \\
\verb|log(X)| & Base-10 logarithm & \verb|R := log(100)| \\
\verb|min(X,Y)| & Minimum & \verb|R := min(3,5)| \\
\verb|max(X,Y)| & Maximum & \verb|R := max(3,5)| \\
\verb|X ** Y| & Exponentiation & \verb|R := 2 ** 10| \\
\end{tabular}
\end{center}

\subsection{Bitwise Operators}

\begin{center}
\begin{tabular}{lll}
\textbf{Operator} & \textbf{Description} & \textbf{Example} \\
\hline
\verb|X /\\ Y| & Bitwise AND & \verb|R := 5 /\\ 3| \\
\verb|X \\/ Y| & Bitwise OR & \verb|R := 5 \\/ 3| \\
\verb|X xor Y| & Bitwise XOR & \verb|R := 5 xor 3| \\
\verb|\\X| & Bitwise complement & \verb|R := \\5| \\
\verb|X << N| & Left shift & \verb|R := 1 << 4| \\
\verb|X >> N| & Right shift & \verb|R := 16 >> 2| \\
\end{tabular}
\end{center}

\section{Channel Abstractions}

Channels provide bidirectional communication. A channel is represented as \verb|ch(In?, Out)| where \verb|In?| is the input stream reader and \verb|Out| is the output stream writer.

\begin{verbatim}
% Send message X on channel, return updated channel
send(X, ch(In, [X?|Out?]), ch(In?, Out)).

% Receive message X from channel, return updated channel
receive(X?, ch([X|In], Out?), ch(In?, Out)).

% Create paired channels for bidirectional communication
new_channel(ch(Xs?, Ys), ch(Ys?, Xs)).
\end{verbatim}

These are typically defined as guard predicates for use in clause heads:
\begin{verbatim}
relay(In, Out?, Ch) :-
    In? = [X|In1], send(X?, Ch?, Ch1) |
    relay(In1?, Out, Ch1?).
\end{verbatim}

\section{Standard Library Predicates}

\subsection{List Operations}

\begin{verbatim}
% Append two lists
append([], Ys?, Ys).
append([X|Xs], Ys, [X?|Zs?]) :- append(Xs?, Ys?, Zs).

% List length
length([], 0?).
length([_|Xs], N?) :- length(Xs?, N1), N := N1? + 1.

% List membership (suspends until found or list exhausted)
member(X?, [X|_]).
member(X, [_|Xs]) :- member(X?, Xs?).

% Reverse a list
reverse(Xs, Ys?) :- reverse_acc(Xs?, [], Ys).
reverse_acc([], Acc?, Acc).
reverse_acc([X|Xs], Acc, Ys?) :- reverse_acc(Xs?, [X?|Acc?], Ys).
\end{verbatim}

\subsection{Stream Operations}

\begin{verbatim}
% Merge two streams fairly
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Ys?, Xs?, Zs).
merge(Xs, [Y|Ys], [Y?|Zs?]) :- merge(Xs?, Ys?, Zs).
merge([], [], []).

% Distribute stream to multiple consumers (requires ground elements)
distribute([X|Xs], [X|Ys1?], [X|Ys2?]) :-
    ground(X?) | distribute(Xs?, Ys1, Ys2).
distribute([], [], []).

% Tag stream elements with source identifier
tag_stream(Name, [M|In], [msg(Name?, M?)|Out]) :-
    tag_stream(Name?, In?, Out?).
tag_stream(_, [], []).
\end{verbatim}

\section{Stream Security Properties}
\label{sec:stream-security-appendix}

Authenticated \GLP streams achieve blockchain-like security through language-level guarantees:

\begin{description}
\item[Immutability] Once stream element \verb|[X|Xs]| is created with \verb|X| bound to value $T$, single-assignment semantics prevents any subsequent assignment to \verb|X|.

\item[Unforkability] The SRSW invariant ensures each writer \verb|Xs| has exactly one occurrence. Attempting two continuations \verb|Xs=[Y|Ys]| and \verb|Xs=[Z|Zs]| would require two occurrences of writer \verb|Xs|, violating SRSW.

\item[Non-repudiation] In authenticated \GLP, stream extensions carry attestations $(Xs\!:=\![Y|Ys])_{M,p,q}$. The signature by agent $p$ provides cryptographic proof of authorship.

\item[Acyclicity] The occurs check prevents a writer from being bound to a term containing its paired reader, ensuring strict temporal ordering.
\end{description}

These properties emerge from \GLP's core semantics rather than requiring additional cryptographic protocols.

\section{Execution Model Summary}

\begin{enumerate}
\item Goals are selected from the active queue (FIFO).
\item Clauses are tried top-to-bottom until one succeeds.
\item Unification proceeds left-to-right, depth-first.
\item If unification requires binding a reader, the goal suspends.
\item When a writer is bound, goals suspended on its reader are reactivated.
\item Failed goals (no clause matches, no suspension possible) are recorded.
\item Computation terminates when the active queue is empty.
\end{enumerate}
