\chapter{Writer Unification Catalog}\label{appendix:unification-catalog}

This appendix provides a comprehensive catalog of writer unification outcomes, derived systematically from Definition~\ref{definition:GLP-unification}. Each entry shows the outcome when unifying a goal term with a clause head term, following the three-case priority: succeed, suspend, fail.

The ``First Use'' column indicates where each case first appears with explanation in the main text. Subsequent occurrences reference back to that section.

\section{Notation}

Throughout this catalog:
\begin{itemize}
\item $c, d$ denote distinct constants
\item $X, Y$ denote goal writers (from the goal being reduced)
\item $X?, Y?$ denote goal readers
\item $V, W$ denote head writers (fresh, from the renamed clause)
\item $V?, W?$ denote head readers (fresh)
\item $\leftarrow$ denotes assignment direction in the resulting writer assignment
\end{itemize}

Head variables are always fresh (renamed apart), so they never conflict with goal variables.

%=============================================================================
\section{Atomic Term Unification}\label{appendix:atomic-unification}

These cases cover unification at a single argument position with atomic terms (constants and variables).

\subsection{Constant vs.\ Constant}

\begin{center}
\begin{tabular}{llll}
\textbf{Goal} & \textbf{Head} & \textbf{Outcome} & \textbf{First Use} \\
\hline
$c$ & $c$ & succeeds with $\emptyset$ & §\ref{sec:constants-unary} \\
$c$ & $d$ & fails & §\ref{sec:constants-unary} \\
\end{tabular}
\end{center}

Identical constants unify with the empty assignment. Distinct constants have no unifier.

\subsection{Constant vs.\ Variable}

\begin{center}
\begin{tabular}{lllll}
\textbf{Goal} & \textbf{Head} & \textbf{Outcome} & \textbf{Assignment} & \textbf{First Use} \\
\hline
$c$ & $V$ & succeeds & $\{V \leftarrow c\}$ & §\ref{sec:constants-gates} \\
$c$ & $V?$ & succeeds & $\{V \leftarrow c\}$ & §\ref{sec:constants-gates} \\
\end{tabular}
\end{center}

A constant against a head variable (writer or reader) succeeds. Head readers $V?$ behave like head writers for unification because $V$ is fresh and can be assigned. The induced reader assignment then propagates the value to $V?$.

\subsection{Goal Writer vs.\ Term}

\begin{center}
\begin{tabular}{lllll}
\textbf{Goal} & \textbf{Head} & \textbf{Outcome} & \textbf{Assignment} & \textbf{First Use} \\
\hline
$X$ & $c$ & succeeds & $\{X \leftarrow c\}$ & §\ref{sec:constants-unary} \\
$X$ & $V$ & fails (WxW) & --- & §\ref{sec:streams-wxw-selection} \\
$X$ & $V?$ & succeeds & $\{X \leftarrow V?\}$ & §\ref{sec:constants-gates} \\
\end{tabular}
\end{center}

Goal writers can receive values (constants or reader references). Writer-to-writer ($X$ vs $V$) fails because it would abandon both paired readers $X?$ and $V?$.

The case $X$ vs $V?$ succeeds: the goal writer $X$ is assigned the head reader $V?$. This connects two communication channels---when $V$ is later bound, the value flows to both $V?$ and (via $X$) to $X?$.

\subsection{Goal Reader vs.\ Term}

\begin{center}
\begin{tabular}{lllll}
\textbf{Goal} & \textbf{Head} & \textbf{Outcome} & \textbf{Suspension Set} & \textbf{First Use} \\
\hline
$X?$ & $c$ & suspends & $\{X?\}$ & §\ref{sec:constants-binary} \\
$X?$ & $V$ & succeeds & $\{V \leftarrow X?\}$ & §\ref{sec:constants-gates} \\
$X?$ & $V?$ & succeeds & $\{V \leftarrow X?\}$ & §\ref{sec:constants-gates} \\
\end{tabular}
\end{center}

Goal readers cannot be assigned. When a goal reader meets a constant, the goal must wait for its paired writer $X$ to provide a value---hence suspension on $\{X?\}$.

When a goal reader meets a head variable (writer or reader), the head writer $V$ is assigned the goal reader $X?$. This succeeds because only head writers are being assigned.

%=============================================================================
\section{Compound Term Unification}\label{appendix:compound-unification}

Compound terms unify by matching functors and recursively unifying arguments.

\subsection{Functor Matching}

\begin{center}
\begin{tabular}{llll}
\textbf{Goal} & \textbf{Head} & \textbf{Outcome} & \textbf{First Use} \\
\hline
$f(...)$ & $f(...)$ & recursive on arguments & §\ref{sec:buffer-difference-list} \\
$f(...)$ & $g(...)$ & fails & §\ref{sec:buffer-difference-list} \\
$f/n$ & $f/m$ & fails (if $n \neq m$) & §\ref{sec:buffer-difference-list} \\
\end{tabular}
\end{center}

Terms with different functors or arities cannot unify.

\subsection{Variable vs.\ Compound}

\begin{center}
\begin{tabular}{lllll}
\textbf{Goal} & \textbf{Head} & \textbf{Outcome} & \textbf{Assignment} & \textbf{First Use} \\
\hline
$X$ & $f(...)$ & succeeds & $\{X \leftarrow f(...)\}$ & §\ref{sec:buffer-difference-list} \\
$X?$ & $f(...)$ & suspends & $\{X?\}$ & §\ref{sec:buffer-difference-list} \\
$f(...)$ & $V$ & succeeds & $\{V \leftarrow f(...)\}$ & §\ref{sec:buffer-difference-list} \\
$f(...)$ & $V?$ & succeeds & $\{V \leftarrow f(...)\}$ & §\ref{sec:buffer-difference-list} \\
\end{tabular}
\end{center}

Goal writers can be assigned compound terms. Goal readers suspend waiting for their paired writer.

%=============================================================================
\section{List Structure Cases}\label{appendix:list-unification}

Lists are the primary data structure for stream communication. These cases are essential for understanding merge, split, and pipeline programs.

\subsection{Cons Cell Matching}

\begin{center}
\begin{tabular}{lllll}
\textbf{Goal} & \textbf{Head} & \textbf{Outcome} & \textbf{Notes} & \textbf{First Use} \\
\hline
$[X|Xs]$ & $[H|Hs]$ & succeeds & Both writers, recursive & §\ref{sec:streams-reverse} \\
$[X|Xs]$ & $[H|Hs?]$ & succeeds & Goal tail writer, head tail reader & §\ref{sec:streams-merge} \\
$[X?|Xs?]$ & $[H|Hs]$ & suspends on $\{X?\}$ & Consumer waiting for element & §\ref{sec:streams-producer-consumer} \\
$[X|Xs?]$ & $[H|Hs]$ & succeeds & Element ready, tail waiting & §\ref{sec:streams-producer-consumer} \\
$[X?|Xs]$ & $[H|Hs]$ & suspends on $\{X?\}$ & Element not ready & §\ref{sec:streams-producer-consumer} \\
\end{tabular}
\end{center}

\subsection{Writer/Reader Tail Discrimination}

This is the key mechanism for clause selection in concurrent observers:

\begin{center}
\begin{tabular}{lllll}
\textbf{Goal} & \textbf{Head} & \textbf{Outcome} & \textbf{Why} & \textbf{First Use} \\
\hline
$[X|Xs]$ & $[H|Hs]$ & fails (WxW on tail) & $Xs$ vs $Hs$ both writers & §\ref{sec:streams-wxw-selection} \\
$[X|Xs]$ & $[H|Hs?]$ & succeeds & $Xs$ assigned $Hs?$ & §\ref{sec:streams-wxw-selection} \\
$[X|Xs?]$ & $[H|Hs]$ & succeeds & $Hs$ assigned $Xs?$ & §\ref{sec:streams-wxw-selection} \\
$[X|Xs?]$ & $[H|Hs?]$ & succeeds & $Hs$ assigned $Xs?$ & §\ref{sec:streams-wxw-selection} \\
\end{tabular}
\end{center}

Programs use WxW failure on tails to discriminate which stream is producing. A clause with writer tail matches goals with reader tail, and vice versa.

\subsection{Empty List Cases}

\begin{center}
\begin{tabular}{llll}
\textbf{Goal} & \textbf{Head} & \textbf{Outcome} & \textbf{First Use} \\
\hline
$[]$ & $[]$ & succeeds & §\ref{sec:streams-reverse} \\
$[]$ & $[H|Hs]$ & fails & §\ref{sec:streams-reverse} \\
$[X|Xs]$ & $[]$ & fails & §\ref{sec:streams-reverse} \\
$Xs$ (writer) & $[]$ & succeeds, $\{Xs \leftarrow []\}$ & §\ref{sec:streams-producer-consumer} \\
$Xs?$ (reader) & $[]$ & suspends on $\{Xs?\}$ & §\ref{sec:streams-producer-consumer} \\
\end{tabular}
\end{center}

\subsection{Variable vs.\ List}

\begin{center}
\begin{tabular}{lllll}
\textbf{Goal} & \textbf{Head} & \textbf{Outcome} & \textbf{Assignment} & \textbf{First Use} \\
\hline
$Xs$ & $[H|Hs]$ & succeeds & $\{Xs \leftarrow [H|Hs]\}$ & §\ref{sec:streams-producer-consumer} \\
$Xs?$ & $[H|Hs]$ & suspends & $\{Xs?\}$ & §\ref{sec:streams-producer-consumer} \\
$[X|Xs]$ & $Ys$ & succeeds & $\{Ys \leftarrow [X|Xs]\}$ & §\ref{sec:streams-merge} \\
$[X|Xs]$ & $Ys?$ & succeeds & $\{Ys \leftarrow [X|Xs]\}$ & §\ref{sec:streams-merge} \\
\end{tabular}
\end{center}

%=============================================================================
\section{Difference List Cases}\label{appendix:dl-unification}

Difference lists use paired hole/tail variables for efficient append. The threading mechanism depends on specific unification outcomes.

\subsection{Difference List Argument Pairs}

A difference list is represented as two arguments $(List, Hole)$ where $Hole$ is the uninstantiated tail of $List$.

\begin{center}
\begin{tabular}{lllll}
\textbf{Goal DL} & \textbf{Head DL} & \textbf{Outcome} & \textbf{Threading} & \textbf{First Use} \\
\hline
$(L, H)$ & $(L', H')$ & succeeds & $L$ unified with $L'$, $H$ with $H'$ & §\ref{sec:buffer-difference-list} \\
$(L?, H)$ & $(L', H')$ & suspends & Waiting for input list & §\ref{sec:buffer-difference-list} \\
$(L, H?)$ & $(L', H')$ & succeeds & Hole provided by caller & §\ref{sec:buffer-difference-list} \\
\end{tabular}
\end{center}

\subsection{Accumulator Threading}

The standard difference list accumulator uses:
\begin{verbatim}
flatten(Tree, Xs, Xs0?) :- ... body uses Xs?, Xs0 ...
\end{verbatim}

\begin{center}
\begin{tabular}{llll}
\textbf{Position} & \textbf{Mode} & \textbf{Role} & \textbf{First Use} \\
\hline
$Xs$ (head writer) & output & Receives constructed list & §\ref{sec:buffer-difference-list} \\
$Xs?$ (body reader) & input to body & Body reads accumulator & §\ref{sec:buffer-difference-list} \\
$Xs0?$ (head reader) & input & Hole from caller & §\ref{sec:buffer-difference-list} \\
$Xs0$ (body writer) & output from body & Body extends list & §\ref{sec:buffer-difference-list} \\
\end{tabular}
\end{center}

%=============================================================================
\section{Guard Evaluation Cases}\label{appendix:guard-unification}

Guards use the same writer unification but with different operational intent: testing rather than binding.

\subsection{Equality Guards}

\begin{center}
\begin{tabular}{llll}
\textbf{Guard} & \textbf{Outcome} & \textbf{Notes} & \textbf{First Use} \\
\hline
$X = c$ & succeeds, binds $X$ & Writer in guard & §\ref{??} \\
$X? = c$ & suspends & Reader needs value first & §\ref{??} \\
$X =?= Y$ & succeeds if equal & Equality test, no binding & §\ref{??} \\
$X \neq Y$ & succeeds if different & Disequality test & §\ref{??} \\
\end{tabular}
\end{center}

\subsection{Type-Testing Guards}

\begin{center}
\begin{tabular}{llll}
\textbf{Guard} & \textbf{Behavior} & \textbf{On Reader} & \textbf{First Use} \\
\hline
\texttt{ground(X)} & succeeds if $X$ ground & suspends if $X?$ unbound & §\ref{sec:constants-gates} \\
\texttt{integer(X)} / \texttt{number(X)} & succeeds if numeric & suspends if $X?$ unbound & §\ref{sec:quicksort} \\
\texttt{atomic(X)} & succeeds if atomic & suspends if $X?$ unbound & §\ref{??} \\
\texttt{compound(X)} & succeeds if compound & suspends if $X?$ unbound & §\ref{??} \\
\end{tabular}
\end{center}

\subsection{Otherwise Guard}

\begin{center}
\begin{tabular}{lll}
\textbf{Guard} & \textbf{Behavior} & \textbf{First Use} \\
\hline
\texttt{otherwise} & succeeds if all prior clauses fail or suspend & §\ref{sec:streams-dynamic-merge} \\
\end{tabular}
\end{center}

The \texttt{otherwise} guard commits only when no prior clause can possibly succeed---either they failed or they suspended and this clause would not conflict.

%=============================================================================
\section{Clause Selection Mechanisms}\label{appendix:clause-selection}

These cases show how writer unification enables clause selection based on argument structure and mode.

\subsection{Selection by Structure}

\begin{center}
\begin{tabular}{lllll}
\textbf{Goal} & \textbf{Clause 1 Head} & \textbf{Clause 2 Head} & \textbf{Selected} & \textbf{First Use} \\
\hline
\texttt{p([a|Xs],...)} & \texttt{p([H|T],...)} & \texttt{p([],...)} & Clause 1 & §\ref{sec:streams-reverse} \\
\texttt{p([],...)} & \texttt{p([H|T],...)} & \texttt{p([],...)} & Clause 2 & §\ref{sec:streams-reverse} \\
\texttt{p(X,...)} & \texttt{p([H|T],...)} & \texttt{p([],...)} & Suspends & §\ref{sec:streams-producer-consumer} \\
\texttt{p(X?,...)} & \texttt{p([H|T],...)} & \texttt{p([],...)} & Suspends & §\ref{sec:streams-producer-consumer} \\
\end{tabular}
\end{center}

\subsection{Selection by Tail Mode (Cooperative Streams)}

For observing two streams that cooperatively produce to a shared output:

\begin{center}
\begin{tabular}{lllll}
\textbf{Goal Tails} & \textbf{C1: writer/reader} & \textbf{C2: reader/writer} & \textbf{Selected} & \textbf{First Use} \\
\hline
writer, reader & fails C1, succeeds C2 & C2 & §\ref{sec:streams-wxw-selection} \\
reader, writer & succeeds C1 & C1 & §\ref{sec:streams-wxw-selection} \\
writer, writer & fails C1, fails C2 & deadlock & §\ref{sec:streams-wxw-selection} \\
reader, reader & suspends both & suspends & §\ref{sec:streams-wxw-selection} \\
\end{tabular}
\end{center}

This mechanism enables fair merge without explicit scheduling.

\subsection{Selection by Ground Guard}

\begin{center}
\begin{tabular}{llll}
\textbf{Goal} & \textbf{Guard} & \textbf{Outcome} & \textbf{First Use} \\
\hline
\texttt{p(a,...)} & \texttt{ground(X)} & succeeds & §\ref{sec:constants-gates} \\
\texttt{p(X,...)} & \texttt{ground(X)} & fails (X unbound) & §\ref{sec:constants-gates} \\
\texttt{p(X?,...)} & \texttt{ground(X?)} & suspends & §\ref{sec:constants-gates} \\
\texttt{p(f(a,b),...)} & \texttt{ground(X)} & succeeds & §\ref{sec:constants-gates} \\
\texttt{p(f(a,Y),...)} & \texttt{ground(X)} & fails (Y unbound) & §\ref{sec:constants-gates} \\
\end{tabular}
\end{center}

%=============================================================================
\section{Suspension and Reactivation}\label{appendix:suspension}

\subsection{Suspension Set Computation}

Given a regular mgu $\sigma$, the suspension set is:
$$W_\sigma = \{X? \in V? : X?\sigma \notin \mathcal{V}\}$$

That is, goal readers that would be mapped to non-variables.

For compound terms, the operational algorithm uses two phases:
\begin{enumerate}
\item \textbf{Collection}: Process arguments left-to-right, accumulating tentative writer bindings $\hat\sigma_w$ and a preliminary suspension set $S$ (readers matched against constants or structures whose paired writers are not yet in $\hat\sigma_w$).
\item \textbf{Resolution}: Compute $S' = \{X? \in S : X \notin \mathrm{dom}(\hat\sigma_w)\}$. If $S' = \emptyset$, succeed with $\hat\sigma_w$. Otherwise, suspend on $S'$.
\end{enumerate}

This two-phase approach ensures that a reader encountered before its paired writer is bound does not cause spurious suspension. For example, goal $p(X?, X)$ against head $p(a, a)$ succeeds: phase 1 adds $X?$ to $S$ and $X := a$ to $\hat\sigma_w$; phase 2 finds $X \in \mathrm{dom}(\hat\sigma_w)$, so $S' = \emptyset$.

\begin{center}
\begin{tabular}{llll}
\textbf{Goal} & \textbf{Head} & \textbf{Suspension Set} & \textbf{First Use} \\
\hline
$f(X?, a)$ & $f(b, Y)$ & $\{X?\}$ & §\ref{sec:constants-gates} \\
$f(X?, Y?)$ & $f(a, b)$ & $\{X?, Y?\}$ & §\ref{sec:constants-gates} \\
$f(X?, Y)$ & $f(a, b)$ & $\{X?\}$ & §\ref{sec:constants-gates} \\
$f(X, Y?)$ & $f(a, b)$ & $\{Y?\}$ & §\ref{sec:constants-gates} \\
\end{tabular}
\end{center}

\subsection{Reactivation Conditions}

A suspended goal reactivates when \emph{any} reader in its suspension set receives a value from its paired writer:

\begin{center}
\begin{tabular}{lll}
\textbf{Suspended On} & \textbf{Reactivates When} & \textbf{First Use} \\
\hline
$\{X?\}$ & $X$ is assigned & §\ref{sec:constants-gates} \\
$\{X?, Y?\}$ & $X$ or $Y$ is assigned & §\ref{sec:constants-gates} \\
\end{tabular}
\end{center}

Upon reactivation, clause matching restarts from the first clause.

%=============================================================================
\section{Cross-Reference Index}

\emph{To be completed: alphabetical index of cases by program construct.}

\begin{description}
\item[append] §\ref{sec:streams-reverse}: list threading, accumulator
\item[bounded buffer] §\ref{sec:buffer-difference-list}: difference lists, suspension for flow control
\item[flatten] §\ref{??}: difference list threading
\item[merge] §\ref{sec:streams-merge}: stream interleaving, tail mode selection
\item[observer] §\ref{sec:streams-wxw-selection}: writer/reader tail discrimination
\item[producer-consumer] §\ref{sec:streams-producer-consumer}: reader suspension, writer assignment
\item[quicksort] §\ref{sec:quicksort}: partition by comparison, type-testing guards
\item[reverse] §\ref{sec:streams-reverse}: accumulator, empty list matching
\item[split] §\ref{??}: alternating element distribution
\end{description}
