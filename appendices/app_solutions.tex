% appendices/app_solutions.tex - Exercise Solutions

\chapter{Selected Exercise Solutions}
\label{app:solutions}

This appendix provides solutions to selected exercises from the main text.

\section{Chapter~\ref{ch:streams}: Streams}

\subsection{Exercise~\ref{ex:biased-merge}: Biased Merge}

Implement a biased merge operator that maintains fairness in dynamically-constructed trees by tracking subtree weights.

\begin{verbatim}
% Biased merge with weight tracking
% Bx, By: weights of left and right subtrees
% N: counter for current priority stream

bmerge(X, Y, [started?|Z?]) :- bmerge(1, 1, 1, X?, Y?, Z).

% Counter exhausted: switch priorities
bmerge(Bx, By, 0, X, Y, Z?) :- bmerge(By?, Bx?, By?, Y?, X?, Z).

% Forward from high-priority stream
bmerge(Bx, By, N, [M|X], Y, Out?) :- N? > 0 |
    forward_msg(M?, Bx?, By?, N?, X?, Y?, Out).

% Forward from low-priority stream (only if high-priority has no message)
bmerge(Bx, By, N, X, [M|Y], Out?) :- N? > 0, unknown(X?) |
    forward_msg(M?, By?, Bx?, N?, Y?, X?, Out).

% End of stream
bmerge(_, _, _, [], Y, [halted?|Y?]).
bmerge(_, _, _, X, [], [halted?|X?]).

% Handle control messages
forward_msg(started, Bx, By, N, X, Y, [started?|Z?]) :-
    Bx1 := Bx? + 1,
    bmerge(Bx1?, By?, N?, X?, Y?, Z).
forward_msg(halted, Bx, By, N, X, Y, [halted?|Z?]) :-
    Bx1 := Bx? - 1,
    bmerge(Bx1?, By?, N?, X?, Y?, Z).
forward_msg(M, Bx, By, N, X, Y, [M?|Z?]) :-
    M =\= started, M =\= halted |
    N1 := N? - 1,
    bmerge(Bx?, By?, N1?, X?, Y?, Z).
\end{verbatim}

The key ideas:
\begin{itemize}
\item Each merge node tracks \verb|Bx| and \verb|By|, the weights of its subtrees
\item When \verb|started| arrives, increment the weight; when \verb|halted| arrives, decrement
\item The counter \verb|N| determines how many messages to forward from the high-priority side before switching
\item When \verb|N| reaches 0, swap priorities: the other stream becomes high-priority with counter reset to its weight
\end{itemize}

This achieves linear bounded-waiting: in a tree with $n$ leaves, a message waits at most $O(n)$ messages before exiting the root.

\subsection{Exercise~\ref{ex:length}: Stream Length}

Compute the length of a stream using an accumulator for tail recursion.

\begin{verbatim}
length(Xs, N?) :- length_acc(Xs?, 0, N).

length_acc([], Acc, Acc?).
length_acc([_|Xs], Acc, N?) :-
    Acc1 := Acc? + 1,
    length_acc(Xs?, Acc1?, N).
\end{verbatim}

The accumulator \verb|Acc| tracks the count seen so far. When the stream ends, the accumulated value is assigned to the output. This is $O(n)$ in both time and space (for the recursive calls, though GLP can optimize tail recursion).

\subsection{Exercise~\ref{ex:map-inc}: Increment Stream}

Apply increment to each element of a stream.

\begin{verbatim}
map_inc([], []).
map_inc([X|Xs], [Y?|Ys?]) :-
    Y := X? + 1,
    map_inc(Xs?, Ys).
\end{verbatim}

Each element \verb|X| from the input stream is incremented and placed in the output stream as \verb|Y|. The recursive call processes the tail concurrently as elements arrive.

\subsection{Exercise~\ref{ex:filter-even}: Filter Even Numbers}

Select only even numbers from a stream.

\begin{verbatim}
filter_even([], []).
filter_even([X|Xs], [X?|Ys?]) :-
    X? mod 2 =:= 0 |
    filter_even(Xs?, Ys).
filter_even([X|Xs], Ys?) :-
    X? mod 2 =\= 0 |
    filter_even(Xs?, Ys).
\end{verbatim}

The guard \verb|X? mod 2 =:= 0| tests whether \verb|X| is even. If so, \verb|X| is included in the output; otherwise, it is skipped. Both clauses have mutually exclusive guards, ensuring deterministic clause selection.
